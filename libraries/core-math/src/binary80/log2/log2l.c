/* Correctly rounded log2l function for binary80 floating point format.

Copyright (c) 2024-2025 Alexei Sibidanov and Paul Zimmermann

This file is part of the CORE-MATH project
(https://core-math.gitlabpages.inria.fr/).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/* References:
   [1] Note on the Veltkamp/Dekker Algorithms with Directed Roundings,
       Paul Zimmermann, https://inria.hal.science/hal-04480440, February 2024.
   [2] CR-LIBM A library of correctly rounded elementary functions in
       double-precision, Catherine Daramy-Loirat, David Defour,
       Florent de Dinechin, Matthieu Gallet, Nicolas Gast, Christoph Lauter,
       Jean-Michel Muller, https://ens-lyon.hal.science/ensl-01529804, 2017.
   [3] Handbook of Floating-Point Arithmetic, Jean-Michel Muller,
       Nicolas Brunie, Florent de Dinechin, Claude-Pierre Jeannerod,
       Mioara Joldes, Vincent Lef√®vre, Guillaume Melquiond, Nathalie Revol,
       Serge Torres, 2018.
 */

#include <stdint.h>
#include <errno.h>

// Warning: clang also defines __GNUC__
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
#endif

#pragma STDC FENV_ACCESS ON

// anonymous structs, see https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1p19
typedef union {
  long double f;
  struct __attribute__((__packed__)) {uint64_t m; uint32_t e:16; uint32_t empty:16;};
} b96u96_u;

typedef union {double f;uint64_t u;} b64u64_u;

static long double __attribute__((noinline)) log2_exact (int e) {return e;}

// Multiply exactly a and b, such that *hi + *lo = a * b.
static inline void a_mul_double (double *hi, double *lo, double a, double b) {
  *hi = a * b;
  *lo = __builtin_fma (a, b, -*hi);
}

// Returns (ah + al) * (bh + bl) - (al * bl)
// We can ignore al * bl when assuming al <= ulp(ah) and bl <= ulp(bh)
static inline void d_mul_double (double *hi, double *lo, double ah, double al,
                                 double bh, double bl) {
  double s, t;

  a_mul_double (hi, &s, ah, bh);
  t = __builtin_fma (al, bh, s);
  *lo = __builtin_fma (ah, bl, t);
}

/* s + t <- a + b, assuming |a| >= |b| */
static inline void
fast_two_sum_double (double *s, double *t, double a, double b)
{
  *s = a + b;
  double e = *s - a;
  *t = b - e;
}

/* For -37 <= i <= 26, T1[i+37] contains {r, h, l} such that
   for xmin := 1+i/128 <= x < xmax := 1+(i+1)/128 for -37 <= i <= -1,
       xmin := 1+i/64 <= x < xmax := 1+(i+1)/64 for 0 <= i <= 26,
   r is the 6-bit approximation minimizing max(abs(r*x-1))
   for xmin <= x < xmax,
   h approximates -log2(r) to nearest, with h multiple of 2^-38, and
   l approximates -log2(r)-h to nearest, with
   |h + l + log2(r)| < 2^-97.91.
   Ensures 0.982666015625000 <= r*x <= 1.01684570312500.
   Table generated by T1() from log2l.sage. */
static const double T1[64][3] = {                                              
   {0x1.68p+0, -0x1.f7a8568cbp-2, -0x1.b3b3864c60011p-44}, /* i=-37 */
   {0x1.6p+0, -0x1.d6753e033p-2, 0x1.5f101c141e67p-42}, /* i=-36 */
   {0x1.6p+0, -0x1.d6753e033p-2, 0x1.5f101c141e67p-42}, /* i=-35 */
   {0x1.58p+0, -0x1.b47ebf739p-2, 0x1.f57d6fae441c1p-40}, /* i=-34 */
   {0x1.58p+0, -0x1.b47ebf739p-2, 0x1.f57d6fae441c1p-40}, /* i=-33 */
   {0x1.5p+0, -0x1.91bba891fp-2, -0x1.708b4b2b5056cp-42}, /* i=-32 */
   {0x1.5p+0, -0x1.91bba891fp-2, -0x1.708b4b2b5056cp-42}, /* i=-31 */
   {0x1.5p+0, -0x1.91bba891fp-2, -0x1.708b4b2b5056cp-42}, /* i=-30 */
   {0x1.48p+0, -0x1.6e221cd9dp-2, -0x1.9bcaf1aa4168ap-43}, /* i=-29 */
   {0x1.48p+0, -0x1.6e221cd9dp-2, -0x1.9bcaf1aa4168ap-43}, /* i=-28 */
   {0x1.4p+0, -0x1.49a784bcdp-2, -0x1.b8afe492bf6ffp-42}, /* i=-27 */
   {0x1.4p+0, -0x1.49a784bcdp-2, -0x1.b8afe492bf6ffp-42}, /* i=-26 */
   {0x1.4p+0, -0x1.49a784bcdp-2, -0x1.b8afe492bf6ffp-42}, /* i=-25 */
   {0x1.38p+0, -0x1.24407ab0ep-2, -0x1.ce60916e52e91p-44}, /* i=-24 */
   {0x1.38p+0, -0x1.24407ab0ep-2, -0x1.ce60916e52e91p-44}, /* i=-23 */
   {0x1.3p+0, -0x1.fbc16b902p-3, -0x1.a0288ea36662ap-41}, /* i=-22 */
   {0x1.3p+0, -0x1.fbc16b902p-3, -0x1.a0288ea36662ap-41}, /* i=-21 */
   {0x1.3p+0, -0x1.fbc16b902p-3, -0x1.a0288ea36662ap-41}, /* i=-20 */
   {0x1.28p+0, -0x1.acf5e2db4p-3, -0x1.d927dfc23d978p-40}, /* i=-19 */
   {0x1.28p+0, -0x1.acf5e2db4p-3, -0x1.d927dfc23d978p-40}, /* i=-18 */
   {0x1.28p+0, -0x1.acf5e2db4p-3, -0x1.d927dfc23d978p-40}, /* i=-17 */
   {0x1.2p+0, -0x1.5c01a39fcp-3, 0x1.4bc302ffa76fbp-42}, /* i=-16 */
   {0x1.2p+0, -0x1.5c01a39fcp-3, 0x1.4bc302ffa76fbp-42}, /* i=-15 */
   {0x1.2p+0, -0x1.5c01a39fcp-3, 0x1.4bc302ffa76fbp-42}, /* i=-14 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-13 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-12 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-11 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-10 */
   {0x1.1p+0, -0x1.663f6fac8p-4, -0x1.13167ccc53826p-40}, /* i=-9 */
   {0x1.1p+0, -0x1.663f6fac8p-4, -0x1.13167ccc53826p-40}, /* i=-8 */
   {0x1.1p+0, -0x1.663f6fac8p-4, -0x1.13167ccc53826p-40}, /* i=-7 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-6 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-5 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-4 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-3 */
   {0x1p+0, 0x0p+0, 0x0p+0}, /* i=-2 */
   {0x1p+0, 0x0p+0, 0x0p+0}, /* i=-1 */
   {0x1p+0, 0x0p+0, 0x0p+0}, /* i=0 */
   {0x1.f8p-1, 0x1.743ee862p-6, -0x1.95539356f93dcp-43}, /* i=1 */
   {0x1.fp-1, 0x1.77394c9d8p-5, 0x1.58d55de5c381p-41}, /* i=2 */
   {0x1.e8p-1, 0x1.1bb32a6p-4, 0x1.52743318a8a57p-42}, /* i=3 */
   {0x1.ep-1, 0x1.7d60496dp-4, -0x1.12ce6312ebb82p-42}, /* i=4 */
   {0x1.d8p-1, 0x1.e0b1ae8f4p-4, -0x1.02a99b4c5a725p-40}, /* i=5 */
   {0x1.dp-1, 0x1.22dadc2acp-3, -0x1.96d25a5b8a19bp-40}, /* i=6 */
   {0x1.c8p-1, 0x1.563dc2ap-3, -0x1.4d37cde37c86bp-41}, /* i=7 */
   {0x1.cp-1, 0x1.8a8980acp-3, -0x1.0b36665592075p-41}, /* i=8 */
   {0x1.cp-1, 0x1.8a8980acp-3, -0x1.0b36665592075p-41}, /* i=9 */
   {0x1.b8p-1, 0x1.bfc67a8p-3, -0x1.667f21fa8423fp-44}, /* i=10 */
   {0x1.bp-1, 0x1.f5fd8a906p-3, 0x1.f1a4847f7b278p-42}, /* i=11 */
   {0x1.bp-1, 0x1.f5fd8a906p-3, 0x1.f1a4847f7b278p-42}, /* i=12 */
   {0x1.a8p-1, 0x1.169c05364p-2, -0x1.d4f1b95e0ff45p-43}, /* i=13 */
   {0x1.ap-1, 0x1.32bfee371p-2, -0x1.1979a5db68722p-42}, /* i=14 */
   {0x1.ap-1, 0x1.32bfee371p-2, -0x1.1979a5db68722p-42}, /* i=15 */
   {0x1.98p-1, 0x1.4f6fbb2cfp-2, -0x1.d33c38d8bd28dp-41}, /* i=16 */
   {0x1.9p-1, 0x1.6cb0f6866p-2, -0x1.b8afe492bf6ffp-41}, /* i=17 */
   {0x1.9p-1, 0x1.6cb0f6866p-2, -0x1.b8afe492bf6ffp-41}, /* i=18 */
   {0x1.88p-1, 0x1.8a8980acp-2, -0x1.0b36665592075p-40}, /* i=19 */
   {0x1.8p-1, 0x1.a8ff97181p-2, 0x1.4bc302ffa76fbp-43}, /* i=20 */
   {0x1.8p-1, 0x1.a8ff97181p-2, 0x1.4bc302ffa76fbp-43}, /* i=21 */
   {0x1.78p-1, 0x1.c819dc2d4p-2, 0x1.7f90e25762b12p-40}, /* i=22 */
   {0x1.78p-1, 0x1.c819dc2d4p-2, 0x1.7f90e25762b12p-40}, /* i=23 */
   {0x1.7p-1, 0x1.e7df5fe54p-2, -0x1.d532c412ba94ep-40}, /* i=24 */
   {0x1.7p-1, 0x1.e7df5fe54p-2, -0x1.d532c412ba94ep-40}, /* i=25 */
   {0x1.68p-1, 0x1.042bd4b9a8p-1, -0x1.b3b3864c60011p-44}, /* i=26 */
};

/* For -71 <= j <= 34, T2[j+71] contains {r, h, l} such that
   for xmin := 1+j/2^12 <= x < xmax := 1+(j+1)/2^12 for j < 0,
       xmin := 1+j/2^11 <= x < xmax := 1+(j+1)/2^11 for 0 <= j,
   r is a 21-bit approximation minimizing max(abs(r*x-1))
   for xmin <= x < xmax,
   h approximates -log2(r) to nearest, with h multiple of 2^-38, and
   l approximates -log2(r)-h to nearest, with |h + l + log2(r)| < 2^-94.31.
   Ensures 0.999755859375000 <= r*x <= 1.00024402141571.
   Table generated by T2() from log2l.sage. */
static const double T2[106][3] = {
   {0x1.047bcp+0, -0x1.9a6151ecp-6, -0x1.19a0256cc7f15p-40}, /* i=-71 */
   {0x1.046b3p+0, -0x1.948232aap-6, -0x1.f1526b900108bp-40}, /* i=-70 */
   {0x1.045aap+0, -0x1.8ea2b3cdp-6, 0x1.8b1e6fcd4ace2p-40}, /* i=-69 */
   {0x1.044a2p+0, -0x1.88c8824p-6, 0x1.61dcc6e227a12p-42}, /* i=-68 */
   {0x1.04399p+0, -0x1.82e84462p-6, 0x1.373d8ca7ca961p-41}, /* i=-67 */
   {0x1.0429p+0, -0x1.7d07a6c3p-6, -0x1.c4c11f7c1b847p-41}, /* i=-66 */
   {0x1.04188p+0, -0x1.772c5766p-6, -0x1.eac5d68098ebbp-40}, /* i=-65 */
   {0x1.0408p+0, -0x1.7150a8eap-6, 0x1.5aa40c86550b4p-40}, /* i=-64 */
   {0x1.03f78p+0, -0x1.6b749b41p-6, 0x1.39459e7479c96p-40}, /* i=-63 */
   {0x1.03e7p+0, -0x1.65982e5fp-6, -0x1.fa4636681c768p-40}, /* i=-62 */
   {0x1.03d68p+0, -0x1.5fbb623ap-6, 0x1.dd03362e2bcfep-44}, /* i=-61 */
   {0x1.03c61p+0, -0x1.59e3e6ap-6, -0x1.937129365683cp-42}, /* i=-60 */
   {0x1.03b59p+0, -0x1.54065c2ap-6, -0x1.c69b60748291ep-42}, /* i=-59 */
   {0x1.03a52p+0, -0x1.4e2e22ep-6, -0x1.1b617da7d846ep-40}, /* i=-58 */
   {0x1.0394ap+0, -0x1.484fd9eap-6, 0x1.dce8f9950b33cp-40}, /* i=-57 */
   {0x1.03843p+0, -0x1.4276e2cp-6, 0x1.9f65baf8badf7p-40}, /* i=-56 */
   {0x1.0373cp+0, -0x1.3c9d8cc2p-6, 0x1.3ebeca38bcf66p-40}, /* i=-55 */
   {0x1.03635p+0, -0x1.36c3d7e4p-6, 0x1.98e0c76d000acp-41}, /* i=-54 */
   {0x1.0352fp+0, -0x1.30ef767cp-6, -0x1.309fdfd94b65cp-40}, /* i=-53 */
   {0x1.03428p+0, -0x1.2b150417p-6, 0x1.6f392ddba5da1p-41}, /* i=-52 */
   {0x1.03321p+0, -0x1.253a32adp-6, -0x1.35635c3c37734p-40}, /* i=-51 */
   {0x1.0321bp+0, -0x1.1f64b5abp-6, -0x1.0b1d35fdf8d18p-40}, /* i=-50 */
   {0x1.03115p+0, -0x1.198eda46p-6, 0x1.60cdcd488dec8p-42}, /* i=-49 */
   {0x1.0300fp+0, -0x1.13b8a071p-6, -0x1.4f8797e878a2cp-40}, /* i=-48 */
   {0x1.02f09p+0, -0x1.0de20822p-6, 0x1.c2a977868f235p-40}, /* i=-47 */
   {0x1.02e03p+0, -0x1.080b114bp-6, 0x1.5ccec2121e904p-40}, /* i=-46 */
   {0x1.02cfdp+0, -0x1.0233bbe1p-6, 0x1.56030492b4395p-40}, /* i=-45 */
   {0x1.02bf8p+0, -0x1.f8c37af2p-7, -0x1.2968c466193e1p-45}, /* i=-44 */
   {0x1.02af2p+0, -0x1.ed135642p-7, -0x1.bfceccdb0262p-40}, /* i=-43 */
   {0x1.029edp+0, -0x1.e16de0dap-7, -0x1.5fe6d81e9aeedp-44}, /* i=-42 */
   {0x1.028e8p+0, -0x1.d5c7af5ep-7, 0x1.fb38add588fe3p-40}, /* i=-41 */
   {0x1.027e2p+0, -0x1.ca15538ep-7, -0x1.43906dfc8f09ep-40}, /* i=-40 */
   {0x1.026dep+0, -0x1.be7917c8p-7, 0x1.3e0967952f1d6p-40}, /* i=-39 */
   {0x1.025d9p+0, -0x1.b2d0b18p-7, 0x1.7b34cb74c9f29p-40}, /* i=-38 */
   {0x1.024d4p+0, -0x1.a7278ec4p-7, 0x1.b778083d7f023p-43}, /* i=-37 */
   {0x1.023cfp+0, -0x1.9b7daf7ep-7, 0x1.0d85c2753cf71p-40}, /* i=-36 */
   {0x1.022cbp+0, -0x1.8fde8556p-7, 0x1.6353e510c250ep-40}, /* i=-35 */
   {0x1.021c7p+0, -0x1.843e9fe4p-7, -0x1.033ee8c09fca4p-44}, /* i=-34 */
   {0x1.020c3p+0, -0x1.789dff12p-7, -0x1.0cb6a592fa8aep-43}, /* i=-33 */
   {0x1.01fbep+0, -0x1.6cf12edep-7, 0x1.e2ceae5e769a8p-40}, /* i=-32 */
   {0x1.01ebbp+0, -0x1.615a8aeep-7, 0x1.791f8d6131606p-41}, /* i=-31 */
   {0x1.01db7p+0, -0x1.55b7b76cp-7, 0x1.7d3eecfa0858dp-43}, /* i=-30 */
   {0x1.01cb3p+0, -0x1.4a14282ap-7, -0x1.f3f9733ae16b4p-40}, /* i=-29 */
   {0x1.01bbp+0, -0x1.3e7b53ep-7, -0x1.47ab7b2d3d278p-40}, /* i=-28 */
   {0x1.01aacp+0, -0x1.32d64d94p-7, 0x1.4c8a5706423dbp-40}, /* i=-27 */
   {0x1.019a9p+0, -0x1.273c037ep-7, -0x1.ccf2bb047250ep-40}, /* i=-26 */
   {0x1.018a6p+0, -0x1.1ba0febep-7, -0x1.769ef679d6cbfp-41}, /* i=-25 */
   {0x1.017a3p+0, -0x1.10053f3ap-7, -0x1.1cb1944133595p-41}, /* i=-24 */
   {0x1.016ap+0, -0x1.0468c4dcp-7, 0x1.b2ff1bb3638d6p-40}, /* i=-23 */
   {0x1.0159dp+0, -0x1.f1971f14p-8, 0x1.0aa2d7bae5645p-40}, /* i=-22 */
   {0x1.0149ap+0, -0x1.da5b3e5cp-8, 0x1.06b848ed802fdp-41}, /* i=-21 */
   {0x1.01398p+0, -0x1.c334e088p-8, 0x1.2feb7b6579b04p-40}, /* i=-20 */
   {0x1.01295p+0, -0x1.abf6148cp-8, -0x1.1f40f732b83a4p-46}, /* i=-19 */
   {0x1.01193p+0, -0x1.94cccdf8p-8, -0x1.187d565368a61p-40}, /* i=-18 */
   {0x1.01091p+0, -0x1.7da21378p-8, -0x1.6838c078e068p-40}, /* i=-17 */
   {0x1.00f8fp+0, -0x1.6675e4ep-8, 0x1.b80a1e148176dp-40}, /* i=-16 */
   {0x1.00e8dp+0, -0x1.4f4841f8p-8, -0x1.0331eba6fbad8p-40}, /* i=-15 */
   {0x1.00d8bp+0, -0x1.38192a9cp-8, 0x1.236194cc061b7p-40}, /* i=-14 */
   {0x1.00c8ap+0, -0x1.20ffa1d4p-8, -0x1.fff0f191ca3f4p-43}, /* i=-13 */
   {0x1.00b88p+0, -0x1.09cda26cp-8, 0x1.fba2d3a683d8ep-40}, /* i=-12 */
   {0x1.00a87p+0, -0x1.e5626838p-9, -0x1.59fece10fb53dp-41}, /* i=-11 */
   {0x1.00986p+0, -0x1.b726a7p-9, 0x1.4d7ffd4884496p-40}, /* i=-10 */
   {0x1.00885p+0, -0x1.88e800cp-9, -0x1.b6a56beda55c4p-40}, /* i=-9 */
   {0x1.00784p+0, -0x1.5aa6753p-9, 0x1.5affdfa901fd5p-41}, /* i=-8 */
   {0x1.00683p+0, -0x1.2c6203ep-9, -0x1.16682f328aec6p-40}, /* i=-7 */
   {0x1.00582p+0, -0x1.fc3559p-10, -0x1.13f7573bd6a89p-41}, /* i=-6 */
   {0x1.00481p+0, -0x1.9fa0dd6p-10, 0x1.a7c84a6887abfp-41}, /* i=-5 */
   {0x1.00381p+0, -0x1.4362d5p-10, -0x1.92a60f29d17e7p-40}, /* i=-4 */
   {0x1.0028p+0, -0x1.cd85866p-11, -0x1.266e85b118f54p-40}, /* i=-3 */
   {0x1.0018p+0, -0x1.14f25dap-11, 0x1.4dbb8c1b7c8c9p-40}, /* i=-2 */
   {0x1.0008p+0, -0x1.714eb1p-13, -0x1.fa53637548e21p-41}, /* i=-1 */
   {0x1.ffep-1, 0x1.7160018p-12, -0x1.ce69aa0cd2408p-41}, /* i=0 */
   {0x1.ffa01p-1, 0x1.14eb20bp-10, 0x1.88bc7cba50fc1p-40}, /* i=1 */
   {0x1.ff603p-1, 0x1.cd671a7p-10, 0x1.7acee5e60f7e1p-40}, /* i=2 */
   {0x1.ff206p-1, 0x1.42e5f108p-9, -0x1.9cb47e5f2191bp-41}, /* i=3 */
   {0x1.fee0ap-1, 0x1.9f0cb5f8p-9, -0x1.99ed09d4022adp-40}, /* i=4 */
   {0x1.fea0fp-1, 0x1.fb27d64p-9, -0x1.b8a2bed7ecfd6p-40}, /* i=5 */
   {0x1.fe615p-1, 0x1.2b9ba608p-8, 0x1.7b86ca8f5c2a1p-40}, /* i=6 */
   {0x1.fe21cp-1, 0x1.599d88d8p-8, -0x1.e06be4f8e2aaep-40}, /* i=7 */
   {0x1.fde24p-1, 0x1.8799909cp-8, 0x1.c7d3648f0c368p-40}, /* i=8 */
   {0x1.fda2dp-1, 0x1.b58fba78p-8, 0x1.802423618ccd3p-40}, /* i=9 */
   {0x1.fd637p-1, 0x1.e380038p-8, 0x1.cc3f1653f935ap-40}, /* i=10 */
   {0x1.fd242p-1, 0x1.08b53468p-7, -0x1.580171297fda4p-40}, /* i=11 */
   {0x1.fce4ep-1, 0x1.1fa773bcp-7, -0x1.e1639d33e2ebep-42}, /* i=12 */
   {0x1.fca5bp-1, 0x1.3696be4ap-7, -0x1.4f9f0cab3ff03p-41}, /* i=13 */
   {0x1.fc668p-1, 0x1.4d88e264p-7, -0x1.1fabcbbdf4c4cp-41}, /* i=14 */
   {0x1.fc277p-1, 0x1.64723fbep-7, 0x1.12be7ea905b9ap-40}, /* i=15 */
   {0x1.fbe87p-1, 0x1.7b58a3f4p-7, -0x1.7be683784334dp-41}, /* i=16 */
   {0x1.fba98p-1, 0x1.923c0d8ep-7, -0x1.2f6950844d149p-40}, /* i=17 */
   {0x1.fb6aap-1, 0x1.a91c7b16p-7, 0x1.606f3bc56ad08p-45}, /* i=18 */
   {0x1.fb2bcp-1, 0x1.bfffbe7ap-7, 0x1.28bfad00475d5p-42}, /* i=19 */
   {0x1.faedp-1, 0x1.d6da3036p-7, 0x1.cb30d69c134e7p-41}, /* i=20 */
   {0x1.faae5p-1, 0x1.edb1a17ep-7, 0x1.dfab14dab4dfcp-41}, /* i=21 */
   {0x1.fa6fap-1, 0x1.0245f334p-6, 0x1.a0892404dc1e8p-43}, /* i=22 */
   {0x1.fa311p-1, 0x1.0daea98ep-6, -0x1.8fe6239fa7f33p-40}, /* i=23 */
   {0x1.f9f29p-1, 0x1.1915dd7ap-6, 0x1.33036bdf2c583p-40}, /* i=24 */
   {0x1.f9b41p-1, 0x1.247e7a1ap-6, -0x1.5e7d47fac33eep-40}, /* i=25 */
   {0x1.f975bp-1, 0x1.2fe2a755p-6, 0x1.18095e895b257p-40}, /* i=26 */
   {0x1.f9375p-1, 0x1.3b483c84p-6, 0x1.56ed4a4a3d7c5p-41}, /* i=27 */
   {0x1.f8f91p-1, 0x1.46a9601ep-6, 0x1.5b29efdf84118p-40}, /* i=28 */
   {0x1.f8badp-1, 0x1.520beaecp-6, -0x1.03b032dfdace1p-41}, /* i=29 */
   {0x1.f87cap-1, 0x1.5d6cef9cp-6, 0x1.04db20ce629c8p-40}, /* i=30 */
   {0x1.f83e9p-1, 0x1.68c97f6dp-6, 0x1.dc5b320f9fe04p-40}, /* i=31 */
   {0x1.f8008p-1, 0x1.74277551p-6, 0x1.cd28b53917896p-41}, /* i=32 */
   {0x1.f7c28p-1, 0x1.7f83e2e2p-6, -0x1.815ec06d1acc1p-40}, /* i=33 */
   {0x1.f7849p-1, 0x1.8adec762p-6, -0x1.525408d2c98bcp-40}, /* i=34 */
};

/* return in h+l an approximation of log2(xh + xl)
   for -0.000244140625 <= xh < 0.00024402141571 and 0 <= xl < 2^-37.49,
   with |l| < 2^-62.17 */
static void
P (double *h, double *l, double xh, double xl)
{
  /* The following is a degree-8 minimax polynomial for log2(1+x)
     over [-0.000244140625,0.00024402141571] generated by Sollya
     (file log2_fast.sollya), with no constant coefficient, double
     coefficients except that of degree 1 which is a double-double,
     and maximal absolute error 2^-84.514. */
  static const double p[] = {
    0x1.71547652b82fep+0, 0x1.777d10fa9419cp-56, // degree 1
    -0x1.71547652b82fep-1,                      // degree 2
    0x1.ec709dc3a03fbp-2,                       // degree 3
    -0x1.71547661d011fp-2,                      // degree 4
    0x1.2776c56eb6ca2p-2,                       // degree 5
    -0x1.bd761baf2853cp-3,                      // degree 6
    0x1.24996255a29ecp-3,                       // degree 7
    -0x1.6c9c75469b616p17,                      // degree 8
  };
  fast_two_sum_double (&xh, &xl, xh, xl);
  // now -0.000244140625 <= xh < 0.00024402141571 and |xl| < 2^-64
  double xx = xh * xh;
  double c7 = __builtin_fma (p[8], xh, p[7]);
  double c5 = __builtin_fma (p[6], xh, p[5]);
  c5 = __builtin_fma (c7, xx, c5);
  double c3 = __builtin_fma (p[4], xh, p[3]);
  c3 = __builtin_fma (c5, xx, c3);
  fast_two_sum_double (h, l, p[2], c3*xh);
  d_mul_double (h, l, *h, *l, xh, xl);
  double t;
  fast_two_sum_double (h, &t, p[0], *h);
  *l += t + p[1];
  // multiply h+l by xh+xl
  d_mul_double (h, l, *h, *l, xh, xl);

  /* From analyzeP() in log2l.sage, the absolute error is bounded by 2^-84.39:
     |h + l - log2(1 + xh + xl)| < 2^-84.39 */
}

/* put in h+l an approximation of e + log2(x) for 1 <= x < 2
   with |h + l - (e + log2(x))| < 2^-84.19 and |l| < 2^-36.99 */
static void
fast_path (double *h, double *l, uint64_t vm, int e)
{
  /* convert x to double-double representation xh + xl, where xh is a
     multiple of 2^-38, thus is representable on 39 bits */

  b64u64_u th = {.u = ((uint64_t)0x3ff<<52) | ((vm >> 25) << 14)};
  b64u64_u tl = {.u = ((uint64_t)0x3d9<<52) | ((vm << 39) >> 12)};
  double xh = th.f, xl = tl.f - 0x1p-38;
  // 1 <= xh < 2 and 0 <= xl < 2^-38

  int64_t i = (vm << 1) >> 58; // 0 <= i < 2^6
  if (i > 26)
  {
    xh = xh * 0.5;
    xl = xl * 0.5;
    e ++;
    i -= 64;
  }

  /* now 0.7109375 <= xh < 1.421875 and 0 <= xl < 2^-38;
     for 0 <= i <= 26 we have 1 <= xh + xl < 1.421875
     for -37 <= i <= -1 we have 0.7109375 <= xh + xl < 1 */
  const double *ti = T1[i + 37];
  xh *= ti[0]; // exact
  xl *= ti[0]; // rounding error < ulp(xl) <= 2^-90
  
  /* since xh was multiple of 2^-38 and ti[0] is multiple of 2^-6,
     xh is now multiple of 2^-44 */

  // now 0.982666015625000 < xh < 1.01684570312500 and 0 <= xl < 2^-37.5

  th.f = xh;
  int j = (th.u >> 41) - 0x1ff800; // -71 <= j <= 34

  /* For -32 <= j < 0, we have 1 + j/2^12 <= x < 1 + (j+1)/2^12;
     for 0 <= j < 16, we have 1 + j/2^12 <= x < 1 + (j+1)/2^11.
     Since xh is multiple of 2^-44 and tj[0] is multiple of 2^-21,
     xh*tj[0] is multiple of 2^-65.
     Since 0.999755859375000 < xh < 1.00024402141571, xh-1 is exactly
     representable on 53 bits. */
  const double *tj = T2[j + 71];
  xh = __builtin_fma (xh, tj[0], -1.0); // exact
  xl *= tj[0]; // rounding error < ulp(xl) <= 2^-90
  /* Let xl0 be the initial value of xl, xl1 the value after xl *= ti[0],
     and xl2 the value after xl *= tj[0]: we have xl1 = xl*t1[0] + eps1
     with |eps1| < 2^-90, and xl2 = xl1*tj[0] + eps2 with |eps2| < 2^-90,
     thus xl2 = xl*t1[0]*tj[0] + eps1*tj[0] + eps2, with
     |eps1*tj[0] + eps2| < 2^-90*(0x1.01fbep+0 + 1) < 2^-88.99. */
  *h = (double) e + ti[1] + tj[1]; // exact since tx[1] multiples of 2^-38
  *l = ti[2] + tj[2];
  /* Since |ti[2]|, |tj[2]| < 2^-39, we have |l| < 2^-38, and the rounding
     error on l is bounded by 2^-90. */
  
  /* now xh + xl represents tj[0]*ti[0]*x - 1, with
     -0.000244140625 <= xh < 0.00024402141571 and 0 <= xl < 2^-37.49 */

  double ph, pl;
  P (&ph, &pl, xh, xl); // absolute error < 2^-84.39
  double t;
  fast_two_sum_double (h, &t, *h, ph);
  *l += t + pl; /* The rounding error is bounded by ulp(t+pl) + ulp(l).
                   Since |h| < 16445, we have |t| < ulp(h) <= 2^-38,
                   |pl| < 2^-62.17 thus ulp(t+pl) <= ulp(2^-37.99) = 2^-90,
                   and since we had |l| < 2^-38, the new value of l is
                   bounded by 2^-38 + 2^-37.99 < 2^-36.99, thus
                   ulp(l) <= ulp(2^-36.99) = 2^-89. */

  /* We have the following errors:
   * error on P() bounded by 2^-84.39
   * error on ti[1] + ti[2] + log2(ti[0]) bounded by 2^-97.91
   * error on tj[1] + tj[2] + log2(tj[0]) bounded by 2^-94.31
   * error on l = ti[2] + tj[2] bounded by 2^-90
   * induced error in P() since xl might be wrong by up to 2^-88.99:
     this is bounded by the derivative of the minimax polynomial times
     2^-88.99, which is < 1.45 * 2^-88.99 < 2^-88.45
   * rounding error on *l += t + pl bounded by 2^-90 + 2^-89
   The total error is thus bounded by:
   2^-84.39 + 2^-97.91 + 2^-94.31 + 2^-90 + 2^-88.45 + 2^-90 + 2^-89 < 2^-84.19
   */
}

/* For -37 <= i <= 26, T1acc[i+37] contains {r, h, l} such that
   with xmin := 1+i/128 <= x < xmax := 1+(i+1)/128 for -37 <= i <= -1,
        xmin := 1+i/64 <= x < xmax := 1+(i+1)/64 for 0 <= i <= 26,
   r is a floating-point number multiple of 2^-17 minimizing max(abs(r*x-1))
   for xmin <= x < xmax: h approximates -log2(r) to nearest,
   and l approximates -log2(r)-h to nearest.
   Ensures 0.992248 <= r*x <= 1.007753.
   Table generated by T1acc() from log2l.sage. */
static const long double T1acc[64][3] = {
   {0x1.661fp+0, -0x1.efed4e4a1ad2fe8p-2l, 0x1.8b5aaca1731f9166p-67l}, /* i=-37 */
   {0x1.623f8p+0, -0x1.dfdce55de10a317p-2l, -0x1.21a6c9c4eea0448p-68l}, /* i=-36 */
   {0x1.5e758p+0, -0x1.cff9eb0a2f52996ep-2l, -0x1.49cbd69e36614abcp-67l}, /* i=-35 */
   {0x1.5ac08p+0, -0x1.c04435a065c281fep-2l, 0x1.50fc719b34c43f2p-70l}, /* i=-34 */
   {0x1.571fp+0, -0x1.b0b73dbec73d76c2p-2l, 0x1.fa955fb568ac8ca6p-67l}, /* i=-33 */
   {0x1.53908p+0, -0x1.a15297d020bdfdbcp-2l, 0x1.37638312f6fc826ep-67l}, /* i=-32 */
   {0x1.5015p+0, -0x1.9217faccfbf78a6ep-2l, 0x1.38d7d259a627ca8ap-67l}, /* i=-31 */
   {0x1.4cab8p+0, -0x1.8304b3897d7ee38cp-2l, 0x1.41b7f1e4b6328a4ap-68l}, /* i=-30 */
   {0x1.49538p+0, -0x1.7418254eb56d167ap-2l, 0x1.31afabb7a2d91754p-67l}, /* i=-29 */
   {0x1.460c8p+0, -0x1.6551a27cbce7e58ap-2l, 0x1.ffce575ec68ad53ep-69l}, /* i=-28 */
   {0x1.42d68p+0, -0x1.56b2b60854c734e4p-2l, -0x1.feea646c441ca71ep-68l}, /* i=-27 */
   {0x1.3fbp+0, -0x1.483602143d02138cp-2l, 0x1.997361b38cc7cf42p-67l}, /* i=-26 */
   {0x1.3c998p+0, -0x1.39df3e178fde4238p-2l, -0x1.96ac7864d579d39ep-67l}, /* i=-25 */
   {0x1.3992p+0, -0x1.2bab2cbe9e61e8e8p-2l, -0x1.d9f19e656172536ep-68l}, /* i=-24 */
   {0x1.3699p+0, -0x1.1d98c86cec23f69cp-2l, 0x1.33d6a3d81d50cf7p-67l}, /* i=-23 */
   {0x1.33ae8p+0, -0x1.0fa95fe6325c9accp-2l, -0x1.1ed2ef795461c268p-71l}, /* i=-22 */
   {0x1.30d18p+0, -0x1.01d96de7d319f62cp-2l, 0x1.d1920b9342f1076ap-67l}, /* i=-21 */
   {0x1.2e028p+0, -0x1.e85933d7cd05106ap-3l, -0x1.b7e09ad5611c845ep-69l}, /* i=-20 */
   {0x1.2b408p+0, -0x1.cd3e7e511aa3416ap-3l, -0x1.cf80ed1fc46bbc3p-72l}, /* i=-19 */
   {0x1.288bp+0, -0x1.b260190d317bfdbap-3l, -0x1.14c715ac42ec6ef8p-68l}, /* i=-18 */
   {0x1.25e2p+0, -0x1.97c042a9f0251ccp-3l, 0x1.c8f966bb99931312p-71l}, /* i=-17 */
   {0x1.23458p+0, -0x1.7d614191b0c8cfbep-3l, -0x1.3e31358e084190c8p-68l}, /* i=-16 */
   {0x1.20b48p+0, -0x1.633b27c3d59d3cfep-3l, -0x1.7108460e6ac86bep-68l}, /* i=-15 */
   {0x1.1e2fp+0, -0x1.4950053093e5776p-3l, 0x1.93425fd513712308p-68l}, /* i=-14 */
   {0x1.1bb48p+0, -0x1.2f9cbbbbdfe1a198p-3l, -0x1.050cec0a960c4294p-68l}, /* i=-13 */
   {0x1.1945p+0, -0x1.1623467996715254p-3l, 0x1.4e53246798149884p-68l}, /* i=-12 */
   {0x1.16e08p+0, -0x1.f9cb4e0b3b3e612ap-4l, 0x1.fe876f88fb83e03ap-69l}, /* i=-11 */
   {0x1.1486p+0, -0x1.c7b66be0edce8bcap-4l, 0x1.5325a7a02032048ep-69l}, /* i=-10 */
   {0x1.12358p+0, -0x1.960b77fb6f6f6022p-4l, -0x1.29ebb5a31053ae1ep-73l}, /* i=-9 */
   {0x1.0fefp+0, -0x1.64ce0fab1fa4b51ep-4l, 0x1.a86bac474d1c6026p-69l}, /* i=-8 */
   {0x1.0db2p+0, -0x1.33f6e70c7e7fc2fp-4l, -0x1.f5fcb4b7222bce9cp-71l}, /* i=-7 */
   {0x1.0b7e8p+0, -0x1.03896c9bb628f7eap-4l, -0x1.4b1efd57ba5b3302p-72l}, /* i=-6 */
   {0x1.0954p+0, -0x1.a6fbed7681b1c66ep-5l, 0x1.20ca36d5f89cdd12p-71l}, /* i=-5 */
   {0x1.07328p+0, -0x1.47af8747263f44e6p-5l, 0x1.4f3c7872704bd244p-70l}, /* i=-4 */
   {0x1.05198p+0, -0x1.d23b2a73a25e562p-6l, 0x1.af4c66c39b8d9966p-71l}, /* i=-3 */
   {0x1.0309p+0, -0x1.16986125fe7ebb9cp-6l, -0x1.9ac8a5a662de859p-71l}, /* i=-2 */
   {0x1.0101p+0, -0x1.720c2ab2312a8804p-8l, 0x1.28c04a9f3205edd8p-73l}, /* i=-1 */
   {0x1.fc08p-1, 0x1.6fdf461d2e4f7e24p-7l, -0x1.260908a03f0ba5dp-72l}, /* i=0 */
   {0x1.f446p-1, 0x1.11d568f79a68cae6p-5l, 0x1.75225264a58298e8p-70l}, /* i=1 */
   {0x1.eccp-1, 0x1.c4eb3635cea064bp-5l, -0x1.1a94fb36bd6de49ap-70l}, /* i=2 */
   {0x1.e574p-1, 0x1.3a9f062a91011ef2p-4l, 0x1.c2ab488fd1727ccap-69l}, /* i=3 */
   {0x1.de5dp-1, 0x1.918f68cc7476f61cp-4l, -0x1.869aa6637f35a1c2p-73l}, /* i=4 */
   {0x1.d77bp-1, 0x1.e733b6aad978c6cap-4l, 0x1.221f6818566eda4p-70l}, /* i=5 */
   {0x1.d0cbp-1, 0x1.1dcf4efede060b82p-3l, 0x1.30e6021aafebc0aep-68l}, /* i=6 */
   {0x1.ca4bp-1, 0x1.476bd73793b985b8p-3l, -0x1.e2c133e6c62ed2a8p-69l}, /* i=7 */
   {0x1.c3f9p-1, 0x1.7073c56f30b41daap-3l, -0x1.5303d358b396b7c8p-68l}, /* i=8 */
   {0x1.bdd3p-1, 0x1.98ebf743d5589e9ap-3l, 0x1.a4f0c747ad21e376p-69l}, /* i=9 */
   {0x1.b7d7p-1, 0x1.c0d9d8e94f119cbep-3l, 0x1.dd62907a49efc3cap-70l}, /* i=10 */
   {0x1.b203p-1, 0x1.e8436768ef457218p-3l, -0x1.f0dec6505dc360c8p-68l}, /* i=11 */
   {0x1.ac57p-1, 0x1.0790b38054dcc47ap-2l, -0x1.020d39bc13578d6ap-69l}, /* i=12 */
   {0x1.a6dp-1, 0x1.1ac0b77e3f7e5c4p-2l, 0x1.608fd4722a1fa5f2p-69l}, /* i=13 */
   {0x1.a16dp-1, 0x1.2db1f0d462ea0e92p-2l, 0x1.0e78ddd30ff07b96p-69l}, /* i=14 */
   {0x1.9c2dp-1, 0x1.4064aeb6da35065ap-2l, -0x1.6e94b8a8a1cc7e46p-68l}, /* i=15 */
   {0x1.970ep-1, 0x1.52dd004ee2095514p-2l, 0x1.3f0e448d7dc1d0d8p-67l}, /* i=16 */
   {0x1.921p-1, 0x1.6517e94738f45142p-2l, -0x1.dc5983bc619a4506p-67l}, /* i=17 */
   {0x1.8d3p-1, 0x1.771d87fd102b155ep-2l, 0x1.8e9b76df16a6d6cp-68l}, /* i=18 */
   {0x1.886ep-1, 0x1.88eb2cf80915f43ap-2l, -0x1.d7891637bdcb8b3cp-73l}, /* i=19 */
   {0x1.83c9p-1, 0x1.9a81eb766a98d55p-2l, 0x1.7083ab14a33271ccp-67l}, /* i=20 */
   {0x1.7f4p-1, 0x1.abe2f8ec9671dcc6p-2l, 0x1.0e2cc831e3bfbc8ap-68l}, /* i=21 */
   {0x1.7ad2p-1, 0x1.bd0fad93872401b4p-2l, 0x1.1c4821a230af6a36p-69l}, /* i=22 */
   {0x1.767ep-1, 0x1.ce0984eed3b35c62p-2l, -0x1.6387394aee1c85b6p-68l}, /* i=23 */
   {0x1.7243p-1, 0x1.ded21e4ae796e10ep-2l, -0x1.40e0da933fca300ap-67l}, /* i=24 */
   {0x1.6e1fp-1, 0x1.ef6f462c653ad34p-2l, 0x1.3488faf6136b1a26p-67l}, /* i=25 */
   {0x1.6a14p-1, 0x1.ffd6c9e8cc0699d2p-2l, -0x1.68bccb317c932dcep-67l}, /* i=26 */
};

/* For -32 <= j < 32, T2acc[j+32] contains {r, h, l} such that
   with xmin := 1+j/2^12 <= x < xmax := 1+(j+1)/2^12,
   r is a floating-point number multiple of 2^-21 minimizing max(abs(r*x-1))
   for xmin <= x < xmax: h approximates -log2(r) to nearest,
   and l approximates -log2(r)-h to nearest.
   Ensures 0.999876941205002367 <= r*x <= 1.00012315926142037.
   Table generated by T2acc() from log2l.sage. */
static const long double T2acc[64][3] = {
   {0x1.01fbe8p+0, -0x1.6cf6e8d2852327d2p-7l, 0x1.1c758181df5d0308p-73l}, /* j=-32 */
   {0x1.01eba8p+0, -0x1.6154d09bfc348a58p-7l, 0x1.ef1b505f161b45aep-75l}, /* j=-31 */
   {0x1.01db7p+0, -0x1.55b7b76be82c113p-7l, -0x1.7de9cd7c56bc42d4p-73l}, /* j=-30 */
   {0x1.01cb3p+0, -0x1.4a14282af9fcb99ep-7l, 0x1.1e94c4db9913f2f2p-72l}, /* j=-29 */
   {0x1.01baf8p+0, -0x1.3e759879fe3dd00ap-7l, -0x1.b405b1b9c301290ep-73l}, /* j=-28 */
   {0x1.01aacp+0, -0x1.32d64d9359bad47cp-7l, -0x1.bdc25741032bc3dap-72l}, /* j=-27 */
   {0x1.019a9p+0, -0x1.273c037ee6795d82p-7l, -0x1.c9437643681d4cep-74l}, /* j=-26 */
   {0x1.018a58p+0, -0x1.1b9b4242aa7b13e2p-7l, 0x1.7f2600e05bca32b2p-74l}, /* j=-25 */
   {0x1.017a28p+0, -0x1.0fff8262414f4da8p-7l, -0x1.d188e99ba530f3fcp-72l}, /* j=-24 */
   {0x1.016ap+0, -0x1.0468c4db26807226p-7l, -0x1.38e53f4652ccce3p-73l}, /* j=-23 */
   {0x1.0159dp+0, -0x1.f1971f12f55d2846p-8l, 0x1.cac89535f8773e82p-73l}, /* j=-22 */
   {0x1.0149a8p+0, -0x1.da66ba35a87f7becp-8l, 0x1.290e25ccaf1b040ap-73l}, /* j=-21 */
   {0x1.01398p+0, -0x1.c334e086d014849ap-8l, -0x1.0c9f7ba1e4409b92p-73l}, /* j=-20 */
   {0x1.012958p+0, -0x1.ac0191d7954afb22p-8l, 0x1.3a15b7c492009d42p-73l}, /* j=-19 */
   {0x1.01193p+0, -0x1.94cccdf9187d5654p-8l, 0x1.2eb3d023435aa4cap-73l}, /* j=-18 */
   {0x1.01091p+0, -0x1.7da213796838c078p-8l, -0x1.c0d007c4abef4592p-73l}, /* j=-17 */
   {0x1.00f8fp+0, -0x1.6675e4de47f5e1ecp-8l, 0x1.02ed948fd4734bbap-73l}, /* j=-16 */
   {0x1.00e8dp+0, -0x1.4f4841f90331eba6p-8l, -0x1.f75b001bf9777b12p-73l}, /* j=-15 */
   {0x1.00d8b8p+0, -0x1.3824ab81b5ca9ef2p-8l, 0x1.2076292a4630f2d6p-73l}, /* j=-14 */
   {0x1.00c8ap+0, -0x1.20ffa1d43ffe1e32p-8l, -0x1.ca3f3ad3da348b28p-75l}, /* j=-13 */
   {0x1.00b888p+0, -0x1.09d924c2186f16dcp-8l, 0x1.a2bff7d68d0e8e1ep-77l}, /* j=-12 */
   {0x1.00a87p+0, -0x1.e562683959fece1p-9l, -0x1.f6a7ac0c77b35d8cp-74l}, /* j=-11 */
   {0x1.009858p+0, -0x1.b70f9f6ac59bd6bap-9l, -0x1.206b50f142a0f564p-77l}, /* j=-10 */
   {0x1.008848p+0, -0x1.88d0f7bfa8ccd5aap-9l, 0x1.a5e321fae4ad2c9ap-74l}, /* j=-9 */
   {0x1.007838p+0, -0x1.5a8f6ab98d2b3a4p-9l, 0x1.948d37524a42c1b4p-81l}, /* j=-8 */
   {0x1.006828p+0, -0x1.2c4af7fb935ed36cp-9l, -0x1.f93d98ce98be769ep-76l}, /* j=-7 */
   {0x1.00582p+0, -0x1.fc35590227eeae78p-10l, 0x1.4abb46772417185p-76l}, /* j=-6 */
   {0x1.004818p+0, -0x1.9fcefaef8f2854b8p-10l, -0x1.58fea6877bb3027ep-75l}, /* j=-5 */
   {0x1.00381p+0, -0x1.4362d5064a983ca8p-10l, 0x1.740cbdf0dff19326p-75l}, /* j=-4 */
   {0x1.002808p+0, -0x1.cde1cd1a4b5bbaep-11l, 0x1.6ec1a519229e0ccap-76l}, /* j=-3 */
   {0x1.0018p+0, -0x1.14f25d9592239f24p-11l, -0x1.b9b915f965581336p-79l}, /* j=-2 */
   {0x1.0008p+0, -0x1.714eb11fa5363754p-13l, -0x1.1c42d64126264502p-78l}, /* j=-1 */
   {0x1.fffp-1, 0x1.715a3bc3593d4d4ap-13l, 0x1.511cba2fb213a106p-80l}, /* j=0 */
   {0x1.ffdp-1, 0x1.150c5586012b810ap-11l, -0x1.64302f39d155d35ap-78l}, /* j=1 */
   {0x1.ffb01p-1, 0x1.cd71455d80147298p-11l, -0x1.69dd0786fd29de4ep-77l}, /* j=2 */
   {0x1.ff902p-1, 0x1.42f0dbf4673b47bep-10l, 0x1.b1348ff9948408d2p-75l}, /* j=3 */
   {0x1.ff703p-1, 0x1.9f2ed74bf3415924p-10l, 0x1.ccb54f7e6cb3eac4p-77l}, /* j=4 */
   {0x1.ff504p-1, 0x1.fb72956d83add1bp-10l, -0x1.a8b478224a6574fap-77l}, /* j=5 */
   {0x1.ff305p-1, 0x1.2bde0b88ad49d4d6p-9l, -0x1.5c83322efaef7634p-75l}, /* j=6 */
   {0x1.ff107p-1, 0x1.59ee8e5e2f9057d2p-9l, -0x1.959d64bbece853aap-75l}, /* j=7 */
   {0x1.fef09p-1, 0x1.8801f0c9eab263f6p-9l, 0x1.0b13f6f4e4c1428p-75l}, /* j=8 */
   {0x1.fed0bp-1, 0x1.b6183327a909878ep-9l, -0x1.cbcb610469efa094p-75l}, /* j=9 */
   {0x1.feb0ep-1, 0x1.e41a3165bc6f1a4cp-9l, 0x1.2a78e469cd7c9022p-77l}, /* j=10 */
   {0x1.fe91p-1, 0x1.091b19a4a3a49a5cp-8l, 0x1.491fb4d776762876p-74l}, /* j=11 */
   {0x1.fe713p-1, 0x1.201ef770d9efd5a6p-8l, -0x1.27e5583491d2bb1cp-73l}, /* j=12 */
   {0x1.fe517p-1, 0x1.3718b01b48719952p-8l, 0x1.e0e1c21b3ee0654p-75l}, /* j=13 */
   {0x1.fe31ap-1, 0x1.4e1f6bda62d1d55ep-8l, -0x1.645ea7ead4fe6b3ap-74l}, /* j=14 */
   {0x1.fe11ep-1, 0x1.651c0161d4a6834cp-8l, -0x1.698ef384dc0001ccp-73l}, /* j=15 */
   {0x1.fdf22p-1, 0x1.7c1a053ff4d56186p-8l, 0x1.a0469db972ccd286p-74l}, /* j=16 */
   {0x1.fdd26p-1, 0x1.931977a262e4c648p-8l, 0x1.42cec690eda70008p-73l}, /* j=17 */
   {0x1.fdb2bp-1, 0x1.aa0ec0babebcf09ap-8l, -0x1.e6a402f398dd737cp-76l}, /* j=18 */
   {0x1.fd92fp-1, 0x1.c1110ff5dc26b1c6p-8l, -0x1.5639a2e1b6ecad66p-73l}, /* j=19 */
   {0x1.fd734p-1, 0x1.d80934d0a60c70f2p-8l, 0x1.7ad103e552c52d7cp-76l}, /* j=20 */
   {0x1.fd539p-1, 0x1.ef02c774a12eaa96p-8l, -0x1.cc0eb58824905edp-73l}, /* j=21 */
   {0x1.fd33fp-1, 0x1.02f91698409afd1cp-7l, -0x1.fe6e958a26777772p-73l}, /* j=22 */
   {0x1.fd145p-1, 0x1.0e717fcf957a7cd8p-7l, 0x1.a5f42ecf9d1473bp-72l}, /* j=23 */
   {0x1.fcf4bp-1, 0x1.19ea9f76f7cad3ecp-7l, -0x1.81d7392820b28116p-72l}, /* j=24 */
   {0x1.fcd51p-1, 0x1.256475a5145a6e46p-7l, 0x1.2bb66100bba8fdp-72l}, /* j=25 */
   {0x1.fcb57p-1, 0x1.30df02709c32314cp-7l, -0x1.1785a36401299cd6p-79l}, /* j=26 */
   {0x1.fc95ep-1, 0x1.3c5476b333dd56bp-7l, -0x1.0bfea4cf391e495cp-73l}, /* j=27 */
   {0x1.fc765p-1, 0x1.47caa107d32f92ccp-7l, 0x1.871aa723c476ef9cp-74l}, /* j=28 */
   {0x1.fc56cp-1, 0x1.5341818515719d68p-7l, -0x1.0e530949d345971ep-74l}, /* j=29 */
   {0x1.fc373p-1, 0x1.5eb918419a224cd2p-7l, 0x1.35d2848ebdadd51cp-75l}, /* j=30 */
   {0x1.fc17bp-1, 0x1.6a2b94a597203d4ep-7l, 0x1.5033fbcb6cdc1ba8p-73l}, /* j=31 */
};

/* s + t <- a + b, assuming |a| >= |b| */
static inline void
fast_two_sum (long double *s, long double *t, long double a, long double b)
{
  *s = a + b;
  long double e = *s - a;
  *t = b - e;
}

// Veltkamp's splitting: split x into xh + xl such that
// x = xh + xl exactly
// xh fits in 32 bits and |xh| <= 2^e if 2^(e-1) <= |x| < 2^e
// xl fits in 32 bits and |xl| < 2^(e-32)
// See reference [1].
static inline void
split (long double *xh, long double *xl, long double x)
{
  static const long double C = 0x1.00000001p+32L;
  long double gamma = C * x;
  long double delta = x - gamma;
  *xh = gamma + delta;
  *xl = x - *xh;
}

/* Dekker's algorithm: rh + rl = u * v
   Reference: Algorithm Mul12 from reference [2], pages 21-22.
   See also reference [3], Veltkamp splitting (Algorithm 4.9) and
   Dekker's product (Algorithm 4.10).
   The Handbook only mentions rounding to nearest, but Veltkamp's and
   Dekker's algorithms also work for directed roundings.
   See reference [1].
*/
static inline void
a_mul (long double *rh, long double *rl, long double u, long double v)
{
  long double u1, u2, v1, v2;
  split (&u1, &u2, u);
  split (&v1, &v2, v);
  *rh = u * v;
  *rl = (((u1 * v1 - *rh) + u1 * v2) + u2 * v1) + u2 * v2;
}

// Return in hi+lo a 128-bit approximation of (ah + al) * b
static inline void
s_mul (long double *hi, long double *lo, long double ah, long double al,
       long double b) {
  a_mul (hi, lo, ah, b); // exact
  *lo += al * b;
}

// Return in hi+lo a 128-bit approximation of (ah + al) * (bh + bl)
static inline void
d_mul (long double *hi, long double *lo, long double ah, long double al,
       long double bh, long double bl) {
  a_mul (hi, lo, ah, bh); // exact
  *lo += ah * bl;
  *lo += al * bh;
}

/* given 0.999876941205002367 <= xh+xl <= 1.00012315926142037,
   put in ph+pl an approximation of log2(xh+xl) with about 128
   bits of accuracy */
static void
Pacc (long double *ph, long double *pl, long double xh, long double xl)
{
  /* the following is a degree-9 minimax polynomial generated by Sollya
     for log2(1+x) for -0.00012305879499763337 <= x <= 0.00012315926142036915,
     with relative error bounded by 2^-128.092 */
  static const long double p[] = {
    0x1.71547652b82fe178p+0L, -0x1.05e004be5b8b05dcp-65L, // degree 1
    -0x1.71547652b82fe178p-1L, 0x1.05e004be5b90945cp-66L, // degree 2
    0x1.ec709dc3a03fd74ap-2L, -0x1.f556ea2e7fe9068p-73L,  // degree 3
    -0x1.71547652b82fe178p-2L, 0x1.05ddbdee9c6e31c2p-67L, // degree 4
    0x1.2776c50ef9bfe792p-2L, 0x1.983b2c958cb58afcp-67L,  // degree 5
    -0x1.ec709dc3a03fb70ep-3L,                            // degree 6
    0x1.a61762a7addd256cp-3L,                             // degree 7
    -0x1.715476fbc0fafbb2p-3L,                            // degree 8
    0x1.484b2f0666016af8p-3L,                             // degree 9
  };
  xh -= 1.0L;
  fast_two_sum (&xh, &xl, xh, xl);
  /* Now |xh| <= 0.000123160 and |xl| < 2^-63 |xh|.
     The relative contribution of the degree i term (with coefficient a[i])
     is a[i]/a[1]*(xh+xl)^(i-1), and the xl contribution in this term is
     bounded by (i-1)*a[i]/a[1]*xh^(i-2)*xl < (i-1)*a[i]/a[1]*xh^(i-1)*2^-63.
     For degree >= 6 this is less than 2^-128, thus we can ignore xl. */
  *ph = p[13] * xh + p[12]; // degree 8 and 9
  *ph = *ph *	xh + p[11]; // degree 7
  *ph = *ph *	xh + p[10]; // degree 6
  *ph = *ph *   xh;
  // add a[5]
  fast_two_sum (ph, pl, p[8], *ph);
  *pl += p[9];
  // multiply by xh+xl
  d_mul (ph, pl, *ph, *pl, xh, xl);
  long double tl;
  // add a[4]
  fast_two_sum (ph, &tl, p[6], *ph);
  *pl += tl + p[7];
  // multiply by xh+xl
  d_mul (ph, pl, *ph, *pl, xh, xl);
  // add a[3]
  fast_two_sum (ph, &tl, p[4], *ph);
  *pl += tl + p[5];
  // multiply by xh+xl
  d_mul (ph, pl, *ph, *pl, xh, xl);
  // add a[2]
  fast_two_sum (ph, &tl, p[2], *ph);
  *pl += tl + p[3];
  // multiply by xh+xl
  d_mul (ph, pl, *ph, *pl, xh, xl);
  // add a[1]
  fast_two_sum (ph, &tl, p[0], *ph);
  *pl += tl + p[1];
  // multiply by xh+xl
  d_mul (ph, pl, *ph, *pl, xh, xl);
}

// return log2(x0) correctly rounded for 1 <= x < 2, where x0 = 2^e*x
static long double __attribute__((noinline))
accurate_path (long double x0)
{
#define EXCEPTIONS 6
static const long double exceptions[EXCEPTIONS][3] = {
  {0x1.5e5a8e406ecbb63ap-1L, -0x1.183bd6ff6d533df2p-1L, 0x1.fffffffffffffffep-66L},
  {0xb.392b2c29379a63dp-6L, -0x1.417b39b22f4c25a2p+1L, -0x1.fffffffffffffffep-64L},
  {0xb.392b2c29379a63dp-7L, -0x1.c17b39b22f4c25a2p+1L, -0x1.fffffffffffffffep-64L},
  {0xb.392b2c29379a63dp+0L, 0x1.be84c64dd0b3da5ep+1L, -0x1.fffffffffffffffep-64L},
  {0xb.392b2c29379a63dp-1L, 0x1.3e84c64dd0b3da5ep+1L, -0x1.fffffffffffffffep-64L},
  {0xa.f2d47203765db1dp-3L, 0x1.cf8852012559841ep-2L, -0x1.c2329a79bc19a76cp-131L},
  };
  for (int i = 0; i < EXCEPTIONS; i++)
    if (x0 == exceptions[i][0])
        return exceptions[i][1] + exceptions[i][2];

  b96u96_u t = {.f = x0};
  int ex = t.e, e = ex - 0x3fff;
  if (__builtin_expect (!ex, 0)) // positive subnormal
  {
    int k = __builtin_clzll (t.m);
    e -= k - 1;
    t.m <<= k;
  }
  t.e = 0x3fff; // normalize t.f in [1,2)
  long double x = t.f;

  static const uint64_t Ex[] =
    {0xe27db35c267b8a5c, 0xe27db35c267b8a5c, 0xf67cd32484077681, 0xf67cd32484077681};
  static const int eEx[] = {-257, 511, -257, 511};
  static const long double rEx[] =
    {-0x1.002d3b8dd1c2c526p+8L, 0x1.ffd2c4722e3d3adap+8L,
     -0x1.000dfc267901af96p+8L, 0x1.fff203d986fe506ap+8L};
  /* "generic" worst cases */
  for (int i = 0; i < 4; i++){
    if (t.m == Ex[i] && (eEx[i] - 255 <= e && e <= eEx[i]))
      return (rEx[i] + (e - eEx[i])) + 0x1p-57L;
  }
  
  int i = (t.m >> 57) - 0x40;
  // 0 <= i < 2^6, with 1+i/64 <= x < 1+(i+1)/64
  if (i > 26)
  {
    x = x * 0.5l;
    e ++;
    i -= 64;
  }

  // now -37 <= i <= 26 and 0.7109375 <= x < 1.421875
  long double xh, xl;
  const long double *ti = T1acc[i + 37];
  a_mul (&xh, &xl, x, ti[0]);
  // 0.992248 < xh + xl < 1.007753
  t.f = xh;

  int j;
  if (xh >= 1)
    j = (t.m >> 51) - 0x1000; // 0 <= j <= 31, 1 <= x < 1+(j+1)/2^12
  else
    j = (t.m >> 52) - 0x1000; // -32 <= j < 0, 1+j/2^12 <= x < 1+(j+1)/2^12
  const long double *tj = T2acc[j + 32];
  s_mul (&xh, &xl, xh, xl, tj[0]);
  // 0.999876941205002367 <= xh+xl <= 1.00012315926142037

  // now we approximate log2(xh+xl) with a minimax polynomial
  long double ph, pl;
  Pacc (&ph, &pl, xh, xl);

  long double tl;
  // add -log2(rj)
  fast_two_sum (&ph, &tl, tj[1], ph);
  pl += tl + tj[2];

  // add -log2(ri)
  fast_two_sum (&ph, &tl, ti[1], ph);
  pl += tl + ti[2];

  // add e
  fast_two_sum (&ph, &tl, (long double) e, ph);
  pl += tl;

  return ph + pl;
}

long double
cr_log2l (long double x)
{
  b96u96_u t = {.f = x};
  int ex = t.e, e = ex - 0x3fff;
  if (__builtin_expect ((ex&0x7fff)==0, 0)) // x=+-0 or positive subnormal
  {
    if (!t.m) {
#ifdef CORE_MATH_SUPPORT_ERRNO
      errno = ERANGE; // pole error
#endif
      return (long double) -1.0 / 0.0; // x=+-0
    }
    int k = __builtin_clzll (t.m);
    e -= k - 1;
    t.m <<= k;
  }
  if (__builtin_expect (ex >= 0x7fff, 0)) // x<=0 or Inf or NaN
  {
    if (t.m == ((uint64_t)1 << 63) && (ex == 0x7fff)) return x; // x=+Inf
    return 0.0L / 0.0L; // x < 0 or qNaN or sNaN
  }

  // now x is normal and x > 0, x = t.m/2^63 * 2^e
  if (__builtin_expect (!(t.m<<1), 0)) return log2_exact (e);

  double h, l;
  fast_path (&h, &l, t.m, e);
  long double H = h, L = l;
  const long double err = 0x1.c1p-85l;
  long double left = H + (L - err), right = H + (L + err);
  if (__builtin_expect (left == right, 1))
    return left;

  return accurate_path (x);
}
