/* Correctly-rounded power function for bfloat16 value.

Copyright (c) 2025 Paul Zimmermann

This file is part of the CORE-MATH project
(https://core-math.gitlabpages.inria.fr/).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include <stdint.h>
#include <errno.h>
#include <fenv.h> // for fexcept_t, fegetexceptflag, FE_INEXACT
#include <math.h> // only used during performance tests
#include <stdio.h>

// Warning: clang also defines __GNUC__
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
#endif

#pragma STDC FENV_ACCESS ON

typedef union {__bf16 f; uint16_t u;} b16u16_u;
typedef union {double f; uint64_t u;} b64u64_u;
static const b16u16_u poszero = {.u = 0x0000};
static const b16u16_u negzero = {.u = 0x8000};
static const b16u16_u one = {.u = 0x3f80};
static const b16u16_u neginf = {.u = 0xff80};
static const b16u16_u posinf = {.u = 0x7f80};

// don't use the MXCSR register since it is not affected by __bf16 operations
static fexcept_t get_flag (void) {
  fexcept_t flag;
  fegetexceptflag (&flag, FE_INEXACT);
  return flag;
}

static void set_flag (fexcept_t flag) {
  fesetexceptflag (&flag, FE_INEXACT);
}

static inline int isint(b16u16_u v) {
  if (v.f == 0.0f) return 1;
  return (v.u & 0x7fff) >> 7 >= 134 - __builtin_ctz(0x80 | v.u);
}

static inline int isodd(b16u16_u v) {
  if (v.f == 0.0f) return 0;
  return (v.u & 0x7fff) >> 7 == 134 - __builtin_ctz(0x80 | v.u);
}

/* For 0 <= i1 < 2^8, T1[i1] approximates log(x1), where the 16-bit
   encoding of x1 is i1*2^7 (i1 encodes the exponent of x1).
   Table generated by table1() in pow.sage. */
static const double T1[] = {
 0, -0x1.5d589f2fe5107p+6, -0x1.5a92d6d005c94p+6, -0x1.57cd0e702682p+6,
 -0x1.55074610473acp+6, -0x1.52417db067f38p+6, -0x1.4f7bb55088ac4p+6,
 -0x1.4cb5ecf0a965p+6, -0x1.49f02490ca1dcp+6, -0x1.472a5c30ead69p+6,
 -0x1.446493d10b8f5p+6, -0x1.419ecb712c481p+6, -0x1.3ed903114d00dp+6,
 -0x1.3c133ab16db99p+6, -0x1.394d72518e725p+6, -0x1.3687a9f1af2b1p+6,
 -0x1.33c1e191cfe3dp+6, -0x1.30fc1931f09cap+6, -0x1.2e3650d211556p+6,
 -0x1.2b708872320e2p+6, -0x1.28aac01252c6ep+6, -0x1.25e4f7b2737fap+6,
 -0x1.231f2f5294386p+6, -0x1.205966f2b4f12p+6, -0x1.1d939e92d5a9ep+6,
 -0x1.1acdd632f662bp+6, -0x1.18080dd3171b7p+6, -0x1.1542457337d43p+6,
 -0x1.127c7d13588cfp+6, -0x1.0fb6b4b37945bp+6, -0x1.0cf0ec5399fe7p+6,
 -0x1.0a2b23f3bab73p+6, -0x1.07655b93db7p+6, -0x1.049f9333fc28cp+6,
 -0x1.01d9cad41ce18p+6, -0x1.fe2804e87b348p+5, -0x1.f89c7428bca6p+5,
 -0x1.f310e368fe178p+5, -0x1.ed8552a93f891p+5, -0x1.e7f9c1e980fa9p+5,
 -0x1.e26e3129c26c1p+5, -0x1.dce2a06a03dd9p+5, -0x1.d7570faa454f2p+5,
 -0x1.d1cb7eea86c0ap+5, -0x1.cc3fee2ac8322p+5, -0x1.c6b45d6b09a3ap+5,
 -0x1.c128ccab4b153p+5, -0x1.bb9d3beb8c86bp+5, -0x1.b611ab2bcdf83p+5,
 -0x1.b0861a6c0f69cp+5, -0x1.aafa89ac50db4p+5, -0x1.a56ef8ec924ccp+5,
 -0x1.9fe3682cd3be4p+5, -0x1.9a57d76d152fdp+5, -0x1.94cc46ad56a15p+5,
 -0x1.8f40b5ed9812dp+5, -0x1.89b5252dd9845p+5, -0x1.8429946e1af5ep+5,
 -0x1.7e9e03ae5c676p+5, -0x1.791272ee9dd8ep+5, -0x1.7386e22edf4a6p+5,
 -0x1.6dfb516f20bbfp+5, -0x1.686fc0af622d7p+5, -0x1.62e42fefa39efp+5,
 -0x1.5d589f2fe5107p+5, -0x1.57cd0e702682p+5, -0x1.52417db067f38p+5,
 -0x1.4cb5ecf0a965p+5, -0x1.472a5c30ead69p+5, -0x1.419ecb712c481p+5,
 -0x1.3c133ab16db99p+5, -0x1.3687a9f1af2b1p+5, -0x1.30fc1931f09cap+5,
 -0x1.2b708872320e2p+5, -0x1.25e4f7b2737fap+5, -0x1.205966f2b4f12p+5,
 -0x1.1acdd632f662bp+5, -0x1.1542457337d43p+5, -0x1.0fb6b4b37945bp+5,
 -0x1.0a2b23f3bab73p+5, -0x1.049f9333fc28cp+5, -0x1.fe2804e87b348p+4,
 -0x1.f310e368fe178p+4, -0x1.e7f9c1e980fa9p+4, -0x1.dce2a06a03dd9p+4,
 -0x1.d1cb7eea86c0ap+4, -0x1.c6b45d6b09a3ap+4, -0x1.bb9d3beb8c86bp+4,
 -0x1.b0861a6c0f69cp+4, -0x1.a56ef8ec924ccp+4, -0x1.9a57d76d152fdp+4,
 -0x1.8f40b5ed9812dp+4, -0x1.8429946e1af5ep+4, -0x1.791272ee9dd8ep+4,
 -0x1.6dfb516f20bbfp+4, -0x1.62e42fefa39efp+4, -0x1.57cd0e702682p+4,
 -0x1.4cb5ecf0a965p+4, -0x1.419ecb712c481p+4, -0x1.3687a9f1af2b1p+4,
 -0x1.2b708872320e2p+4, -0x1.205966f2b4f12p+4, -0x1.1542457337d43p+4,
 -0x1.0a2b23f3bab73p+4, -0x1.fe2804e87b348p+3, -0x1.e7f9c1e980fa9p+3,
 -0x1.d1cb7eea86c0ap+3, -0x1.bb9d3beb8c86bp+3, -0x1.a56ef8ec924ccp+3,
 -0x1.8f40b5ed9812dp+3, -0x1.791272ee9dd8ep+3, -0x1.62e42fefa39efp+3,
 -0x1.4cb5ecf0a965p+3, -0x1.3687a9f1af2b1p+3, -0x1.205966f2b4f12p+3,
 -0x1.0a2b23f3bab73p+3, -0x1.e7f9c1e980fa9p+2, -0x1.bb9d3beb8c86bp+2,
 -0x1.8f40b5ed9812dp+2, -0x1.62e42fefa39efp+2, -0x1.3687a9f1af2b1p+2,
 -0x1.0a2b23f3bab73p+2, -0x1.bb9d3beb8c86bp+1, -0x1.62e42fefa39efp+1,
 -0x1.0a2b23f3bab73p+1, -0x1.62e42fefa39efp+0, -0x1.62e42fefa39efp-1, 0x0p+0,
 0x1.62e42fefa39efp-1, 0x1.62e42fefa39efp+0, 0x1.0a2b23f3bab73p+1,
 0x1.62e42fefa39efp+1, 0x1.bb9d3beb8c86bp+1, 0x1.0a2b23f3bab73p+2,
 0x1.3687a9f1af2b1p+2, 0x1.62e42fefa39efp+2, 0x1.8f40b5ed9812dp+2,
 0x1.bb9d3beb8c86bp+2, 0x1.e7f9c1e980fa9p+2, 0x1.0a2b23f3bab73p+3,
 0x1.205966f2b4f12p+3, 0x1.3687a9f1af2b1p+3, 0x1.4cb5ecf0a965p+3,
 0x1.62e42fefa39efp+3, 0x1.791272ee9dd8ep+3, 0x1.8f40b5ed9812dp+3,
 0x1.a56ef8ec924ccp+3, 0x1.bb9d3beb8c86bp+3, 0x1.d1cb7eea86c0ap+3,
 0x1.e7f9c1e980fa9p+3, 0x1.fe2804e87b348p+3, 0x1.0a2b23f3bab73p+4,
 0x1.1542457337d43p+4, 0x1.205966f2b4f12p+4, 0x1.2b708872320e2p+4,
 0x1.3687a9f1af2b1p+4, 0x1.419ecb712c481p+4, 0x1.4cb5ecf0a965p+4,
 0x1.57cd0e702682p+4, 0x1.62e42fefa39efp+4, 0x1.6dfb516f20bbfp+4,
 0x1.791272ee9dd8ep+4, 0x1.8429946e1af5ep+4, 0x1.8f40b5ed9812dp+4,
 0x1.9a57d76d152fdp+4, 0x1.a56ef8ec924ccp+4, 0x1.b0861a6c0f69cp+4,
 0x1.bb9d3beb8c86bp+4, 0x1.c6b45d6b09a3ap+4, 0x1.d1cb7eea86c0ap+4,
 0x1.dce2a06a03dd9p+4, 0x1.e7f9c1e980fa9p+4, 0x1.f310e368fe178p+4,
 0x1.fe2804e87b348p+4, 0x1.049f9333fc28cp+5, 0x1.0a2b23f3bab73p+5,
 0x1.0fb6b4b37945bp+5, 0x1.1542457337d43p+5, 0x1.1acdd632f662bp+5,
 0x1.205966f2b4f12p+5, 0x1.25e4f7b2737fap+5, 0x1.2b708872320e2p+5,
 0x1.30fc1931f09cap+5, 0x1.3687a9f1af2b1p+5, 0x1.3c133ab16db99p+5,
 0x1.419ecb712c481p+5, 0x1.472a5c30ead69p+5, 0x1.4cb5ecf0a965p+5,
 0x1.52417db067f38p+5, 0x1.57cd0e702682p+5, 0x1.5d589f2fe5107p+5,
 0x1.62e42fefa39efp+5, 0x1.686fc0af622d7p+5, 0x1.6dfb516f20bbfp+5,
 0x1.7386e22edf4a6p+5, 0x1.791272ee9dd8ep+5, 0x1.7e9e03ae5c676p+5,
 0x1.8429946e1af5ep+5, 0x1.89b5252dd9845p+5, 0x1.8f40b5ed9812dp+5,
 0x1.94cc46ad56a15p+5, 0x1.9a57d76d152fdp+5, 0x1.9fe3682cd3be4p+5,
 0x1.a56ef8ec924ccp+5, 0x1.aafa89ac50db4p+5, 0x1.b0861a6c0f69cp+5,
 0x1.b611ab2bcdf83p+5, 0x1.bb9d3beb8c86bp+5, 0x1.c128ccab4b153p+5,
 0x1.c6b45d6b09a3ap+5, 0x1.cc3fee2ac8322p+5, 0x1.d1cb7eea86c0ap+5,
 0x1.d7570faa454f2p+5, 0x1.dce2a06a03dd9p+5, 0x1.e26e3129c26c1p+5,
 0x1.e7f9c1e980fa9p+5, 0x1.ed8552a93f891p+5, 0x1.f310e368fe178p+5,
 0x1.f89c7428bca6p+5, 0x1.fe2804e87b348p+5, 0x1.01d9cad41ce18p+6,
 0x1.049f9333fc28cp+6, 0x1.07655b93db7p+6, 0x1.0a2b23f3bab73p+6,
 0x1.0cf0ec5399fe7p+6, 0x1.0fb6b4b37945bp+6, 0x1.127c7d13588cfp+6,
 0x1.1542457337d43p+6, 0x1.18080dd3171b7p+6, 0x1.1acdd632f662bp+6,
 0x1.1d939e92d5a9ep+6, 0x1.205966f2b4f12p+6, 0x1.231f2f5294386p+6,
 0x1.25e4f7b2737fap+6, 0x1.28aac01252c6ep+6, 0x1.2b708872320e2p+6,
 0x1.2e3650d211556p+6, 0x1.30fc1931f09cap+6, 0x1.33c1e191cfe3dp+6,
 0x1.3687a9f1af2b1p+6, 0x1.394d72518e725p+6, 0x1.3c133ab16db99p+6,
 0x1.3ed903114d00dp+6, 0x1.419ecb712c481p+6, 0x1.446493d10b8f5p+6,
 0x1.472a5c30ead69p+6, 0x1.49f02490ca1dcp+6, 0x1.4cb5ecf0a965p+6,
 0x1.4f7bb55088ac4p+6, 0x1.52417db067f38p+6, 0x1.55074610473acp+6,
 0x1.57cd0e702682p+6, 0x1.5a92d6d005c94p+6, 0x1.5d589f2fe5107p+6,
 0x1.601e678fc457bp+6, 0,
};

/* For 0 <= i2 < 2^7, T2[i2] approximates log(x2), where 1 <= x2 < 2
   and i2 matches the 7 lower bits of the 16-bit encoding of x2.
   Table generated by table2() in pow.sage. */
static const double T2[] = {
 0x0p+0, 0x1.fe02a6b106789p-8, 0x1.fc0a8b0fc03e4p-7, 0x1.7b91b07d5b11bp-6,
 0x1.f829b0e7833p-6, 0x1.39e87b9febd6p-5, 0x1.77458f632dcfcp-5,
 0x1.b42dd711971bfp-5, 0x1.f0a30c01162a6p-5, 0x1.16536eea37ae1p-4,
 0x1.341d7961bd1d1p-4, 0x1.51b073f06183fp-4, 0x1.6f0d28ae56b4cp-4,
 0x1.8c345d6319b21p-4, 0x1.a926d3a4ad563p-4, 0x1.c5e548f5bc743p-4,
 0x1.e27076e2af2e6p-4, 0x1.fec9131dbeabbp-4, 0x1.0d77e7cd08e59p-3,
 0x1.1b72ad52f67ap-3, 0x1.29552f81ff523p-3, 0x1.371fc201e8f74p-3,
 0x1.44d2b6ccb7d1ep-3, 0x1.526e5e3a1b438p-3, 0x1.5ff3070a793d4p-3,
 0x1.6d60fe719d21dp-3, 0x1.7ab890210d909p-3, 0x1.87fa06520c911p-3,
 0x1.9525a9cf456b4p-3, 0x1.a23bc1fe2b563p-3, 0x1.af3c94e80bff3p-3,
 0x1.bc286742d8cd6p-3, 0x1.c8ff7c79a9a22p-3, 0x1.d5c216b4fbb91p-3,
 0x1.e27076e2af2e6p-3, 0x1.ef0adcbdc5936p-3, 0x1.fb9186d5e3e2bp-3,
 0x1.0402594b4d041p-2, 0x1.0a324e27390e3p-2, 0x1.1058bf9ae4ad5p-2,
 0x1.1675cababa60ep-2, 0x1.1c898c16999fbp-2, 0x1.22941fbcf7966p-2,
 0x1.2895a13de86a3p-2, 0x1.2e8e2bae11d31p-2, 0x1.347dd9a987d55p-2,
 0x1.3a64c556945eap-2, 0x1.404308686a7e4p-2, 0x1.4618bc21c5ec2p-2,
 0x1.4be5f957778a1p-2, 0x1.51aad872df82dp-2, 0x1.5767717455a6cp-2,
 0x1.5d1bdbf5809cap-2, 0x1.62c82f2b9c795p-2, 0x1.686c81e9b14afp-2,
 0x1.6e08eaa2ba1e4p-2, 0x1.739d7f6bbd007p-2, 0x1.792a55fdd47a2p-2,
 0x1.7eaf83b82afc3p-2, 0x1.842d1da1e8b17p-2, 0x1.89a3386c1425bp-2,
 0x1.8f11e873662c7p-2, 0x1.947941c2116fbp-2, 0x1.99d958117e08bp-2,
 0x1.9f323ecbf984cp-2, 0x1.a484090e5bb0ap-2, 0x1.a9cec9a9a084ap-2,
 0x1.af1293247786bp-2, 0x1.b44f77bcc8f63p-2, 0x1.b9858969310fbp-2,
 0x1.beb4d9da71b7cp-2, 0x1.c3dd7a7cdad4dp-2, 0x1.c8ff7c79a9a22p-2,
 0x1.ce1af0b85f3ebp-2, 0x1.d32fe7e00ebd5p-2, 0x1.d83e7258a2f3ep-2,
 0x1.dd46a04c1c4a1p-2, 0x1.e24881a7c6c26p-2, 0x1.e744261d68788p-2,
 0x1.ec399d2468ccp-2, 0x1.f128f5faf06edp-2, 0x1.f6123fa7028acp-2,
 0x1.faf588f78f31fp-2, 0x1.ffd2e0857f498p-2, 0x1.02552a5a5d0ffp-1,
 0x1.04bdf9da926d2p-1, 0x1.0723e5c1cdf4p-1, 0x1.0986f4f573521p-1,
 0x1.0be72e4252a83p-1, 0x1.0e44985d1cc8cp-1, 0x1.109f39e2d4c97p-1,
 0x1.12f719593efbcp-1, 0x1.154c3d2f4d5eap-1, 0x1.179eabbd899a1p-1,
 0x1.19ee6b467c96fp-1, 0x1.1c3b81f713c25p-1, 0x1.1e85f5e7040dp-1,
 0x1.20cdcd192ab6ep-1, 0x1.23130d7bebf43p-1, 0x1.2555bce98f7cbp-1,
 0x1.2795e1289b11bp-1, 0x1.29d37fec2b08bp-1, 0x1.2c0e9ed448e8cp-1,
 0x1.2e47436e40268p-1, 0x1.307d7334f10bep-1, 0x1.32b1339121d71p-1,
 0x1.34e289d9ce1d3p-1, 0x1.37117b54747b6p-1, 0x1.393e0d3562a1ap-1,
 0x1.3b68449fffc23p-1, 0x1.3d9026a7156fbp-1, 0x1.3fb5b84d16f42p-1,
 0x1.41d8fe84672aep-1, 0x1.43f9fe2f9ce67p-1, 0x1.4618bc21c5ec2p-1,
 0x1.48353d1ea88dfp-1, 0x1.4a4f85db03ebbp-1, 0x1.4c679afccee3ap-1,
 0x1.4e7d811b75bb1p-1, 0x1.50913cc01686bp-1, 0x1.52a2d265bc5abp-1,
 0x1.54b2467999498p-1, 0x1.56bf9d5b3f399p-1, 0x1.58cadb5cd7989p-1,
 0x1.5ad404c359f2dp-1, 0x1.5cdb1dc6c1765p-1, 0x1.5ee02a9241675p-1,
 0x1.60e32f44788d9p-1,
};

/* For 0 <= i2 < 2^7, T3[i2] approximates log(x2), where x2 is
   subnormal, and i2 equals the 16-bit encoding of x2.
   Table generated by table3() in pow.sage. */
static const double T3[] = {
 0, -0x1.70c119cf00033p+6, -0x1.6dfb516f20bbfp+6, -0x1.6c5c1f3054c26p+6,
 -0x1.6b35890f4174bp+6, -0x1.6a510951049fep+6, -0x1.699656d0757b3p+6,
 -0x1.68f87d23736c9p+6, -0x1.686fc0af622d7p+6, -0x1.67f72491a981ap+6,
 -0x1.678b40f12558ap+6, -0x1.6729a7f340678p+6, -0x1.66d08e709633fp+6,
 -0x1.667e97b9673dp+6, -0x1.6632b4c394255p+6, -0x1.65ec0eb2595f2p+6,
 -0x1.65a9f84f82e63p+6, -0x1.656be3ee02c37p+6, -0x1.65315c31ca3a6p+6,
 -0x1.64f9fecbfda99p+6, -0x1.64c5789146116p+6, -0x1.64938284c82bdp+6,
 -0x1.6463df9361204p+6, -0x1.64365ad017293p+6, -0x1.640ac610b6ecbp+6,
 -0x1.63e0f8d3093c9p+6, -0x1.63b8cf5987f5cp+6, -0x1.639229f2fe40ep+6,
 -0x1.636cec63b4de1p+6, -0x1.6348fd6919042p+6, -0x1.632646527a17ep+6,
 -0x1.6304b2aab76d8p+6, -0x1.62e42fefa39efp+6, -0x1.62c4ad549526cp+6,
 -0x1.62a61b8e237c3p+6, -0x1.62886ca578094p+6, -0x1.626b93d1eaf32p+6,
 -0x1.624f8557e29f5p+6, -0x1.6234366c1e625p+6, -0x1.62199d1abbfc4p+6,
 -0x1.61ffb03166ca2p+6, -0x1.61e6672c38adp+6, -0x1.61cdba24e8e49p+6,
 -0x1.61b5a1c3f58d2p+6, -0x1.619e173381d9p+6, -0x1.61871413ae1e5p+6,
 -0x1.6170927037e1fp+6, -0x1.615a8cb7378adp+6, -0x1.6144fdb0d7a57p+6,
 -0x1.612fe077e6d6p+6, -0x1.611b307329f55p+6, -0x1.6106e94f5782bp+6,
 -0x1.60f306f9a8ae8p+6, -0x1.60df859aeee4dp+6, -0x1.60cc61931ef9ap+6,
 -0x1.60b9977545043p+6, -0x1.60a72403d596ep+6, -0x1.6095042d5268dp+6,
 -0x1.6083350939bcep+6, -0x1.6071b3d538d9bp+6, -0x1.60607df29ad0ap+6,
 -0x1.604f90e3ed972p+6, -0x1.603eea4ad8264p+6, -0x1.602e87e61ceb1p+6,
 -0x1.601e678fc457bp+6, -0x1.600e873b6bd9bp+6, -0x1.5ffee4f4b5df8p+6,
 -0x1.5fef7eddd7f2p+6, -0x1.5fe0532e4434fp+6, -0x1.5fd160316be87p+6,
 -0x1.5fc2a44598c21p+6, -0x1.5fb41ddadb2c6p+6, -0x1.5fa5cb720babfp+6,
 -0x1.5f97ab9bddd34p+6, -0x1.5f89bcf803581p+6, -0x1.5f7bfe345dfbdp+6,
 -0x1.5f6e6e0c3f1b1p+6, -0x1.5f610b47b3d0fp+6, -0x1.5f53d4badcb5p+6,
 -0x1.5f46c9455051bp+6, -0x1.5f39e7d18782ep+6, -0x1.5f2d2f5453002p+6,
 -0x1.5f209ecc5965cp+6, -0x1.5f1435419d1eap+6, -0x1.5f07f1c5099d5p+6,
 -0x1.5efbd37007602p+6, -0x1.5eefd9641645ep+6, -0x1.5ee402ca6dc35p+6,
 -0x1.5ed84ed3a291dp+6, -0x1.5eccbcb751783p+6, -0x1.5ec14bb3ced72p+6,
 -0x1.5eb5fb0ddaa67p+6, -0x1.5eaaca10589abp+6, -0x1.5e9fb80c0c2ccp+6,
 -0x1.5e94c45758439p+6, -0x1.5e89ee4e02464p+6, -0x1.5e7f3550f85e3p+6,
 -0x1.5e7498c61ab73p+6, -0x1.5e6a1818078ecp+6, -0x1.5e5fb2b5e9e6p+6,
 -0x1.5e5568134aae1p+6, -0x1.5e4b37a7e449p+6, -0x1.5e4120ef783b7p+6,
 -0x1.5e372369a6ef4p+6, -0x1.5e2d3e99c9674p+6, -0x1.5e237206ccc88p+6,
 -0x1.5e19bd3b0f9d9p+6, -0x1.5e101fc440bbdp+6, -0x1.5e0699333fb26p+6,
 -0x1.5dfd291bfeae2p+6, -0x1.5df3cf1565bdp+6, -0x1.5dea8ab9375e8p+6,
 -0x1.5de15ba3f64fap+6, -0x1.5dd84174cc7fdp+6, -0x1.5dcf3bcd73219p+6,
 -0x1.5dc64a521bc5ep+6, -0x1.5dbd6ca95a75ap+6, -0x1.5db4a27c10bb8p+6,
 -0x1.5dabeb7559927p+6, -0x1.5da34742762cdp+6, -0x1.5d9ab592bb896p+6,
 -0x1.5d92361780cbep+6, -0x1.5d89c8840e4fep+6, -0x1.5d816c8d8d6c4p+6,
 -0x1.5d7921eaf8dfp+6, -0x1.5d70e8550dd94p+6, -0x1.5d68bf863da3dp+6,
 -0x1.5d60a73a9fd4ep+6,
};

/* For 0 <= i1 < 2^6, T4[i1] approximates exp(i1*log(2)/2^6).
   Table generated by table4() in pow.sage. */
static const double T4[] = {
 0x1p+0, 0x1.02c9a3e778061p+0, 0x1.059b0d3158574p+0, 0x1.0874518759bc8p+0,
 0x1.0b5586cf9890fp+0, 0x1.0e3ec32d3d1a2p+0, 0x1.11301d0125b51p+0,
 0x1.1429aaea92dep+0, 0x1.172b83c7d517bp+0, 0x1.1a35beb6fcb75p+0,
 0x1.1d4873168b9aap+0, 0x1.2063b88628cd6p+0, 0x1.2387a6e756238p+0,
 0x1.26b4565e27cddp+0, 0x1.29e9df51fdee1p+0, 0x1.2d285a6e4030bp+0,
 0x1.306fe0a31b715p+0, 0x1.33c08b26416ffp+0, 0x1.371a7373aa9cbp+0,
 0x1.3a7db34e59ff7p+0, 0x1.3dea64c123422p+0, 0x1.4160a21f72e2ap+0,
 0x1.44e086061892dp+0, 0x1.486a2b5c13cdp+0, 0x1.4bfdad5362a27p+0,
 0x1.4f9b2769d2ca7p+0, 0x1.5342b569d4f82p+0, 0x1.56f4736b527dap+0,
 0x1.5ab07dd485429p+0, 0x1.5e76f15ad2148p+0, 0x1.6247eb03a5585p+0,
 0x1.6623882552225p+0, 0x1.6a09e667f3bcdp+0, 0x1.6dfb23c651a2fp+0,
 0x1.71f75e8ec5f74p+0, 0x1.75feb564267c9p+0, 0x1.7a11473eb0187p+0,
 0x1.7e2f336cf4e62p+0, 0x1.82589994cce13p+0, 0x1.868d99b4492edp+0,
 0x1.8ace5422aa0dbp+0, 0x1.8f1ae99157736p+0, 0x1.93737b0cdc5e5p+0,
 0x1.97d829fde4e5p+0, 0x1.9c49182a3f09p+0, 0x1.a0c667b5de565p+0,
 0x1.a5503b23e255dp+0, 0x1.a9e6b5579fdbfp+0, 0x1.ae89f995ad3adp+0,
 0x1.b33a2b84f15fbp+0, 0x1.b7f76f2fb5e47p+0, 0x1.bcc1e904bc1d2p+0,
 0x1.c199bdd85529cp+0, 0x1.c67f12e57d14bp+0, 0x1.cb720dcef9069p+0,
 0x1.d072d4a07897cp+0, 0x1.d5818dcfba487p+0, 0x1.da9e603db3285p+0,
 0x1.dfc97337b9b5fp+0, 0x1.e502ee78b3ff6p+0, 0x1.ea4afa2a490dap+0,
 0x1.efa1bee615a27p+0, 0x1.f50765b6e454p+0, 0x1.fa7c1819e90d8p+0,
};

/* For 0 <= i2 < 2^6, T5[i2] approximates exp(i2*log(2)/2^12).
   Table generated by table5() in pow.sage. */
static const double T5[] = {
 0x1p+0, 0x1.000b175effdc7p+0, 0x1.00162f3904052p+0, 0x1.0021478e11ce6p+0,
 0x1.002c605e2e8cfp+0, 0x1.003779a95f959p+0, 0x1.0042936faa3d8p+0,
 0x1.004dadb113dap+0, 0x1.0058c86da1c0ap+0, 0x1.0063e3a559473p+0,
 0x1.006eff583fc3dp+0, 0x1.007a1b865a8cap+0, 0x1.0085382faef83p+0,
 0x1.00905554425d4p+0, 0x1.009b72f41a12bp+0, 0x1.00a6910f3b6fdp+0,
 0x1.00b1afa5abcbfp+0, 0x1.00bcceb7707ecp+0, 0x1.00c7ee448ee02p+0,
 0x1.00d30e4d0c483p+0, 0x1.00de2ed0ee0f5p+0, 0x1.00e94fd0398ep+0,
 0x1.00f4714af41d3p+0, 0x1.00ff93412315cp+0, 0x1.010ab5b2cbd11p+0,
 0x1.0115d89ff3a8bp+0, 0x1.0120fc089ff63p+0, 0x1.012c1fecd613bp+0,
 0x1.0137444c9b5b5p+0, 0x1.01426927f5278p+0, 0x1.014d8e7ee8d2fp+0,
 0x1.0158b4517bb88p+0, 0x1.0163da9fb3335p+0, 0x1.016f0169949edp+0,
 0x1.017a28af25567p+0, 0x1.018550706ab62p+0, 0x1.019078ad6a19fp+0,
 0x1.019ba16628de2p+0, 0x1.01a6ca9aac5f3p+0, 0x1.01b1f44af9f9ep+0,
 0x1.01bd1e77170b4p+0, 0x1.01c8491f08f08p+0, 0x1.01d37442d507p+0,
 0x1.01de9fe280ac8p+0, 0x1.01e9cbfe113efp+0, 0x1.01f4f8958c1c6p+0,
 0x1.020025a8f6a35p+0, 0x1.020b533856324p+0, 0x1.02168143b0281p+0,
 0x1.0221afcb09e3ep+0, 0x1.022cdece68c4fp+0, 0x1.02380e4dd22adp+0,
 0x1.02433e494b755p+0, 0x1.024e6ec0da046p+0, 0x1.02599fb483385p+0,
 0x1.0264d1244c719p+0, 0x1.027003103b10ep+0, 0x1.027b357854772p+0,
 0x1.0286685c9e059p+0, 0x1.02919bbd1d1d8p+0, 0x1.029ccf99d720ap+0,
 0x1.02a803f2d170dp+0, 0x1.02b338c811703p+0, 0x1.02be6e199c811p+0,
};

// return a binary64 approximation of log(x), where x is encoded by u
static double
log_accurate (uint16_t u)
{
  uint16_t i1 = u >> 7;
  uint16_t i2 = u & 0x7f;
  return (i1 == 0) ? T3[i2] : T1[i1] + T2[i2];
}

static __bf16
exp_accurate (double ylogx, uint64_t sign, fexcept_t flag)
{
  // deal with overflow and underflow
  if (ylogx > 0x1.62e42fefa39efp+6) {
#ifdef CORE_MATH_SUPPORT_ERRNO
    errno = ERANGE; // overflow
#endif
    return (sign == 0) ? 0x1p128 : -0x1p128;
  }
  if (ylogx < -0x1.7386e22edf4a6p+6) {
#ifdef CORE_MATH_SUPPORT_ERRNO
    errno = ERANGE; // underflow
#endif
    return (sign == 0) ? 0x1p-134 : -0x1p-134; // underflow
  }

  // cases where x^y rounds to 1
  if (__builtin_fabs (ylogx) <= 0x1p-9)
    return (sign == 0) ? 1.0 + ylogx : -1.0 - ylogx;

#define K 0x1.71547652b82fep+12            // approximates 2^12/log(2)
#define INVK -0x1.62e42fefa39efp-13        // approximates -log(2)/2^12
  double jd = __builtin_trunc (K * ylogx); // |j| < 2^20
  int j = jd;
  int e = j >> 12, i1 = (j >> 6) & 0x3f, i2 = j & 0x3f;
  // ylogx = e*log(2) + i1*log(2)/2^6 + i2*log(2)/2^12 + r
  double r = __builtin_fma (jd, INVK, ylogx); // |r| < 2^-13 log(2) ~ 2^-13.5
  // approximate exp(r) with a degree-3 polynomial
  double rr = r * r;
  double c2 = 0.5 + 0x1.5555555555555p-3 * r;
  double c0 = 1.0 + r;
  b64u64_u expr = {.f = c0 + c2 * rr};
  expr.f *= T4[i1] * T5[i2];
  expr.u += sign + ((int64_t) e << 52);
#ifdef CORE_MATH_SUPPORT_ERRNO
  int u = (expr.f > 0) ? 1.0f - 0x1p-25f == 1.0f // true for rndn/rndu
    : -1.0f + 0x1p-25f == -1.0f;
  int v = (expr.f > 0) ? 1.0f + 0x1p-25f != 1.0f // true for rndu
    : -1.0f - 0x1p-25f != -1.0f;
  int exact = 0;
#endif
  // round to nearest the low-order bits to catch exact/midpoint values
  // for rndu and x,y=0x1.2p-63,0x1.8p+0  we get expr.u = 0x...000093
  // for rndd and x,y=0x1.2p-39,0x1.4p+1 we get expr.u = 0x...ffff27
  if (((expr.u + 0xd9) & 0xffffffffe00ull) <= 0x93) { // exact/midpoint case
#ifdef CORE_MATH_SUPPORT_ERRNO
    exact = 1;
#endif
    expr.u = (expr.u + 0xd9) & 0xfffffffffffffe00ull;
    set_flag (flag); // restore flags
  }
  __bf16 ret = expr.f;
#ifdef CORE_MATH_SUPPORT_ERRNO
  // in the underflow domain, expr might be exact, but still truncated
  exact = exact && ret == expr.f;
  double t = __builtin_fabs (expr.f);
  /* for rndz/rndd, we have underflow for t < 0x1p-126;
     for rndn, we have underflow for t < 0x1.ffp-127;
     for rndu, we have underflow for t <= 0x1.fep-127 */
  if (!exact && (t <= 0x1.fep-127 || (t < 0x1.ffp-127 && !v) || (t < 0x1p-126 && !u)))
    errno = ERANGE; // underflow
  /* for rndz/rndd, we have overflow for t >= 0x1p+128;
     for rndn, we have overflow for t >= 0x1.ffp+127;
     for rndu, we have overflow for t > 0x1.fep+127 */
  if (t >= 0x1p+128 || (t >= 0x1.ffp+127 && u) || (t > 0x1.fep+127 && v))
    errno = ERANGE; // overflow
#endif
  return ret;
}

__bf16 cr_pow_bf16(__bf16 x, __bf16 y){
  volatile fexcept_t flag = get_flag ();
  b16u16_u vx = {.f = x}, vy = {.f = y};
  uint16_t ux = vx.u, uy = vy.u;
  uint64_t sign = 0;

  if ((ux & 0x7fff) == 0x3f80) { // |x| = 1
    if (ux >> 15) { // x = -1
      if ((uy & 0x7fff) > 0x7f80) return y + y; // y = NaN
      if (isint(vy)) return (isodd(vy)) ? vx.f : -vx.f;
#ifdef CORE_MATH_SUPPORT_ERRNO
      errno = EDOM;
#endif
      return 0.0f / 0.0f;
    }
    return ((uy & 0x7fff) > 0x7f80 && !(uy & 0x040)) ? y + y : x;
    // 1^y = 1 except if y = sNaN
  }

  if (!(uy & 0x7fff)) // y = 0
    // x^0 = 1 except if x = sNaN
    return ((ux & 0x7fff) > 0x7f80 && !(ux & 0x040)) ? x + x : one.f;

  if ((uy & 0x7fff) >= 0x7f80) { // y = Inf/NaN
    // the case |x| = 1 was checked above
    if ((ux & 0x7fff) > 0x7f80) return x + x; // x = NaN
    if ((uy & 0x7fff) == 0x7f80) { // y = +/-Inf
      if (((ux & 0x7fff) < 0x3f80) ^ (uy >> 15))
        return posinf.f; // |x| < 1 && y = -Inf or |x| > 1 && y = +Inf
      else
        return poszero.f; // |x| < 1 && y = +Inf or |x| > 1 && y = -Inf
    }
    return y + y; // y = NaN
  }

  if (!(ux & 0x7fff)) { // if x = 0
    if (uy >> 15) { // y < 0
#ifdef CORE_MATH_SUPPORT_ERRNO
      errno = ERANGE;
#endif
      if (isodd(vy) && ux >> 1) return neginf.f;
      else return posinf.f;
    } else { // y > 0
      if (isodd(vy) && ux >> 1) return negzero.f;
      else return poszero.f;
    }
  }

  if (ux >= 0x7f80) { // x = Inf or x = NaN or x <= 0
    if ((ux & 0x7fff) == 0x7f80) { // x = +/-Inf
      if (!isodd(vy)) ux &= 0x7fff; // y even -> ret will be positive
      if (uy >> 15) ux &= 0x8000; // y < 0 -> ret will be +/-0
      return vx.f;
    }
    if ((ux & 0x7fff) > 0x7f80) return x + x; // x is NaN
    // x < 0
    if (!isint(vy)) {
#ifdef CORE_MATH_SUPPORT_ERRNO
      errno = EDOM;
#endif
      return 0.0f / 0.0f;
    }
    else if (isodd(vy)) sign = 1ull << 63;
    ux &= 0x7fff;
  }

  double logx = log_accurate (ux);
  double ylogx = (double) y * logx;
  return exp_accurate (ylogx, sign, flag);
}

// dummy function since GNU libc does not provide it
__bf16 pow_bf16 (__bf16 x, __bf16 y) {
	return (__bf16) powf ((float) x, (float) y);
}
