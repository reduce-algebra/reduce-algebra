\chapter*{Error Handling}

\section{Introduction}

  In  PSL,  as in most LISP systems, various kinds of errors are
detected by functions in the process of checking the validity of
their argument types and other  conditions.    Errors  are  then
"signalled"  by  a call on an error function.  In PSL, the error
handler typically calls an interactive break loop, which permits
the user to examine the context of the error and optionally make
some corrections and continue the computation, or to  abort  the
computation.

  While  in  the  break  loop,  the  user remains in the binding
context of the function that detected the error; the  user  sees
the value of fluid variables as they are in the function itself.
If  the  user  aborts the computation, fluid and local variables
are unbound. In compiled functions, due to allocation of local variables
in the (system) stack, local variables are invisible to the error
handler and the debugging facilities. Therefore, compilation can
be recommended for fully debugged code, only.

\section{The Basic Error Functions}

\de{error}{(error NUMBER: integer MESSAGE:any): None Returned}{expr}
{    Under  the  initial  (and  usual)  values  of  a  couple  of
    switches,  the  error  message is printed and an interactive
    break loop (see below) is entered.  If the user "quits"  out
    of  the  interactive  break  loop,  control  returns  to the
    innermost error handler.  }

    The user may supply an error handler. The interactive break
    loop and the top level loop also supply error handlers, so
    if the user makes no special preparation, control will
    return to an existing break loop or to the top level of PSL.


    Whenever a call on error  results  in  return  to  an  error
    handler,  the  error  number  of the error becomes the value
    returned by the error handler.  Fluid  variables  and  local
    bindings  are  unbound  to  return to the environment of the
    error handler.  Global variables are  not  affected  by  the
    process.    The  error  message  is  printed  with 5 leading
    asterisks  on  both  the  standard  output  device  and  the
    currently  selected output device unless the standard output
    device is not open.    If  the  message  is  a  list  it  is
    displayed  without  top level parentheses.  The message from
    the error call is available for  later  examination  in  the
    global variable {\tt emsg*}.

    Note:  the  exact  format of error messages generated by PSL
    functions described in this document may not be  exactly  as
    given  and should not be relied upon to be in any particular
    form.  Likewise, error numbers generated  by  PSL  functions
    are  not  fixed.   Currently, a number of different calls on
    error result in the same error message and number.


\DE{continuableerror}{(continuableerror NUMBER:integer MESSAGE:any\\
FORM: form): any}{expr}  
{   Similar to error.  If an interactive break is entered due to
    a  call  on  continuableerror,  the  user  has  options   of
    "continuing"  or  "retrying"  (see  information on the break
    loop, below).    In  either  of  these  cases  the  call  on
    continuableerror   returns.     The  value  returned  is  as
    described in the  documentation  of  the  interactive  break
    loop.  }
    
    The FORM argument is used for "retrying" after a continuable
    error.    The  FORM is generally made to look like a call on
    the function  that  signalled  the  error  (actual  argument
    values  filled  in),  and  the function signalling the error
    generally returns with the value returned  by  the  call  on
    continuableerror.  For example the call on conterror, in the
    example  below  is  equivalent  to  the  following  call  on
    continuableerror:
\begin{verbatim}
(continuableerror 99 "Attempt to divide by 0 in DIVIDE"
          (list 'divide (mkquote u) (mkquote v)))
\end{verbatim}
    The FORM argument may be nil.  In this case it  is  expected
    that  the  break  will  be  left  via "continue" rather than
    "retry".

    As in the example above, setting up the errorform* can get a
    bit tricky, often involving mkquoteing of already  evaluated
    arguments.  The following macro may be useful.

\de{conterror}{(conterror [ARGS:any]): any}{macro}
{The format of ARGS is \\
{\tt (errornumber formatstring \{arguments to printf\} reevalform).}
}
    The FORMATSTRING  is used with the following arguments in a
    call on bldmsg to build an  error  message.    If  the  only
    argument  to  printf  is  a  string, the FORMATSTRING may be
    omitted, and no call to  bldmsg  is  made.    REEVALFORM  is
    something like
    {\tt (foo x y)}
    which becomes
    {\tt (list 'foo (mkquote x) (mkquote y))}
    to be passed to the function continuableerror.

\begin{verbatim}
(de divide (u v)
  (cond ((zerop v)
          (conterror 99
                "Attempt to divide by 0 in DIVIDE"
                (divide u v)))
         (t (cons (quotient u v) (remainder u v)))
 ))
\end{verbatim}

\de{fatalerror}{(fatalerror S:any): None Returned}{expr}
{This  function allows neither continuation nor even a return
    to any error handler.
}
\begin{verbatim}
    (de fatalerror (s)
      (errorprintf "***** Fatal error: %S" s)
      (while t (quit))
      nil)
\end{verbatim}

\section{Basic Error Handlers}

\de{errset}{(errset U:form *EMSGP:boolean): any}{macro}
{    Errset  and  errorset  are  the  basic  PSL  error   handler
    functions.
}

    If  an error occurs during the evaluation of U, the value of
    number from the associated error call  is  returned  as  the
    value  of  the  errset.    There  are  actually  a couple of
    exceptions.  If a continuable error is continued by the user
    in the interactive break loop, no special return  to  errset
    is  done.    Also if the user requests the computation to be
    aborted completely back to the top level no return to errset
    is done.

    The boolean argument is evaluated without protection of  the
    error  handler.    The fluid variable *EMSGP is bound to the
    boolean value for the evaluation of the form.  If the  value
    of  *EMSGP  is  nil when an error occurs no error message is
    printed and no interactive break loop occurs.  In this  case
    control  must  return  to the innermost error handler except
    for the case of a fatal error.

    If errset is returned to in the normal way, its value  is  a
    list  of  one  element, the value of the form.  If errset is
    returned to via the error mechanism, its value is the  error
    number of the error call that caused the return.


\de{errorset}{(errorset U:any *EMSGP:boolean *BACKTRACE:boolean): any}{expr}

{    This  is an older function than errset.  Errset is generally
    preferred.  }

    In most respects errorset behaves the same as errset.    See
    the documentation of errset above.  Note that errorset is an
    expr,  so  U  gets evaluated once as the parameter is passed
    and the result is then  evaluated  inside  errorset.   Since
    errorset  itself  calls eval on its first argument there are
    likely to be problems with compiled code that uses errorset.

    In addition to  binding  *EMSGP  as  errset  does,  errorset
    overrides  the  behavior usually specified by the *BACKTRACE
    switch.  The backtrace behavior of  PSL  errors  during  the
    execution  of  a  form  inside  an errorset error handler is
    determined by the second parameter to the errorset.

  The following two switches and one global variable are used by
the functions in this section.  Useage of any of  these  can  be
considered advanced.

\variable{*emsgp}{[Initially: t]}{fluid}
{
    Fluid  variable  rebound  by  errset and errorset.  Controls
    error message printing during call on error.    If  nil,  no
    error  message will be printed and no interactive break loop
    will be entered.  If an unwind backtrace has been  requested
    through  the  backtrace flag or a call on errorset, one will
    be.
}

\variable{emsg*}{[Initially: nil]}{global}
{
    Contains the message generated   by  the  last  error  call.
    Particularly  useful  in  case  printing  of the message was
    suppressed.
}

\variable{*backtrace}{[Initially: nil]}{switch}
{
    Used by  the  top  level  read-eval-print  loop  to  control
    whether  an  unwind  backtrace  will  be printed when errors
    occur outside the scope of any user-specified error handler.
}

\section{Break Loop}

  On detecting an error, PSL normally enters  a  read/eval/print
loop  called  a break loop.  Here the user can examine the state
of his computation,  change  the  values  of  fluid  and  global
variables, or define missing functions.  He can then dismiss the
error  call  to the normal error handling mechanism (errorset or
errset above).  If the error was of the continuable type, he may
continue the computation.  By setting the switch *break to  nil,
all  break loops can be suppressed, and just an error message is
displayed.  Suppressing error  messages  also  suppresses  break
loops.

\variable{*break}{[Initially: t]}{switch}
{
    Controls  whether  the    break  package  is   called before
    unwinding the stack on error.
}

\variable{breaklevel*}{[Initially: 0]}{global}
{
    The current number of nesting level of breaks.
}

\variable{maxbreaklevel*}{[Initially: 5]}{global}
{
    The maximum number of nesting levels  of  breaks  permitted.
    If  an  error  occurs  with  at  least this number of nested
    breaks already existing, no entry to  an  interactive  break
    loop  is  made.   Control aborts back to the innermost error
    handler instead.
}

\vspace{1cm}
The prompt {\tt "lisp break>"} indicates that PSL  has entered a break
loop.   A  message  of  the form "Retry form is ..." may also be
printed, in  which  case  the  user  is  able  to  continue  his
computation  by repairing the offending expression.  By default,
a break loop uses the functions read, eval, and print.  This may
be  changed  by  setting  {\tt breakreader*, breakevaluator*, or
breakprinter*} to the appropriate function name.

\vspace{1cm}
\variable {errorform*} {[Initially: nil]} {global}
{
    Contains  an   expression to reevaluate inside  a break loop
    for continuable errors.  Used as a  tag  for  various  Error
    functions.
}

\vspace{1cm}  
  Several  ids,  if  typed  at top-level, are special in a break
loop.  These are used as commands, and  are currently M,  R,  T,
Q,  A,  I,  and C.  They call functions stored on their property
lists under the indicator breakfunction.  These ids are  special
only  at   top-level, and  do not  cause  any difficulty if used
as variables inside expressions.    However,  they  may  not  be
simply   typed at top-level  to see their  values.  This is  not
expected to cause any difficulty.\\

The meanings of these commands are:\\

\begin{tabular}{lp{14.0cm}}

M & Display errorform*, this command calls the function 
breakerrmsg.\\

R & Retry. This tries to evaluate the retry form, and 
	 continue the computation. It evaluates the value of
	errorform*. This is often useful after defining a 
	missing function or assigning a value to a variable. 
	This command calls the function breakretry.\\

C &          Continue. This causes the expression last printed
             by  the  break loop to be returned as the value of
             the  call  on  continuableerror.   This  is  often
             useful  as  an  automatic  stub.  If an expression
             containing an undefined function is  evaluated,  a
             break  loop  is  entered,  and this may be used to
             return the value  of  the  function  call.    This
             command calls the function breakcontinue.\\

Q &          Quit. This exits the break loop by throwing to
             the closest surrounding error handler. It  calls
             the function breakquit.\\

A &          Abort. This  aborts  to  the  top  level, i.e.,
             restarts PSL. It calls the function reset.\\

T &          Trace. This prints a backtrace of function calls
             on the stack except for those on the lists
             ignoredinbacktrace* and interpreterfunctions*. It
             calls the function backtrace.\\

I &          Interpreter  Trace. This prints a backtrace of
             only interpreted functions call on the stack
             except for those on the list interpreterfunctions*.
													It calls  the  function interpbacktrace.
\end{tabular}

\vspace{0.5cm}
An  attempt  to  continue  a non-continuable error with R or C
prints a message and behaves as Q.

\variable{ignoredinbacktrace*}{[Initially: string]}{global}
{ A list of function names that will not  be  printed  by  the
  commands I and T given within a break loop
  (eval apply fastapply codeapply codeevalapply catch errorset
  evprogn toploop breakeval bindeval break main).
}

\variable{interpreterfunctions*}
{[Initially: string]}{global}
{
    A  list  of  function  names that will not be printed by the
    command I given within a break loop
    (cond prog and or progn setq).
}

\vspace{0.5cm}
The above two globals can be reset in  an  init  file  if  the
programmer desires to do so.
\begin{verbatim}
(de new-nth (seq index)
    (cond ((onep index) (car x))
          (t (new-nth (rest index) (sub1 index)))))

1 lisp> (new-nth '(a b c) 2)
***** `S' is an unbound ID
***** Continuable error: retry form is `S'
2 lisp break (1)> t
Backtrace from top of stack:
car new-nth new-nth
NIL
3 lisp break (1)> seq
(b c)
4 lisp break (1)> c
b
\end{verbatim}

\section{Details on the Break Loop}

  If  the  switch  break  is  t, the function break is called by
error or continuableerror  before    unwinding  the  stacks,  or
printing  a  backtrace.  Input and output to/from break loops is
done from/to the  values (channels) of {\tt breakin*}  and
{\tt breakout*}.
The  channels  selected  on    entrance  to  the break  loop are
restored upon exit.

\variable{breakin*}{[Initially: nil]}{global}
{
    So rds chooses stdin*.
}

\variable{breakout*}{[Initially: nil]}{global}
{
    Similar to breakin*.
}

\vspace{1cm}
		Break is essentially  a read-eval-print function,  called   in
the    error    context.   Any fluid may be  printed or changed,
function definitions  changed, etc.  The break uses  the  normal
toploop  mechanism (including history), embedded in a catch with
tag $break$.  The toploop attempts  to  use  the  parent  loop's
toploopread*,  toploopprint*  and  toploopeval*;  the  breakeval
function first checks top-level  ids  to  see  if  they  have  a
special  breakfunction  on  their  property  lists, stored under
breakfunction.   This  is  expected  to  be  a  function  of  no
arguments, and is applied instead of eval.

\section{Some Convenient Error Calls}

  The following functions may be useful in user packages:

\de{rangeerror}{(rangeerror OBJECT:any INDEX:integer FN:function):\\
None}{expr}
{
{\tt (stderror \\
       (bldmsg "Index \%r out of range for \%p in \%p"
                                INDEX  OBJECT  FN))}
}

\de{stderror}{(stderror MESSAGE:string): None Returned}{expr}
{
{\tt (error 99 message)}
}

\de{typeerror}{(typeerror OFFENDER:any FN:function TYP:any):\\
None Returned}{expr}
{
{\tt (stderror (bldmsg\\
     "An attempt was made to do \%p on \%r, which is not \%w"\\
        FN  OFFENDER  TYP))}
}

\de{usagetypeerror}
{(usagetypeerror OFF:any FN:function TYP:any USAGE:any):\\
None Returned}{expr}
{
{\tt (stderror (bldmsg\\
\small
\verb+"An attempt was made to use \%r as \%w in \%p, where \%w is needed"+
OFFENDER  USAGE  FN  TYP))}
}

\de{nonwordserror}{(nonwordserror OFFENDER:any FN:function): None
Returned}{expr} 
{
{\tt (typeerror OFFENDER FN "a words vector")}
}

\de{nonpairerror}{(nonpairerror OFFENDER:any FN:function): None
Returned}{expr} 
{
{\tt (typeerror OFFENDER FN "a pair")}
}

\de{nonlisterror}{(nonlisterror OFFENDER:any FN:function):\\ 
None Returned}{expr}
{
{\tt (typeerror OFFENDER FN "a list or NIL")}
}

\de{noniderror}{(noniderror OFFENDER:any FN:function): None
Returned}{expr} 
{
{\tt (typeerror OFFENDER FN "an identifier")}
}

\de{nonnumbererror}{(nonnumbererror OFFENDER:any FN:function):
None Returned}{expr} 
{
{\tt (typeerror OFFENDER FN "a number")}
}

\de{nonintegererror}{(nonintegererror OFFENDER:any FN:function):
None Returned}{expr} 
{
{\tt (typeerror OFFENDER FN "an integer")}
}

\de{nonpositiveintegererror}
{(nonpositiveintegererror OFFENDER:any FN:function): None}{expr}
{ 
{\tt (typeerror OFFENDER FN "a non-negative integer")}
}

\de{noncharactererror}{(noncharactererror OFFENDER:any
FN:function): None Returned}{expr} 
{   
{\tt (typeerror OFFENDER FN "a character")}
}

\de{nonstringerror}{(nonstringerror OFFENDER:any FN:function):
None Returned}{expr} 
{
{\tt (typeerror OFFENDER FN "a string")}
}

\de{nonvectorerror}{(nonvectorerror OFFENDER:any FN:function):
None Returned}{expr} 
{
{\tt (typeerror OFFENDER FN "a vector")}
}

\de{nonwordserror}{(nonwordserror OFFENDER:any FN:function): None
Returned}{expr} 
{ {\tt (typeerror OFFENDER FN "a words vector")} }

\de{nonsequenceerror}{(nonsequenceerror OFFENDER:any FN:function):
None Returned}{expr} 
{ {\tt (typeerror OFFENDER FN "a sequence")} }
