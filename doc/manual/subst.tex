\ttindextype{// (double slash)}{operator}
\index{Double slash operator!in rules}
\index{Rules!Double slash operators}
\index{Operator!double slash}
The \emph{double slash operator} may be used as an alternative to a single
slash (quotient) in order to match quotients properly.  E.g., in the
example of the Gamma function above, one can use:
\begin{verbatim}
gammarule :=
   {gamma(~z)//(~c*gamma(~zz))  => gamma(z)/(c*gamma(zz-1)*zz)
                  when fixp(zz -z) and (zz -z) >0,
    gamma(~z)//gamma(~zz) => gamma(z)/(gamma(zz-1)*zz)
                  when fixp(zz -z) and (zz -z) >0};

let gammarule;

gamma(z)/gamma(z+3);

          1
----------------------
  3      2
 z  + 6*z  + 11*z + 6
\end{verbatim}
\index{Double tilde variables!in rules}
\index{Rules!Double tilde variables}
\index{Variable!double tilde}
The above example suffers from the fact that two rules had to be
written in order to perform the required operation. This can be simplified
by the use of \emph{double tilde variables}. E.g. the rule list
\begin{verbatim}
 GGrule :=  {
    gamma(~z)//(~~c*gamma(~zz))  => gamma(z)/(c*gamma(zz-1)*zz)
     when fixp(zz -z) and (zz -z) >0};
\end{verbatim}
will implement the same operation in a much more compact way.
In general, double tilde variables are bound to the neutral element
with respect to the operation in which they are used.

\begin{tabular}{lll}

Pattern given & Argument used & Binding  \\
\\
\textasciitilde z + \textasciitilde \textasciitilde y  &   x   &  z=x; y=0  \\   
\textasciitilde z + \textasciitilde \textasciitilde y  &   x+3 &  z=x; y=3  or  z=3; y=x \\ 
\\
\textasciitilde z * \textasciitilde \textasciitilde y  &   x   &  z=x; y=1\\
\textasciitilde z * \textasciitilde \textasciitilde y  &   x*3 &  z=x; y=3  or  z=3; y=x\\
\\
\textasciitilde z / \textasciitilde \textasciitilde y  &    x   &  z=x; y=1\\
\textasciitilde z / \textasciitilde \textasciitilde y  &    x/3 &  z=x; y=3  \\
\\
\end{tabular}

Remarks: A double tilde variable as the numerator of a pattern is not allowed.
Also, using double tilde variables may lead to recursion errors when the
zero case is not handled properly.
\begin{verbatim}
let f(~~a * ~x,x)  => a * f(x,x) when freeof (a,x);

f(z,z);

***** f(z,z) improperly defined in terms of itself

% BUT:

let ff(~~a * ~x,x)
       => a * ff(x,x) when freeof (a,x) and a neq 1;

ff(z,z);
                 ff(z,z)

ff(3*z,z);
                 3*ff(z,z)
\end{verbatim}

\subsection*{Displaying Rules Associated with an Operator}
\hypertarget{operator:SHOWRULES}{}

The operator \texttt{showrules}\ttindextype{showrules}{operator} takes a single identifier
as argument, and returns in rule-list form the operator rules associated
with that argument.  For example:
\begin{verbatim}
showrules log;

                    1
{df(log(~x),~x) => ---,
                    x

         ~x
 df(log(----),~z) => df(log(x),z) - df(log(y),z)}
         ~y
\end{verbatim}

Such rules can then be manipulated further as with any list.  For example
\texttt{rhs first ws;} has the value \texttt{1}.  Note that an operator may
have other properties that cannot be displayed in such a form, such as the
fact it is an odd function, or has a definition defined as a procedure.

\subsection*{Order of Application of Rules}

If rules have overlapping domains, their order of application is
important.  In general, it is very difficult to specify this order
precisely, so that it is best to assume that the order is arbitrary.
However, if only one operator is involved, the order of application of the
rules for this operator can be determined from the following:

\begin{enumerate}
\item Rules containing at least one free variable apply before all rules
without free variables.
\item Rules activated in the most recent \texttt{let}
command are applied first.
\item \texttt{let} with several entries generate
the same order of application as a corresponding sequence of commands with
one rule or rule set each.
\item Within a rule set, the rules containing at least
one free variable are applied in their given order.
In other words, the first member of the list is applied first.
\item Consistent with the first item, any rule in a rule list that
contains no free variables is applied after all rules containing free
variables.
\end{enumerate}
\textit{Example:} The following rule set enables the computation of exact
values of the Gamma function:
\begin{verbatim}
        operator gamma,gamma_error;
        gamma_rules :=
        {gamma(~x)=>sqrt(pi)/2 when x=1/2,
         gamma(~n)=>factorial(n-1) when fixp n and n>0,
         gamma(~n)=>gamma_error(n) when fixp n,
         gamma(~x)=>(x-1)*gamma(x-1) when fixp(2*x) and x>1,
         gamma(~x)=>gamma(x+1)/x when fixp(2*x)};
\end{verbatim}
Here, rule by rule, cases of known or definitely uncomputable values
are sorted out; e.g. the rule leading to the error expression
will be applied for negative integers only, since the positive
integers are caught by the preceding rule, and the
last rule will apply for negative odd multiples of $1/2$ only.
Alternatively the first rule could have been written as
\begin{verbatim}
        gamma(1/2) => sqrt(pi)/2,
\end{verbatim}
but then the case $x=1/2$ should be excluded in the \texttt{when} part of the
last rule explicitly because a rule without free variables cannot take
precedence over the other rules.

\section{Asymptotic Commands} \index{Asymptotic command}
\label{sec-asymp}
In expansions of polynomials involving variables that are known to be
small, it is often desirable to throw away all powers of these variables
beyond a certain point to avoid unnecessary computation.  The command 
\texttt{let} may be used to do this.  For example, if only powers of \texttt{x} up to
\texttt{x\textasciicircum 7} are needed, the command
\begin{verbatim}
        let x^8 = 0;
\end{verbatim}
will cause the system to delete all powers of \texttt{x} higher than 7.

\textit{CAUTION:}  This particular simplification works differently from most
substitution mechanisms in {\REDUCE} in that it is applied during
polynomial manipulation rather than to the whole evaluated expression.
Thus, with the above rule in effect, 
\texttt{x\textasciicircum 10/x\textasciicircum 5} would give the
result zero, since the numerator would simplify to zero.  Similarly
\texttt{x\textasciicircum 20/x\textasciicircum 10} would give a 
\texttt{Zero divisor} error message,
since both numerator and denominator would first simplify to zero.

\hypertarget{command:WEIGHT}{}
The method just described is not adequate when expressions involve several
variables having different degrees of smallness. In this case, it is
necessary to supply an asymptotic weight to each variable and count up the
total weight of each product in an expanded expression before deciding
whether to keep the term or not. There are two associated commands in the
system to permit this type of asymptotic constraint. The command 
\texttt{weight}\ttindextype{weight}{command}
takes a list of equations of the form
\begin{syntax}
  \meta{kernel form}\texttt{ = }\meta{number}
\end{syntax}
where \meta{number} must be a positive integer (not just evaluate to a
positive integer).  This command assigns the weight \meta{number} to the
relevant kernel form.  A check is then made in all algebraic evaluations
to see if the total weight of the term is greater than the weight level
assigned to the calculation.  If it is, the term is deleted.  To compute
the total weight of a product, the individual weights of each kernel form
are multiplied by their corresponding powers and then added.

\hypertarget{command:WTLEVEL}{}
The weight level of the system is initially set to 1. The user may change
this setting by the command\ttindextype{wtlevel}{command}
\begin{syntax}
        \texttt{wtlevel }\meta{number}\texttt{;}
\end{syntax}
which sets \meta{number} as the new weight level of the system.
\meta{number} must evaluate to a positive integer.  \texttt{wtlevel} will also
allow \texttt{nil} as an argument, in which case the current weight level is returned.
