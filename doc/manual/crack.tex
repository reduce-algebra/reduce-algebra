\subsection{Introduction}

\subsubsection{Purpose}

The package \package{Crack} attempts the solution of an overdetermined
system of algebraic, ordinary or partial differential equations
(ODEs/PDEs) with at most polynomial nonlinearities.

Under `normal circumstances' differential equations (DEs) which
describe physical processes are not overdetermined, i.e.\ the number
of DEs matches the number of unknown functions which are involved.
Although \package{Crack} may be successful in such cases (e.g.\ for
characteristic ODE-systems of first order PDEs) this is not the
typical application.  It is rather the qualitative investigations of
such differential equations, i.e.\ the investigation of their
infinitesimal symmetries (with \package{LiePDE} and
\package{ApplySym}) and conservation laws (with \package{Conlaw})
which result in over-determined systems which are the main application
area of \package{Crack}.

\subsubsection{Interactivity}

The package was originally developed to run automatically and effort
was made for the program to decide which computational steps are to be
done next with a choice among integrations, separations, substitutions
and investigation of integrability conditions.  It is known from hand
computations that the right sequence of operations with exactly the
right equations at the right time is often crucial to avoid an
explosion of the length of expressions.  This statement keeps its
truth for the computerized solution of systems of equations as they
become more complex.  As a consequence more and more interactive
access has been provided to inspect data, to specify how to proceed
with the computation and how to control it.  This allows human
intervention in critical stages of the computations (see the switch
\texttt{off batch\_mode} below).

\subsubsection{General Structure}

A problem consists of a system of equations and a set of inequalities.
With each equation are associated a short name and numerous data, like
size, which functions, derivatives and variables occur but also which
investigations have already been done with this equation and which not
in order to avoid unnecessary duplication of work.  These data are
constantly updated if the equation is modified in any way.

A set of about 30 modules is available to integrate, substitute,
decouple, \ldots\ equations.  A complete list can be inspected in
interactive mode with the command \texttt{p2}, which lists each
operation with the number by which it is called.  All modules can be
called interactively or automatically.  Automatic computation is
organized by a priority list of modules (each represented by a number)
where modules are invoked in the order they appear in the priority
list, each module trying to find equations in the system it can be
applied to.  The priority list can be inspected with the command
\texttt{p1}.  If a module is not successful then the next module in
the list is tried; if any one is successful then execution starts
again at the beginning of the priority list.  See the
\hyperref[crack-lb1]{Reference} subsection below for further details.

Because each module has access to all the data, it is enough to call a
module by its number.  For example, inputting the number 2 in
interactive mode will start the direct separation module (see below)
to look for a directly separable equation and split it.

\subsection{Syntax}

\subsubsection{The call}
\package{Crack} is called by
\begin{center}
  \begin{tabular}{r@{}l}\tt
    crack( & \{\textit{equ}$_1$, \textit{equ}$_2$, \ldots , \textit{equ}$_m$\}, \\
    & \{\textit{ineq}$_1$, \textit{ineq}$_2$, \ldots , \textit{ineq}$_n$\}, \\
    & \{\textit{fun}$_1$, \textit{fun}$_2$, \ldots , \textit{fun}$_p$\}, \\
    & \{\textit{var}$_1$, \textit{var}$_2$, \ldots , \textit{var}$_q$\});
  \end{tabular}
\end{center}
where $m,n,p,q$ are arbitrary.
\begin{itemize}
\item The \textit{equ}$_i$ are identically vanishing partial
  differential expressions, i.e.\ they represent equations $0 =
  \mathit{equ}_i$, which are to be solved for the functions
  \textit{fun}$_j$ as far as possible, thereby drawing only necessary
  conclusions and not restricting the general solution.
\item The \textit{ineq}$_i$ are algebraic or differential expressions
  which must not vanish identically for any solution to be determined,
  i.e.\ only such solutions are computed for which none of the
  expressions \textit{ineq}$_i$ vanishes identically in all
  independent variables.
\item The dependence of the (scalar) functions \textit{fun}$_j$ on
  independent variables must be defined beforehand with
  \texttt{depend} rather than declaring these functions as operators.
  Their arguments may themselves only be identifiers representing
  variables, not expressions.  Also other unknown functions not in
  \textit{fun}$_j$ must not be represented as operators but only
  declared using \texttt{depend}.
\item The functions $\textit{fun}_j$ and their derivatives may only
  occur polynomially.
\item The $\textit{var}_k$ are further independent variables, which
  are not already arguments of any of the $\textit{fun}_j$.  If there
  are none then the fourth argument is the empty list \texttt{\{\}},
  although it does no harm to include arguments of functions
  $\textit{fun}_j$.
\item The dependence of the $\textit{equ}_i$ on the independent
  variables and on constants and functions other than $\textit{fun}_j$
  is arbitrary.
\item \package{Crack} can be run in automatic batch mode (the default)
  or interactively with the switch setting \texttt{off batch\_mode}.
\end{itemize}

\subsubsection{The result}
The result is a list of solutions
\[ \{\textit{sol}_1, \ldots \}, \]
where each solution is a list of 4 lists
\[ \begin{array}{r@{}l}
  \{ & \{\textit{con}_1, \textit{con}_2, \ldots , \textit{con}_q\}, \\
  &\{\textit{fun}_a=\textit{ex}_a, \textit{fun}_b=\textit{ex}_b,
  \ldots , \textit{fun}_p=\textit{ex}_p\}, \\
  &\{\textit{fun}_c, \textit{fun}_d, \ldots , \textit{fun}_r\}, \\
  &\{\textit{ineq}_1, \textit{ineq}_2, \ldots , \textit{ineq}_s\} \}.
\end{array} \]
For example, in the case of a linear system, the input consists of at
most one solution $\textit{sol}_1$.

If \package{Crack} finds a contradiction, e.g.\ $0=1$, then there
exists no solution and it returns the empty list \texttt{\{\}}.  If
\package{Crack} can factorize algebraically a non-linear equation then
factors are set to zero individually and different sub-cases are
studied by \package{Crack} calling itself recursively.  If during such
a recursive call a contradiction results, then this sub-case will not
have a solution but other sub-cases still may have solutions.  The
empty list is also returned if no solution exists which satisfies the
inequalities \textit{ineq}$_i \neq 0$.

The expressions $\textit{con}_i$ (if there are any), are the remaining
necessary and sufficient conditions for the functions
$\textit{fun}_c,\ldots,\textit{fun}_r$ in the third list.  Those
functions can be original functions from the equations to be solved
(of the second argument of the call of \package{Crack}) or new
functions or constants which arose from integrations.  The dependence
of new functions on variables is declared with \texttt{depend} and to
visualize this dependence the algebraic mode function
\texttt{fargs(}\textit{fun}$_i$\texttt{)} can be used.  If there are
no $\textit{con}_i$ then all equations are solved and the functions in
the third list are unconstrained.  The second list contains equations
$\textit{fun}_i=\textit{ex}_i$ where each $\textit{fun}_i$ is an
original function and $\textit{ex}_i$ is the computed expression for
$\textit{fun}_i$.  The elements of the fourth list are the expressions
that have been assumed to be nonzero in the derivation of this
solution.

\subsubsection{Automatic versus Interactive}

Under normal circumstances one will try to have problems solved
automatically by \package{Crack}.  An alternative is to input
\texttt{off batch\_mode;} before calling \package{Crack} and to solve
problems interactively.  In interactive mode it is possible to
\begin{itemize}
\item inspect data, like equations and their properties, unknown
  functions, variables, identities, and statistics;
\item save, change, add or drop equations;
\item add inequalities;
\item inspect and change flags and parameters which govern individual
  modules as well as their interplay;
\item pick a list of methods to be used out of about 30 different ones
  and specify their priorities, and in this way very easily compose an
  automatic solving strategy;
\item or, for more interactive work, to specify how to proceed,
  i.e.\ which computational step to do and how often, like doing
  \begin{itemize}
  \item one automatic step,
  \item one specific step,
  \item a number of automatic steps,
  \item a specific step as often as possible or a specified number of times.
  \end{itemize}
\end{itemize}
To get interactive help one enters \texttt{h} or \texttt{?}.

Flags and parameters are stored as symbolic fluid variables which
means that they can be accessed by \texttt{lisp(\ldots)},
e.g.\ \texttt{lisp( print\_:=5 );}, before calling \package{Crack}.
\texttt{print\_}, for example, is a measure of the maximal length of
expressions to be printed on the screen (the number of factors in
terms).  A complete list of flags and parameters is given at the
beginning of the file \texttt{crinit.red} (in the REDUCE
\texttt{packages/crack} directory).

One more parameter shall be mentioned, which is the list of
modules/procedures called \texttt{proc\_list\_}.  In interactive mode
this list can be looked at with \texttt{p} or changed with
\texttt{cp}.  This list defines the order in which the different
modules/procedures are tried whenever \package{Crack} has to decide
what to do next.  Exceptions to this rule may be specified.  For
example, some procedure, say $P_1$, requires after its execution
another specific procedure, say $P_2$, to be executed, no matter
whether $P_2$ is next according to \texttt{proc\_list\_} or not.  This
is managed by $P_1$ writing a task for procedure $P_2$ into a
hot-list.  Tasks listed in the global variable \texttt{to\_do\_list}
are dealt with in the \texttt{to\_do} step which should always come
first in \texttt{proc\_list\_}.  A way to have the convenience of
running \package{Crack} automatically and still being able to break
the fixed rhythm prescribed by {\tt proc\_list\_} is to have the entry
\texttt{stop\_batch} in \texttt{proc\_list\_} and have \package{Crack}
started in automatic batch mode.  Then execution continues until none
of the procedures which come before \texttt{stop\_batch} are
applicable any more so that \texttt{stop\_batch} is executed next,
which will stop automatic execution and go into interactive mode.
This allows either to continue the computation interactively, or to
change \texttt{proc\_list\_} with \texttt{cp} and continue in
automatic mode.

The default value of \texttt{proc\_list\_} does not include all
possible modules because not all are suitable for every kind of
overdetermined system to be solved.  The complete list is shown in
interactive mode by \texttt{cp}.  A few basic modules are described in
the following subsection.  The efficiency of \package{Crack} in automatic
mode is very much dependent on the content of \texttt{proc\_list\_}
and the sequence of its elements.  Optimizing \texttt{proc\_list\_}
for a given task needs experience which cannot be formalized in a few
simple rules and will therefore not be explained in more detail here.
The following remarks are only guidelines.

\subsection{Modules}

The following modules are represented by numbers in the priority list.
Each module can appear with modifications under different numbers.
For example, integration is available under
\hyperlink{crack-m_7}{\emph{7}}, \hyperlink{crack-m_24}{\emph{24}} and
\hyperlink{crack-m_25}{\emph{25}}.  Here \hyperlink{crack-m_7}{\emph{7}}
encodes an integration of short equations $0=\partial^n f/\partial
x^n$.  \hyperlink{crack-m_7}{\emph{7}} has highest priority of the
three integrations.  \hyperlink{crack-m_24}{\emph{24}} encodes the
integration of an equation that leads to the substitution of a
function and \hyperlink{crack-m_25}{\emph{25}} refers to any
integration and has lowest priority.

\subsubsection{Integration and Separation}

An early feature in the development of the package \package{Crack} was
the ability to integrate exact differential equations and some
generalizations of them (see \cite{Wolf:2000}).  As a consequence of
integrations \hyperlink{crack-m_7}{\emph{7}},
\hyperlink{crack-m_24}{\emph{24}}, \hyperlink{crack-m_25}{\emph{25}} an
increasing number of functions of fewer variables is introduced which
sooner or later produces equations with some independent variables
occuring only explicitly and not as variables in functions.  Such
equations are split by the separation module
\hyperlink{crack-m_2}{\emph{2}}.  Another possibility is equations in
which each independent variable occurs in at least one function in the
equation but no function depends on all variables.  In this case
so-called indirect separations are appropriate: for linear problems
\hyperlink{crack-m_10}{\emph{10}}, \hyperlink{crack-m_26}{\emph{26}} and
for non-linear problems \hyperlink{crack-m_48}{\emph{48}}.

\subsubsection{Substitutions}

Substitutions can have a dramatic effect on the size and complexity of
systems.  Therefore it is possible to have them not only done
automatically but also controlled tightly, either by specifying
exactly what equation should be used to substitute which unknown and
where, or by picking a substitution out of a list of substitutions
offered by the program \emph{\{cs\}}.  Substitutions to be performed
automatically can be controlled with a number of filters, for example,
by
\begin{itemize}
\item limiting the size of the equation to be used for substitution;
  \emph{\{length\_limit\}}
\item limiting the size of equations in which the substitution is to
  be done; \emph{\{target\_limit\_\}}
\item allowing only linear equations to be used for substitutions;
  \emph{\{lin\_subst\}}
\item allowing equations to increase in size only up to some factor in
  order for a substitution to be performed in that equation;
  \emph{\{cost\_limit\}}
\item allowing a substitution for a function through an expression
  only if that expression involves exclusively functions of fewer
  variables; \emph{\{less\_vars\}}
\item allowing substitutions only that do not lead to a case distinction
  coefficient = 0 or not;
\item specifying whether extra effort should be spent to identify the
  substitution with the lowest bound on growth of the full system.
  \emph{\{min\_growth\}}
\end{itemize}
Substitution types are represented by different numbers
\hyperlink{crack-m_3}{(3--6,15--21)} depending on the subset of the
above filters to be used.  If a substitution type is to be done
automatically then from all possible substitutions passing all filters
of this type that substitution is selected that leads to no sub-cases
(if available) and that uses the shortest equation.

\subsubsection{Factorization}

It is very common that big algebraic systems contain equations that
can be factorized.  Factorizing an equation and setting the factors
individually to zero simplifies the whole task because factors are
simpler expressions than the whole equation and setting them to zero
may lead to substitutions and thereby further simplifications.  The
downside is that if problems with, say 100 unknowns, would need 40
case distinctions in order to be able to solve automatically for the
remaining 60 unknowns then this would require $2^{40}$ cases to be
investigated which is impractical.  The problem is to find the right
balance between delaying case distinctions in order not to generate
too many cases and introducing case distinctions as early as necessary
in order to simplify the system.  This simplification may be necessary
to solve the system but in any case it will speed up its solution
(although at the price of having to solve a simplified system at least
twice, depending on the number of factors).

For large systems with many factorizable equations the careful
selection of the next equation to be factorized is important to gain
the most from each factorization and to succeed with as few
factorizations as possible.  Some of the criteria which give factors
and therefore equations a higher priority are
\begin{itemize}
\item the number of equations in which this factor occurs,
\item if the factor is a single unknown function or constant, then the
  number of times this unknown turns up in the whole system,
\item the total degree of the factor,
\item the number of factors of an equation.
\end{itemize}
It also matters in which order the factors are set to zero.  For
example, the equation $0=ab$ can be used to split into the 2 cases:
$1.\ a=0, \ 2.\ a\neq 0, b=0$ or to split into the 2 cases $1.\ b=0,
\ 2.\ b\neq 0, a=0$.  If one of the 2 factors, say $b$, involves
functions which occur only linearly then this property is to be
preserved and these functions should be substituted as such
substitutions preserve their linearity.  But to have many such
substitutions available, it is useful to know of many non-linearly
occuring functions to be non-zero as they occur as coefficients of the
linearly occuring functions.  In the above situation it is therefore
better to do the first splitting $1.\ a=0, \ 2.\ a\neq 0, b=0$ because
$a\neq 0$ will be more useful for substitutions of linear functions
than $b\neq 0$ would be.

An exception of this plausible rule occurs towards the end of all the
substitutions of all the linearly occurring $b_i$ when some $b_i$ is
an overall factor to many equations.  If one would then set, say,
$b_{22}=0$ as the second case in a factorization, the first case would
generate as subcases factorizations of other equations where
$b_{22}=0$ would be the second case again and so on.  To avoid this
one should investigate $b_{22}=0$ as the first case in the first
factorization.

The only purpose of that little thought experiment was to show that
simple questions, like `Which factored equation should be used first
for case-distinctions and in which order to set factors to zero?' can
already be difficult to answer in general.

\package{Crack} currently offers two factorization steps:
\hyperlink{crack-m_8}{(8)} and \hyperlink{crack-m_47}{(47)}.

\subsubsection{Elimination (Gr\"{o}bner Basis) Steps}

To increase safety and avoid excessive expression swell one can apart
from the normal call \hyperlink{crack-m_30}{(30)} request to do
Gr\"{o}bner basis computation steps only if they are simplification
steps replacing an equation by a shorter equation.
\hyperlink{crack-m_27}{(27)}

In a different version only steps are performed in which equations are
included which do not contain more than 3 unknowns.  This helps to
focus on steps which are more likely to solve small sub-systems with
readily available simple results.  \hyperlink{crack-m_57}{(57)}

Often the computationally cheapest way to obtain a consistent
(involutive) system of equations is to change the ordering during the
computation.  This is the case when substitutions of functions are
performed which are not ranked highest in a lexicographical ordering
of functions.  But \package{Crack} also offers an interactive way to
\begin{itemize}
\item change the lexicographical ordering of variables, \emph{\{ov\}}
\item change the lexicographical ordering of functions, \emph{\{of\}}
\item give the differential order of derivatives a higher or lower
  priority in the total ordering than the lexicographical ordering of
  functions, \emph{\{og\}}
\item give either the total differential order of a partial derivative
  a higher priority than the lexicographical ordering of the
  derivative of that function or to take the lexicographical ordering
  of derivatives as the only criterion.  \emph{\{of\}}
\end{itemize}

\subsubsection{Solution of an Under-Determined Differential Equation}

When solving an over-determined system of linear differential
equations where the general solution involves free functions, in the
last computational step often a single equation for more than one
function remains to be solved.  Examples are the computation of
symmetries and conservation laws of non-linear differential equations
which are linearizable.  In \package{Crack} two procedures are
available, one for under-determined linear ODEs
\hyperlink{crack-m_22}{(22)} and one for linear PDEs,
\hyperlink{crack-m_23}{(23)} both with non-constant coefficients.

\subsubsection{Indirect Separation}

Integrations introduce new functions of fewer variables.  As equations
are used to substitute functions of all variables it is only a
question of time that equations are generated in which no function
depends on all variables.  If at least one variable occurs only
explicitly then the equation can be split, which we call direct
separation.  But sometimes all variables appear as variables of
unknown functions, e.g.\ $0=f(x)+g(y)$ although usually much more
complicated with 10 or 20 independent variables and many functions
that depend on different combinations of these variables.  Because no
variable occurs only explicitly, direct separations mentioned above
are not possible.  Two different algorithms, one for linear indirectly
separable equations \hyperlink{crack-m_10}{(10)},
\hyperlink{crack-m_26}{(26)} and one for non-linear directly separable
equations \hyperlink{crack-m_48}{(48)} provide systematic ways of
dealing with such equations.

Indirectly separable equations always result when an equation is
integrated with respect to different variables, like $0=f_{xy}$ to
$f=g(x)+h(y)$ and a function, here $f(x,y)$, is substituted.

\subsubsection{Function and Variable Transformations}

In the interactive mode one can specify a transformation of the whole
problem with \texttt{pt} in which old functions and variables are
expressed as a mix of new functions and variables.

\subsubsection{Solution of First Order Linear PDE}

If a system contains a single linear first-order PDE for just one
function then in an automatic step characteristic ODE-systems are
generated, integrated if possible, a variable transformation for the
whole system of equations is performed to have in the first-order PDE
only one single derivative and to make this PDE integrable for the
integration modules.  \hyperlink{crack-m_39}{(39)}

\subsubsection{Length Reduction of Equations}

An algorithm designed originally to length-reduce differential
equations proved to be essential in length-reducing systems of
bi-linear algebraic equations or homogeneous equations which resulted
from bi-linear equations during the solution process.

The aim of the method \hyperlink{crack-m_11}{(11)} is to find out
whether one equation $0=E_1$ can length-reduce another one $0=E_2$ by
replacing $E_2$ through an appropriate linear combination $\alpha E_1
- \beta E_2,\ \ \beta \neq 0$.  To find $\alpha, \beta$ one can divide
each term of $E_2$ through each term of $E_1$ and count how often each
quotient occurs.  If a quotient $\alpha/\beta$ occurs $m$ times then
$\alpha E_1 - \beta E_2$ will have $\leq n_1+n_2-2m$ terms because
$2m$ terms will cancel each other.  A length reduction is found if
$n_1+n_2-2m\leq\max(n_1,n_2)$.  The method becomes efficient after a
few algorithmic refinements discussed in \cite{Wolf:2002}.
Length-reduced equations
\begin{itemize}
\item are more likely to length-reduce other equations,
\item are much more likely to be factorizable,
\item are more suited for substitutions as the substitution induces
  less growth of the whole systems and introduces fewer new occurrences
  of functions in equations,
\item are more likely to be integrable by being exact or being an ODE
  if the system consists of differential equations,
\item involve on average fewer unknowns and make the whole system more
  sparse.  This sparseness can be used to plan better a sequence of
  eliminations.
\end{itemize}

This concludes the listing of modules.  Other aspects of
\package{Crack} follow.

\subsection{Features}

\subsubsection{Flexible Process Control}

Different types of over-determined systems are more or less suited for
an automatic solution.  With the currrent version it is relatively
safe to try solving large bi-linear algebraic problems automatically.
Another well-suited area concerns over-determined systems of linear
PDEs.  In contrast, non-linear systems of PDEs most likely require a
tighter interactive control.  Different modes of operation are
possible.  One can
\begin{itemize}
\item perform one \emph{\{a\}} or more computational steps
  \emph{\{g\}} automatically, where each step tries modules in the
  order defined by the current priority list \emph{\{p1\}} until one
  module succeeds in its purpose;
\item perform one module a specific number of times or as long as it
  is successful; \emph{\{l\}}
\item set a time limit for how long the program should run
  automatically; \emph{\{time\_limit, limit\_time\}}
\item interrupt an on-going automatic computation and continue the
  computation interactively by copying the file \texttt{\_stop\_crack}
  into the directory where the ongoing computation was started and
  re-naming it \texttt{\_stop\_} (and by deleting \texttt{\_stop\_} to
  resume automatic computation);
\item arrange the priority list of module changes at a certain point
  in the computation when the system of equations has changed its
  character;
\item induce a case distinction whether a user-given expression is
  zero or not; \emph{\{44\}}
\item have a module that changes the priority list \emph{proc\_list\_}
  dynamically, depending essentially on the size and difficulty of the
  system but also on the success rate of previous steps. \emph{\{61,
  62, 63\}}
\end{itemize}
Apart from flexible control over what kind of steps to do, the steps
themselves can be controlled more or less too, e.g.\ whether equations
are selected by the module or the user.

So-called \emph{to-do} steps have highest priority in the priority
list.  The list of to-do steps is usually empty but can be filled by
any successful step if it requires another specific step to follow
instantly.  For example, if a very simple equation $0=f_x$ is
integrated then the substitution of $f$ should follow straight away,
even if substitutions would have a low priority according to the
current priority list.

\subsubsection{Total Data Control}

To make wise decisions of how to continue the computation in an
interactive session one needs tools to inspect large systems of
equations.  Helpful commands in \package{Crack} print
\begin{itemize}
\item equations, inequalities, functions and variables \emph{\{e, pi, f\}};
\item the occurence of all derivatives of selected functions in any
  equation; \emph{\{v\}}
\item a statistics summary of the equations of the system;
  \emph{\{s\}}
\item a matrix display of occurences of unknowns in all equations;
  \emph{\{pd\}}
\item the value of any LISP variable; \emph{\{pv\}}
\item the value of algebraic expressions that can be specified using
  equation names (e.g.\ \texttt{coeffn(e\_5,df(f,x,y),2)});
  \emph{\{pe\}}
\item not under-determined subsystems. \emph{\{ss\}}
\end{itemize}

Inspecting a computation which already goes on for hours or a day and
has performed many thousand steps is time consuming.  The task is made
easier with the possibility to plot graphically as a function of time:
the type of steps performed, the number of unknowns, the number of
remaining equations, the number of terms in these equations and the
memory usage. \emph{\{ps\}}

When non-linear systems are considered and many case distinctions and
sub-(sub-\ldots)case distinctions are made in a long computation, one
easily loses track.  With one command one can list all cases that have
been considered so far with their assumption, the number of steps made
until they are solved or until the next sub-case distinction was made
and the number of solutions contained in each completed case.
\emph{\{ls\}}

\subsubsection{Safety}

When working on large problems, a stage may come where computational
steps are necessary, like substitution, which are risky in the sense
that they may simplify the problem or complicate it by increasing its
size.  To avoid this risk a few safety features have been implemented.
\begin{itemize}
\item At any time during the computation one can save a backup of the
  complete current situation in a file and also load a backup.  The
  command \texttt{sb "file\_name"} saves all global variables and data
  into an ASCII file and the command \texttt{rb "file\_name"} reads
  these data from a file.  The format is independent of the computer
  used and independent of the underlying Lisp version.  Apart from
  reading in a backup file during an interactive computation with
  \texttt{rb} one can also start a computation with a backup file.
  After loading \package{Crack} one makes in REDUCE the call
  \texttt{crackshell()\$} followed by the file name of the backup.
\item All key strokes are automatically recorded in a list which is
  available after each interactive step with \texttt{ph}, or when the
  computation has finished through \texttt{lisp reverse history\_;}.
  This list can be fed into \package{Crack} at the beginning of a new
  computation so that the same operations are performed automatically
  that were performed interactively before.  The purpose is to be able
  to do an interactive exploration first and to repeat it afterwards
  automatically without having to note with pen or pencil all steps
  that had been done.

  By assigning this list to the Lisp variable \texttt{old\_history}
  before calling \package{Crack} with \texttt{off batch\_mode} the
  same steps as in the previous run are performed first as
  \package{Crack} first reads input from \texttt{old\_history} and
  then reads from the keyboard.
\item During an automatic computation the program might start a
  computational step which turns out to take far too long.  It would
  be better to stop this computation and try something else instead.
  But in computer algebra with lots of global variables involved it is
  not straightforward to stop a computation in the middle.  If one
  used time as a criterion then it could happen that time is up during
  a garbage collection and to stop would be deadly for the session.
  \package{Crack} allows to set a limit of garbage collections for any
  computations that have the potential to last forever, like algebraic
  factorizations of large expressions.  With such an arrangement an
  automatic computation cannot get stuck due to lengthy
  factorizations, searches for length reductions or elimination steps.
  \emph{\{max\_gc\_elimin, max\_gc\_fac, max\_gc\_red\_len,
  max\_gc\_short, max\_gc\_ss\}}
\item Due to an initiative by Winfried Neun the parallel version of
  REDUCE has been re-activated (and was running on the Beowulf cluster
  at Brock University \cite{MelNeun:2002}).  This allows conveniently
  (with \emph{\{pp\}}) to duplicate the current status of a
  \package{Crack} computation to another computer, to try out there
  different operations (e.g.\ risky ones) until a viable way to
  continue the computation is found without endangering the original
  session.
  \end{itemize}

\subsubsection{Managing Solutions}

Non-linear problems can have many solutions.  The number of solutions
found by \package{Crack} can even be higher because to make progress
\package{Crack} may have factorized an equation and considered the two
cases $a=0$ and $a \neq 0$ whereas solutions in both cases could be
merged to only one solution without any restriction for $a$.  This
merging of solutions can be accomplished with a separate program
\texttt{merge\_sol()} after the computation.

Another form of post-processing is the production of a web page for
each solution, like
\href{https://lie.math.brocku.ca/twolf/bl/v/v1l05o35-s1.html}{
  lie.math.brocku.ca/twolf/bl/v/v1l05o35-s1.html}.

If in the solution of over-determined differential equations the
program performs integrations of equations before the differential
Gr\"{o}bner basis was computed then in the final solution there may be
redundant constants or functions of integration.  Redundant constants
or functions in a solution are not an error but they make solutions
appear unnecessarily complicated.  In a postprocessing step these
functions and constants can be eliminated.  \emph{\{adjust\_fnc,
drop\_const(), dropredundant()\} }

\subsubsection{Parallelization}

The availability of a parallel version of \package{Crack} was
mentioned above allowing to try out different ways to continue an
ongoing computation.  A different possibility to make use of a cluster
of computers with \package{Crack} is to export automatically the
investigation of sub-cases and sub-sub-cases to different computers to
be solved in parallel.

It was explained above how factorizations may be necessary to make any
progress but also their potential of exploding the time requirements.
By running the computation on a cluster and being able to solve many
more cases one can give factorizations a higher priority and
capitalize on the benefit of factorizations, i.e.\ the simplification
of the problem.

\subsubsection{Relationship to Gr\"{o}bner Basis Algorithms}

For systems of equations in which the unknown constants or functions
turn up only polynomially a well-known method is able to check the
consistency of the system.  For algebraic systems this is the
Gr\"{o}bner Basis method and for systems of differential equations
this is the differential Gr\"{o}bner Basis method.  To guarantee the
method will terminate a total ordering of unknowns and their
derivatives has to be introduced.  This ordering determines which
highest powers of unknowns are to be eliminated next or which
highest-order derivatives have to be eliminated next using
integrability conditions.  Often such eliminations lead to exponential
growth of the generated equations.  In the package \package{Crack}
such computations are executed with only a low priority.  Operations
have a higher priority which reduce the length of equations,
irrespective of any orderings.  Violating any ordering a finite number
of times still guarantees a finite algorithm.  The potential gain is
large as described next.

\subsubsection{Exploiting Bi-Linearity}

In bi-linear algebraic problems we have 2 sets of variables,
$a_1,\ldots,a_m$ and $b_1,\ldots,b_n$, such that all equations have
the form $0=\sum_{k=1}^l \gamma_k a_{i_k}b_{j_k}, \ \gamma_k \in G$.
Although the problem is linear in the $a_i$ and linear in the $b_j$ it
still is a non-linear problem.  A guideline which helps keep the
structure of the system during computation relatively simple is to
preserve the linearity of either the $a_i$ or the $b_j$ as long as
possible.  In classification problems of integrable systems the ansatz
for the symmetry/first integral usually involves more terms and
therefore more constants (called $b_j$ in applications of
\package{Crack}) than the ansatz for the integrable system (with
constants $a_i$).  A good strategy therefore is to keep the system
linear in the $b_j$ during the computation, i.e.\ to
\begin{itemize}
\item substitute only a $b_j$ in terms of $a_i, b_k$, or an $a_i$ in
  terms of an $a_k$ but not an $a_i$ in terms of any $b_k$;
\item do elimination steps for any $b_j$ or for an $a_i$ if the
  involved equations do not contain any $b_k$.
\end{itemize}
The proposed measures are effective not only for algebraic problems
but for ODEs/PDEs too (i.e.\ to preserve linearity of a subset of
functions as long as possible).  \emph{\{flin\_\}}

\subsubsection{Occurrence of sin, cos or Other Special Functions}

If the equations to be solved involve special functions, like $\sin$
and $\cos$, then one is inclined to add let-rules for simplifying
expressions.  Before doing this the simplification rules at the end of
the file \texttt{crinit.red} (in the REDUCE \texttt{packages/crack}
directory) should be inspected such that new rules do not lead to
cycles with existing rules.  One possibility is to replace existing
rules, for example to substitute the existing rule
\begin{verbatim}
     trig1_ := {sin(~x)**2 => 1-cos(x)**2}$
\end{verbatim}
by the new rule
\begin{verbatim}
     trig1_ := {cos(~x)**2 => 1-sin(x)**2}$
\end{verbatim}
These rules are switched off when integrations are performed in order
not to interfere with the REDUCE integrator.

Apart from an initial customization of let-rules to be used during the
whole run one can also specify and clear let-rules during a
computation using the interactive commands \texttt{lr,cr}.

\subsubsection{Exchanging Time for Memory}

The optimal order of applying different methods to the equations of a
system is not fixed.  It does depend, for example, on the
distributions of unknown functions in the equations and on what the
individual method would produce in the next step.  For example, it is
possible that the decoupling module which applies integrability
conditions through cross differentiations of equations is going well
up to a stage when it suddenly produces huge equations.  They not only
occupy much memory, they also are slow to handle.  Right \emph{before}
this explosion started other methods should have been tried
(shortening of equations, any integrations, solution of
under-determined ODEs if there are any, \ldots).  These alternative
methods are normally comparatively slow or unfavourable as they
introduce new functions but under the current circumstances they may
be perfect to avoid any growth and to complete the calculation.  How
could one have known beforehand that some method will lead to an
explosion?  One does not know.  But one can regularly make a backup
with the interactive \texttt{sb} command and restart at this situation
if necessary.

\subsubsection{Customization}

The addition of new modules to perform new specialized computations is
easy.  Only the input and output of any new module are fixed.  The
input consists of the system of equations, the list of inequalities
and the list of unknowns to be computed.  The output includes the new
system of equations and new intermediate results.  The module name has
to be added to a list of all modules and a one line description has to
be added to a list of descriptions.  This makes it easy for users to
add special techniques for the solution of systems with extra
structure.  A dummy template module \emph{\{58\}} is already added and
has only to be filled with content.

\subsubsection{Debugging}

A feature, useful mainly for debugging is that in the middle of an
ongoing interactive computation the program can be changed by loading
a different version of \package{Crack} procedures.  Thus one could
advance quickly close to the point in the execution where an error
occurs, load a version of the faulty procedure that gives extensive
output and watch how the fault happens before fixing it.

The possibility to interrupt REDUCE itself temporarily and to inspect
the underlying LISP environment \emph{\{br\}} or to execute LISP
commands and to continue with the \package{Crack} session afterwards
\emph{\{pc\}} led to a few improvements and fixes in REDUCE itself.

\subsection{Technical issues}

\subsubsection{System Requirements}

PSL REDUCE is faster whereas CSL REDUCE seems to be more stable under
Microsoft Windows.  Also it provides portable compiled code.

Memory requirements depend crucially on the application.  The
\texttt{crack.rlg} file can be produced by running \texttt{crack.tst}
in a 4MB session running REDUCE under \textsc{Linux} (the files are in
the REDUCE \texttt{packages/crack} directory).  On the other hand it
is not difficult to formulate problems that consume any amount of
memory.

\subsubsection{Availability}

The package \package{Crack} together with \package{LiePDE},
\package{ConLaw} and \package{ApplySym} are included with REDUCE\@.
Publications related to \package{Crack} itself and to applications
based on it can be found under
\href{https://lie.math.brocku.ca/twolf/home/publications.html}{
  lie.math.brocku.ca/twolf/home/publications.html}.

\subsubsection{The files}

The following files are provided with \package{Crack} (in the REDUCE
\texttt{packages/crack} directory):
\begin{flushleft}
  \begin{tabular}{ll}
    \texttt{crack.red} & contains read-in statements for a number
    of files \texttt{cr*.red} \\
    \texttt{crack.tst} & contains test examples \\
    \texttt{crack.rlg} & contains the output of \texttt{crack.tst} \\
    \texttt{crack.tex} & the original version of this manual.
  \end{tabular}
\end{flushleft}

\subsection{Reference}
\label{crack-lb1}

\subsubsection{Elements of proc\_list\_}

The interactive command \texttt{p1} shows \emph{proc\_list\_}.  This
list defines the order in which procedures are tried if a step is to
be performed automatically.  Command \texttt{p2} shows the complete
list as it is shown below.  To select any one procedure of the
complete list interactively, one simply inputs the number shown in ().
The numbering of procedures grew historically.  Each number has only
little or no connection with the priority of the procedure it is
labelling.
\begin{description}
\item[\texttt{to\_do \hypertarget{crack-m_1}{(1)}:}] hot list of steps
  to be taken next.  Should always come first.
\item[\texttt{subst\_level\_? \hypertarget{crack-m_3}{(3-6,15-21)}:}]
  substitutions of functions by expressions.  Substitutions differ by
  their maximal allowed size and other properties.  To find out which
  function has which properties one currently has to inspect the
  procedure definitions of \texttt{subst\_level\_?} in the file
  \texttt{crmain.red}.
\item[\texttt{separation \hypertarget{crack-m_2}{(2)}:}] what is
  described as direct separation in the next subsection.
\item[\texttt{gen\_separation \hypertarget{crack-m_26}{(26)}:}] what
  is described as indirect separation in the next subsection.  Only to
  be used for linear problems.
\item[\texttt{quick\_gen\_separation \hypertarget{crack-m_10}{(10)}:}]
  generalized separation of equations with an upper size limit.
\item[\texttt{quick\_integration \hypertarget{crack-m_7}{(7)}:}]
  integration of very specific short equations.
\item[\texttt{full\_integration \hypertarget{crack-m_24}{(24)}:}]
  integration of equations which lead to a substitution.
\item[\texttt{integration \hypertarget{crack-m_25}{(25)}:}] any
  integration.
\item[\texttt{factorize\_to\_substitute
    \hypertarget{crack-m_8}{(8)}:}] splitting the computation into the
  investigation of different sub-cases resulting from the algebraic
  factorization of an equation.  Only useful for non-linear problems,
  and applied only if each one of the factors, when individually set
  to zero, would enable the substitution of a function.
\item[\texttt{factorize\_any \hypertarget{crack-m_47}{(47)}:}]
  splitting into sub-cases based on a factorization even if not all
  factors set to zero lead to substitutions.
\item[\texttt{change\_proc\_list \hypertarget{crack-m_37}{(37)}:}]
  reserved name of a procedure to be written by the user that does
  nothing else but changing \texttt{proc\_list\_} in a fixed manner.
  This is to be used if the computation splits naturally into
  different parts and if it is clear from the beginning what the
  computational methods (\texttt{proc\_list\_}) have to be.
\item[\texttt{stop\_batch \hypertarget{crack-m_38}{(38)}:}] If the
  first steps to simplify or partially solve a system of equations are
  known and should be done automatically and afterwards
  \package{Crack} should switch into interactive mode then
  \texttt{stop\_batch} is added to \texttt{proc\_list} with a priority
  just below the steps to be done automatically.
\item[\texttt{drop\_lin\_dep \hypertarget{crack-m_12}{(12)}:}] module
  to support solving big linear systems (still experimental).
\item[\texttt{find\_1\_term\_eqn \hypertarget{crack-m_13}{(13)}:}]
  module to support solving big linear systems (still experimental).
\item[\texttt{trian\_lin\_alg \hypertarget{crack-m_14}{(14)}:}] module
  to support solving big linear systems (still experimental).
\item[\texttt{undetlinode \hypertarget{crack-m_22}{(22)}:}] parametric
  solution of single under-determined linear ODE (with non-constant
  coefficients).  Only applicable for linear problems.  (Too many
  redundant functions resulting from integrations may prevent further
  integrations.  If they are involved in single ODEs then the
  parametric solution of such ODEs treated as single under-determined
  equations is useful.  Danger: new generated equations become very
  big if the minimal order of any function in the ODE is high.)
\item[\texttt{undetlinpde \hypertarget{crack-m_23}{(23)}:}] parametric
  solution of single under-determined linear PDE (with non-constant
  coefficients).  Only applicable for linear problems (still
  experimental).
\item[\texttt{alg\_length\_reduction \hypertarget{crack-m_11}{(11)}:}]
  length reduction by algebraic combination.  Only for linear
  problems.  One has to be careful when combining it with decoupling
  as infinite loops may occur when shortening and lowering order
  reverse each other.
\item[\texttt{diff\_length\_reduction
    \hypertarget{crack-m_27}{(27)}:}] length reduction by differential
  reduction.
\item[\texttt{decoupling \hypertarget{crack-m_30}{(30)}:}] steps
  towards the computation of a differential Gr\"{o}bner Basis.
\item[\texttt{add\_differentiated\_pdes
    \hypertarget{crack-m_31}{(31)}:}] only useful for non-linear
  differential equations with leading derivative occurring
  non-linearly.
\item[\texttt{add\_diff\_ise \hypertarget{crack-m_32}{(32)}:}] for the
  treatment of non-linear indirectly separable equations.
\item[\texttt{multintfac \hypertarget{crack-m_33}{(33)}:}] to find
  integrating factors for a system of equations.  Should have very low
  priority if used at all.
\item[\texttt{alg\_solve\_single \hypertarget{crack-m_34}{(34)}:}] to
  be used for equations quadratic in the leading derivative.
\item[\texttt{alg\_solve\_system \hypertarget{crack-m_35}{(35)}:}] to
  be used if a (sub-)system of equations shall be solved for a set of
  functions or their derivatives algebraically.
\item[\texttt{subst\_derivative \hypertarget{crack-m_9}{(9)}:}]
  substitution of a derivative of a function everywhere by a new
  function if such a derivative exists.
\item[\texttt{undo\_subst\_derivative
    \hypertarget{crack-m_36}{(36)}:}] undo the above substitution.
\item[\texttt{del\_redundant\_fc \hypertarget{crack-m_40}{(40)}:}]
  drop redundant functions and constants.  For that an over-determined
  PDE system is formulated and solved to set redundant constants and
  functions of integration to zero.  This may take longer if many
  functions occur.
\item[\texttt{find\_trafo \hypertarget{crack-m_39}{(39)}:}] finding a
  first-order linear PDE.  By solving it the program finds a variable
  transformation that transforms the PDE to a single derivative and
  makes the PDE integrable for the integration modules.  Because a
  variable transformation was performed the solution contains only new
  functions of integration which depend on single (new) variables and
  not on expressions of them, like sums of them.  Therefore the result
  of the integration can be used for substitutions in other equations.
  If the transformation had not been made then the solution of the PDE
  would involve arbitrary functions of expressions and could not be
  used for the other equations using the current modules of
  \package{Crack}.  A general transformation can be done interactively
  with the command \texttt{cp}.
\item[\texttt{sub\_problem \hypertarget{crack-m_41}{(41)}:}] solve a
  subset of equations first (still experimental).
\item[\texttt{del\_redundant\_de \hypertarget{crack-m_28}{(28)}:}]
  delete redundant equations.
\item[\texttt{idty\_integration \hypertarget{crack-m_29}{(29)}:}]
  integrate an identity.
\item[\texttt{gen\_separation2 \hypertarget{crack-m_48}{(48)}:}]
  indirect separation of a PDE.  This is a second version for
  non-linear PDEs.
\item[\texttt{find\_and\_use\_sub\_systems12
    \hypertarget{crack-m_49}{(49)}:}] find sub-systems of equations
  with at least as many equations as functions.  In this case find
  systems with at most 2 functions, none of them a function of the set
  \texttt{flin\_}.  (These are functions which occur initially only
  linearly in a non-linear problem; \texttt{flin\_} is assigned
  initially by the user.)
\item[\texttt{find\_and\_use\_sub\_systems13
    \hypertarget{crack-m_50}{(50)}:}] like above only with at most 3
  functions, none from \texttt{flin\_}.
\item[\texttt{find\_and\_use\_sub\_systems14
    \hypertarget{crack-m_51}{(51)}:}] like above only with at most 4
  functions, none from \texttt{flin\_}.
\item[\texttt{find\_and\_use\_sub\_systems15
    \hypertarget{crack-m_52}{(52)}:}] like above only with at most 5
  functions, none from \texttt{flin\_}.
\item[\texttt{find\_and\_use\_sub\_systems22
    \hypertarget{crack-m_53}{(53)}:}] like above only with at most 2
  functions.  Only \texttt{flin\_} are considered, all others ignored.
\item[\texttt{find\_and\_use\_sub\_systems23
    \hypertarget{crack-m_54}{(54)}:}] like above only with at most 3
  functions.  Only \texttt{flin\_} are considered, all others ignored.
\item[\texttt{find\_and\_use\_sub\_systems24
    \hypertarget{crack-m_55}{(55)}:}] like above only with at most 4
  functions.  Only \texttt{flin\_} are considered, all others ignored.
\item[\texttt{find\_and\_use\_sub\_systems25
    \hypertarget{crack-m_56}{(56)}:}] like above only with at most 5
  functions.  Only \texttt{flin\_} are considered, all others ignored.
\item[\texttt{high\_prio\_decoupling \hypertarget{crack-m_57}{(57)}:}]
  do a decoupling step with two equations that in total involve at
  most 3 different functions of all independent variables in these
  equations.
\item[\texttt{user\_defined \hypertarget{crack-m_58}{(58)}:}] This is
  an empty procedure which can be filled by the user with a very
  specific computational step that is needed in a special user
  application.  Template:
\begin{verbatim}
symbolic procedure user_defined(arglist)$
   % arglist is a Lisp list {pdes,forg,vl_} where
   %   pdes is the list of names of all equations
   %   forg is the list of original functions +
   %     their values as far as known
   %   vl_ is the list of independent variables
begin
   ...
   return if successful then list(pdes,forg)
      % new pdes + functions and their value
      else nil
end$
\end{verbatim}
\item[\texttt{alg\_groebner \hypertarget{crack-m_59}{(59)}:}] call of
  the REDUCE procedure \texttt{groebnerf} trying to solve the whole
  system under the assumption that it is a completely algebraic
  polynomial system.  All resulting solutions are considered
  individually further.
\item[\texttt{solution\_check \hypertarget{crack-m_60}{(60)}:}] this
  procedure tests whether a solution that is defined in an external
  procedure \texttt{sol\_define()} is still contained in the general
  solution of the system currently under investigation.  This
  procedure is useful to find the place in a long computation where a
  special solution is either lost or added to the general solution of
  the system to be solved.  Template:
\begin{verbatim}
algebraic procedure sol_define$
<< % This procedure contains the statements
   % that specify a solution
   % Example: Test whether s=h_-y**2/t**2, u=y/t
   % is a solution, where h_=h_(t)
   depend h_,t$
   % Return a list of expressions that vanish for
   % the solution to be tested, in this example:
   {s-(h_-y**2/t**2), u-y/t}
>>$
\end{verbatim}
\end{description}

\subsubsection{Online Help}

The following commands and their one line descriptions appear in the
same order as in the online help.

\subsubsubsection{Help for Help}

\begin{longtable}[l]{ll}
  \texttt{hd} & Help to inspect data \\
  \texttt{hp} & Help to proceed \\
  \texttt{hf} & Help to change flags and parameters \\
  \texttt{hc} & Help to change data of equations \\
  \texttt{hi} & Help to work with identities \\
  \texttt{hb} & Help to trace and debug
\end{longtable}

\subsubsubsection{Help to Inspect Data}

\begin{longtable}[l]{ll}
  \texttt{e}  & Print equations \\
  \texttt{eo} & Print overview of functions in equations \\
  \texttt{pi} & Print inequalities \\
  \texttt{f}  & Print functions and variables \\
  \texttt{v}  & Print all derivatives of all functions \\
  \texttt{s}  & Print statistics \\
  \texttt{fc} & Print no of free cells \\
  \texttt{pe} & Print an algebraic expression \\
  \texttt{ph} & Print history of interactive input \\
  \texttt{pv} & Print value of any Lisp variable \\
  \texttt{pf} & Print no of occurences of each function \\
  \texttt{pr} & Print active substitution rules \\
  \texttt{pd} & Plot the occurence of functions in equations \\
  \texttt{ps} & Plot a statistical history \\
  \texttt{lc} & List all case distinctions \\
  \texttt{ws} & Write statistical history in file \\
  \texttt{sn} & Show name of session \\
  \texttt{ss} & Find and print sub-systems \\
  \texttt{w}  & Write equations into a file
\end{longtable}

\subsubsubsection{Help to Proceed}

\begin{longtable}[l]{ll}
  \texttt{a}  & Do one step automatically \\
  \texttt{g}  & Go on for a number of steps automatically \\
  \texttt{t}  & Toggle between automatic and user selection of equations \\
  & (\texttt{expert\_mode=nil/t}) \\
  \texttt{p1} & Print a list of all modules in batch mode \\
  \texttt{p2} & Print a complete list of all modules \\
  \texttt{\#} & Execute the module with the number `\#' once \\
  \texttt{l}  & Execute a specific module repeatedly \\
  \texttt{sb} & Save complete backup to file \\
  \texttt{rb} & Read backup from file \\
  \texttt{ep} & Enable parallelism \\
  \texttt{dp} & Disable parallelism \\
  \texttt{pp} & Start an identical parallel process \\
  \texttt{kp} & Kill a parallel process \\
  \texttt{x}  & Exit interactive mode for good \\
  \texttt{q}  & Quit current level or crack if in level 0
\end{longtable}

\subsubsubsection{Help to Change Flags and Parameters}

\begin{longtable}[l]{ll}
  \texttt{pl} & Maximal length of an expression to be printed \\
  \texttt{pm} & Toggle to print more or less information about PDEs (\texttt{print\_more}) \\
  \texttt{pa} & Toggle to print all or not all information about the PDEs (\texttt{print\_all}) \\
  \texttt{cp} & Change the priorities of procedures \\
  \texttt{og} & Toggle ordering between `lexicographical ordering of functions having \\
  & a higher priority than any ordering of derivatives' and the opposite \\
  & (\texttt{lex\_fc=t}) resp.\ (\texttt{lex\_fc=nil}) \\
  \texttt{od} & Toggle ordering between `the total order of derivatives having a higher \\
  & priority than lexicographical ordering' (\texttt{lex\_df=nil}) or not (\texttt{lex\_df=t}) \\
  \texttt{oi} & Interactive change of ordering on variables \\
  \texttt{or} & Reverse ordering on variables \\
  \texttt{om} & Mix randomly ordering on variables \\
  \texttt{of} & Interactive change of ordering on functions \\
  \texttt{op} & Print current ordering \\
  \texttt{ne} & Root of the name of new generated equations (default: \texttt{e\_}) \\
  \texttt{nf} & Root of the name of new functions and constants (default: \texttt{c\_}) \\
  \texttt{ni} & Root of the name of new identities (default: \texttt{id\_}) \\
  \texttt{na} & Toggle for the \texttt{nat} output switch (\texttt{!*nat}) \\
  \texttt{as} & Input of an assignment \\
  \texttt{kp} & Toggle for keeping a partitioned copy of each equation (\texttt{keep\_parti}) \\
  \texttt{fi} & Toggle for allowing or not allowing integrations of equations which \\
  & involve unresolved integrals (\texttt{freeint\_}) \\
  \texttt{fa} & Toggle for allowing or not allowing solutions of ODEs involving the \\
  & \texttt{abs} function (\texttt{freeabs\_}) \\
  \texttt{cs} & Switch on/off the confirmation of intended substitutions and of the \\
  & order of the investigation of subcases resulting in a factorization \\
  \texttt{fs} & Enforce direct separation \\
  \texttt{ll} & change of the line length \\
  \texttt{re} & Toggle for allowing to re-cycle equation names (\texttt{do\_recycle\_eqn}) \\
  \texttt{rf} & Toggle for allowing to re-cycle function names (\texttt{do\_recycle\_fnc}) \\
  \texttt{st} & Setting a CPU time limit for un-interrupted run \\
  \texttt{cm} & Adding a comment to the \texttt{history\_} list \\
  \texttt{lr} & Adding a LET-rule \\
  \texttt{cr} & Clearing a LET-rule
\end{longtable}

\subsubsubsection{Help to Change Data of Equations}

\begin{longtable}[l]{ll}
  \texttt{r}  & Replace or add one equation \\
  \texttt{rd} & Reduce an equation modulo LET rules \\
  \texttt{n}  & Replace one inequality \\
  \texttt{de} & Delete one equation \\
  \texttt{di} & Delete one inequality \\
  \texttt{c}  & Change a flag or property of one PDE \\
  \texttt{pt} & Perform a transformation of functions and variables
\end{longtable}

\subsubsubsection{Help to Work with Identities}

\begin{longtable}[l]{ll}
  \texttt{i}  & Print identities between equations \\
  \texttt{id} & Delete redundand equations \\
  \texttt{iw} & Write identities to a file \\
  \texttt{ir} & Remove list of identities \\
  \texttt{ia} & Add or replace an identity \\
  \texttt{ih} & Start recording histories and identities \\
  \texttt{ip} & Stop recording histories and identities \\
  \texttt{ii} & Integrate an identity \\
  \texttt{ic} & Check the consistency of identity data \\
  \texttt{iy} & Print the history of equations
\end{longtable}

\subsubsubsection{Help to Trace and Debug}

\begin{longtable}[l]{ll}
  \texttt{tm} & Toggle for tracing the main procedure (\texttt{tr\_main}) \\
  \texttt{tg} & Toggle for tracing the generalized separation (\texttt{tr\_gensep}) \\
  \texttt{ti} & Toggle for tracing the generalized integration (\texttt{tr\_genint})  \\
  \texttt{td} & Toggle for tracing the decoupling process (\texttt{tr\_decouple}) \\
  \texttt{tl} & Toggle for tracing the decoupling length reduction process \\
  & (\texttt{tr\_redlength}) \\
  \texttt{ts} & Toggle for tracing the algebraic length reduction process (\texttt{tr\_short}) \\
  \texttt{to} & Toggle for tracing the ordering procedures process (\texttt{tr\_orderings}) \\
  \texttt{tr} & Trace an arbitrary procedure \\
  \texttt{ut} & Untrace a procedure \\
  \texttt{br} & Lisp break \\
  \texttt{pc} & Do a function call \\
  \texttt{in} & Reading in a REDUCE file
\end{longtable}

\subsubsection{Global variables}

The following is a complete list of identifiers used as global Lisp
variables (to be precise, symbolic fluid variables) within
\package{Crack}.  Some are flags and parameters, others are global
variables; some of them can be accessed after the \package{Crack} run.
\begin{flushleft}\tt
  !*allowdfint\_bak\quad !*dfprint\_bak\quad !*exp\_bak\quad !*ezgcd\_bak\quad !*fullroots\_bak\quad
  !*gcd\_bak\quad !*mcd\_bak\quad !*nopowers\_bak\quad !*ratarg\_bak\quad !*rational\_bak\quad
  !*batch\_mode\quad abs\_\quad adjust\_fnc\quad allflags\_\quad batchcount\_\quad !*backup\_\quad collect\_sol\quad
  confirm\_subst\quad cont\_\quad contradiction\_\quad cost\_limit5\quad current\_dir\quad
  default\_proc\_list\_\quad do\_recycle\_eqn\quad do\_recycle\_fnc\quad done\_trafo\quad
  eqname\_\quad expert\_mode\quad explog\_\quad facint\_\quad flin\_\quad force\_sep\quad fname\_\quad fnew\_\quad
  freeabs\_\quad freeint\_\quad ftem\_\quad full\_proc\_list\_\quad gcfree!*\quad genint\_\quad glob\_var\quad
  global\_list\_integer\quad global\_list\_ninteger\quad global\_list\_number\quad high\_gensep\quad
  homogen\_\quad history\_\quad idname\_\quad idnties\_\quad independence\_\quad ineq\_\quad inter\_divint\quad
  keep\_parti\quad last\_steps\quad length\_inc\quad level\_\quad lex\_df\quad lex\_fc\quad limit\_time\quad
  lin\_problem\quad lin\_test\_const\quad logoprint\_\quad low\_gensep\quad max\_gc\_counter\quad
  max\_gc\_elimin\quad max\_gc\_fac\quad max\_gc\_red\_len\quad max\_gc\_short\quad max\_gc\_ss\quad
  max\_red\_len\quad maxalgsys\_\quad mem\_eff\quad my\_gc\_counter\quad nequ\_\quad new\_gensep\quad nfct\_\quad
  nid\_\quad odesolve\_\quad old\_history\quad orderings\_\quad target\_limit\_0\quad target\_limit\_1\quad
  target\_limit\_2\quad target\_limit\_3\quad target\_limit\_4\quad poly\_only\quad potint\_\quad print\_\quad
  print\_all\quad print\_more\quad proc\_list\_\quad prop\_list\quad pvm\_able\quad quick\_decoup\quad
  record\_hist\quad recycle\_eqns\quad recycle\_fcts\quad recycle\_ids\quad reducefunctions\_\quad
  repeat\_mode\quad safeint\_\quad session\_\quad simple\_orderings\quad size\_hist\quad size\_watch\quad
  sol\_list\quad solvealg\_\quad stepcounter\_\quad stop\_\quad struc\_dim\quad struc\_eqn\quad subst\_0\quad
  subst\_1\quad subst\_2\quad subst\_3\quad subst\_4\quad time\_\quad time\_limit\quad to\_do\_list\quad tr\_decouple\quad
  tr\_genint\quad tr\_gensep\quad tr\_main\quad tr\_orderings\quad tr\_redlength\quad tr\_short\quad trig1\_\quad
  trig2\_\quad trig3\_\quad trig4\_\quad trig5\_\quad trig6\_\quad trig7\_\quad trig8\_\quad userrules\_\quad vl\_
\end{flushleft}

\subsubsection{Global Flags and Parameters}

The list below gives a selection of flags and global parameters that
are available, for example, to fine tune the performance according to
specific needs of the system of equations that is studied.  Usually
they are not needed and very few are used regularly by the author.
The interactive command that changes the flag/parameter is given in [
], default values of the flags/parameters are given in ().  All values
can be changed interactively with the \texttt{as} command.  The values
of the flags and parameters can either be set after loading
\package{Crack} and before starting it with a Lisp assignment, for
example,
\begin{verbatim}
     lisp(print_ := 8)$
\end{verbatim}
or after starting \package{Crack} in interactive mode with specific
commands, like \texttt{pl} to change specifically the print length
determining parameter \texttt{print\_}, or the command \texttt{as} to
do an assignment.  The values of parameters/flags can be inspected
interactively using \texttt{pv} and changed with \texttt{as}.

\begin{description}\sloppy
\item[\texttt{!*batch\_mode [x] (t) :}] running \package{Crack} in
  interactive mode (\texttt{!*batch\_mode=nil}) or automatically
  (\texttt{!*batch\_mode=t}).  It can also be set in algebraic mode
  before starting \package{Crack} by \texttt{on/off batch\_mode}.
  Interactive mode can be left and automatic computation be started by
  the interactive command \texttt{x}.
\item[\texttt{!*iconic (nil) :}] whether new processes in
  parallelization should appear as icons (\texttt{t}) or windows
  (\texttt{nil}).
\item[\texttt{adjust\_fnc (nil) :}] if \texttt{t} then free
  constants/functions are scaled and redundant ones are dropped to
  simplify the result after the computation has been completed.
\item[\texttt{collect\_sol (t) :}] whether solutions found shall be
  collected and returned together at the end or not (to save memory);
  it matters only for non-linear problems with very many special
  solutions.  If a computation has to be performed with any solution
  that is found, then these commands can be put into an
  \texttt{algebraic procedure crack\_out(eqns, assigns, freef, ineq)}
  which is currently empty in file \texttt{crmain.red} but which is
  called for each solution.
\item[\texttt{confirm\_subst [cs] (nil) :}] whether substitutions have
  to be confirmed interactively.
\item[\texttt{cont\_ (nil) :}] interactive user control for
  integration or substitution of large expressions (enabled =
  \texttt{t}).
\item[\texttt{cost\_limit5 (100) :}] maximal number of extra terms
  generated by a substitution.
\item[\texttt{do\_recycle (nil) :}] whether function names shall be
  recycled or not (saves memory but computation is less clear to
  follow).
\item[\texttt{done\_trafo (nil) :}] an (algebraic mode) list of
  back-transformations that would invert done transformations; this
  list is useful after \package{Crack} completed to invert
  transformations if needed.
\item[\texttt{eqname\_ [ne] ('e\_) :}] name of new equations.
\item[\texttt{expert\_mode [t] (nil) :}] For \texttt{expert\_mode=t}
  the equations that are involved in the next computational step are
  selected by \package{Crack}, for \texttt{expert\_mode=nil} the user
  is asked to select one or two equations which are to be worked with
  in the next computational step.
\item[\texttt{facint\_ (1000) :}] if \texttt{nil} then no search for
  integrating factors, otherwise sets the maximum of product
  \emph{terms * kernels} when searching for an integrating factor.
\item[\texttt{flin\_ (nil) :}] a list of functions occuring only
  linearly in an otherwise non-linear problem; must be assigned before
  calling \package{Crack}.  During execution \package{Crack} tries to
  preserve the linearity of these functions as long as possible.
\item[\texttt{fname\_ [nf] ('c\_) :}] name of new functions and
  constants (integration).
\item[\texttt{force\_sep (nil) :}] whether direct separation should be
  forced even if functions occur in the supposedly linear independent
  explicit expressions (for non-linear problem).
\item[\texttt{freeabs\_ [fi] (t) :}] Do not use solutions of ODEs that
  involve the \texttt{abs} function.
\item[\texttt{freeint\_ [fi] (t) :}] Do integrations only if explicit
  part is integrable.
\item[\texttt{genint\_ (15) :}] if \texttt{nil} then generalized
  integration disabled else sets the maximal number of new functions
  and extra equations due to the generalized integration of one
  equation.
\item[\texttt{high\_gensep (300) :}] minimum size of expressions to
  separate in a generalized way by \texttt{quick\_gen\_separation}.
\item[\texttt{homogen\_ (nil) :}] test for homogeneity of each
  equation (for debugging).
\item[\texttt{idname\_ [ni] ('id\_) :}] name of new equations.
\item[\texttt{idnties\_ (nil) :}] list of identities resulting from
  reductions and integrability conditions.
\item[\texttt{independence\_ (nil) :}] interactive control of linear
  independence (enabled = \texttt{t}).
\item[\texttt{inter\_divint (nil) :}] whether the integration of
  divergence identities with more than 2 differentiation variables
  shall be confirmed interactively.
\item[\texttt{keep\_parti [kp] (nil) :}] whether for each equation a
  copy in partitioned form is to be stored to speed up several
  simplifications but which needs more memory.
\item[\texttt{last\_steps (nil) :}] a list of the last steps generated
  and updated automatically in order to avoid cycles.
\item[\texttt{length\_inc (1.0) :}] factor by which the length of an
  expression may grow when performing \texttt{diff\_length\_reduction}.
\item[\texttt{lex\_df [od] (nil) :}] if \texttt{t} then use
  lexicographical instead of total degree ordering of derivatives.
\item[\texttt{lex\_fc [og] (t) :}] if \texttt{t} then lexicographical
  ordering of functions has higher priority than any ordering of
  derivatives.
\item[\texttt{limit\_time (nil) :}] = time() + how many more seconds
  allowed in batch mode.
\item[\texttt{logoprint\_ (t) :}] print logo after \package{Crack}
  call.
\item[\texttt{low\_gensep (6) :}] maximum size of expressions to be
  separated in a generalized way by \texttt{quick\_gen\_separation}.
\item[\texttt{max\_gc\_counter (100000000) :}] maximal total number of
  garbage collections.
\item[\texttt{max\_gc\_elimin (15) :}] maximal number of garbage
  collections during elimination in decoupling.
\item[\texttt{max\_gc\_fac (15) :}] maximal number of garbage
  collections during factorization.
\item[\texttt{max\_gc\_red\_len (30) :}] maximal number of garbage
  collections during length reduction.
\item[\texttt{max\_gc\_short (40) :}] maximal number of garbage
  collections during shortening.
\item[\texttt{max\_gc\_ss (10) :}] maximal number of garbage
  collections during search of sub-systems.
\item[\texttt{max\_red\_len (1000000) :}] maximal product of lengths
  of two equations to be combined with length-reducing decoupling.
\item[\texttt{maxalgsys\_ (20) :}] maximum number of equations to be
  solved in specialsol.
\item[\texttt{mem\_eff (t) :}] whether to be memory efficient even if
  slower.
\item[\texttt{my\_gc\_counter (0) :}] initial value of
  \texttt{my\_gc\_counter}.
\item[\texttt{nequ\_ (1) :}] index of the next new equation.
\item[\texttt{new\_gensep (nil) :}] whether or not a newer
  (experimental) form of \texttt{gensep} should be used.
\item[\texttt{nfct\_ (1) :}] index of the next new function or
  constant.
\item[\texttt{nid\_ (1) :}] index of the next new identity.
\item[\texttt{odesolve\_ (100) :}] maximal length of a DE (number of
  terms) to be integrated as ODE.
\item[\texttt{old\_history (nil) :}] \texttt{old\_history} is
  interactive input to be read from this list.
\item[\texttt{poly\_only (nil) :}] all equations are polynomials only.
\item[\texttt{potint\_ (t) :}] allowing `potential integration'.
\item[\texttt{print\_ [pl] (12) :}] maximal length of an expression to
  be printed.
\item[\texttt{print\_all [pa] (nil) :}] print all information about
  the PDEs.
\item[\texttt{print\_more [pm] (t) :}] print more informations about
  the PDEs.
\item[\texttt{quick\_decoup (nil) :}] whether decoupling should be
  done faster with less care for saving memory.
\item[\texttt{record\_hist (nil) :}] whether the history of equations
  is to be recorded.
\item[\texttt{safeint\_ (t) :}] use only solutions of ODEs with
  non-vanishing denominator.
\item[\texttt{session\_ (``bu''+random number+date) :}] when loading
  \package{Crack} or executing.
\item[\texttt{size\_watch (nil) :}] whether before each computational
  step the size of the system shall be recorded in the global variable
  \texttt{size\_hist}.
\item[\texttt{solvealg\_ (nil) :}] Use \package{SOLVE} for algebraic
  equations.
\item[\texttt{struc\_eqn (nil) :}] whether the equations have the form
  of structural equations (an application is Killing vector and
  Killing tensor computations).
\item[\texttt{subst\_* :}] maximal length of an expression to be
  substituted, used with different values for different procedures
  \texttt{subst\_level\_*}.
\item[\texttt{target\_limit\_* (nil) :}] maximum of product
  \emph{length(PDE) * length(substituted expression)} for a PDE which
  is to be used for a substitution.  If \texttt{target\_limit\_* =
    nil} then no length limit, used with different values for
  different procedures \texttt{subst\_level\_*}.
\item[\texttt{time\_ (nil) :}] print the time needed for running
  \package{Crack}.
\item[\texttt{time\_limit (nil) :}] whether a time limit is active
  after which batch-mode is interrupted to interactive mode.
\item[\texttt{tr\_decouple [td] (nil) :}] trace decoupling process.
\item[\texttt{tr\_genint [ti] (nil) :}] trace generalized integration.
\item[\texttt{tr\_gensep [ts] (nil) :}] trace generalized separation.
\item[\texttt{tr\_main [tm] (nil) :}] trace main procedure.
\item[\texttt{tr\_orderings [to] (nil) :}] trace orderings stuff.
\item[\texttt{tr\_redlength [tr] (nil) :}] trace length reduction.
\end{description}

\subsection{A More Detailed Description of Some of the Modules}

The package \package{Crack} contains a number of modules.  The basic
ones are for computing a pseudo-differential Gr\"{o}bner Basis (using
integrability conditions in a systematic way), integrating exact PDEs,
separating PDEs, solving DEs containing functions of only a subset of
all variables and solving standard ODEs (of Bernoulli or Euler type,
linear, homogeneous and separable ODEs).  These facilities will be
described briefly together with examples.  The test file
\texttt{crack.tst} (in the REDUCE \texttt{packages/crack} directory)
demonstrates these and others.

\subsubsection{Pseudo Differential Gr\"{o}bner Basis}

This module (called `decoupling' in \texttt{proc\_list\_}) reduces
derivatives in equations by using other equations and it applies
integrability conditions to formulate additional equations which are
subsequently reduced, and so on.

A general algorithm to bring a system of PDEs into a standard form
where all integrability conditions are satisfied by applying a finite
number of additions, multiplications and differentiations is based on
the general theory of involutive systems \cite{Riquier:1910,
  Thomas:1937, Janet:1929}.

Essential to this theory is a total ordering of partial derivatives
which allows assignment to each PDE of a \emph{Leading Derivative}
(LD) according to a chosen ordering of functions and derivatives.
Examples for possible orderings are
\begin{itemize}
\item lex.\ order of functions $>$ lex.\ order of variables,
\item lex.\ order of functions $>$ total differential order $>$
  lex.\ order of variables,
\item total order $>$ lex.\ order of functions $>$ lex.\ order of
  variables,
\end{itemize}
or mixtures of them by giving weights to individual functions and
variables.  Above, the ``$>$'' indicate ``before'' in priority of
criteria.  The principle is then to
\begin{enumerate}
\item take two equations at a time and differentiate them as
  often as necessary to get equal LDs,
\item regard these two equations as algebraic equations in the
  common LD and calculate the remainder w.r.t.\ the LD, i.e.\ to
  generate an equation without the LD by the Euclidean algorithm, and
\item add this equation to the system.
\end{enumerate}
Usually pairs of equations are taken first, such that only one of the
equations must be differentiated.  If in such a generation step one of
the equations is not differentiated then it is called a simplification
step and this equation will be replaced by the new equation.

The algorithm ends when each combination of two equations yields only
equations which simplify to an identity modulo the other equations.  A
more detailed description is given e.g.\ in \cite{Bocharov:89,
  Reid:90}.

Other programs implementing this algorithm are described e.g.\ in
\cite{Schwarz:1985, Bocharov:89, Fushchich:89, Reid:90,
  Reid_Wittkopf_Boulton:1996, Reid_Lin_Wittkopf:2001} and
\cite{Mansfield:1996}.

In the interactive mode of \package{Crack} it is possible to change
the lexicographical ordering of variables, of functions, to choose
between `total differential order' ordering of variables or
lexicographical ordering of variables and to choose whether
lexicographical ordering of functions should have a higher priority
than the ordering of the variables in a derivative, or not.

An example of the computation of a differential Gr\"{o}bner Basis is
given in the test file \texttt{crack.tst}.

\subsubsection{Integrating Exact PDEs}

The technical term `exact' is adapted for PDEs from exterior calculus
and is a small abuse of language but it is useful to characterize the
kind of PDEs under consideration.

The purpose of the integration module in \package{Crack} is to decide
whether a given differential expression $D$ which involves unknown
functions $f^i(x^j),\; 1\leq i\leq m$ of independent variables $x^j,\;
1\leq j\leq n$ is a total derivative of another expression $I$
w.r.t.\ some variable $x^k,\; 1\leq k\leq n$

\[ D(x^i,\; f^j,\; f^j,_p,\; f^j,_{pq}, \ldots)
     = \frac{d I(x^i,\; f^j,\; f^j,_p,\; f^j,_{pq}, \ldots)}{d x^k}. \]

The index $k$ is reserved in the following for the integration
variable $x^k$.  With an appropriate function of integration $c^r$,
which depends on all variables except $x^k$, it is no loss of
generality to replace $0 = D$ by $0 = I + c^r$ in a system of
equations.

Of course there always exists a function $I$ with a total derivative
equal to $D$ but the question is whether for \emph{arbitrary} $f^i$
the integral $I$ is functionally dependent only on the $f^i$ and their
derivatives, and \emph{not on integrals} of $f^i$.

\paragraph*{Preconditions:}

$D$ is a polynomial in the $f^i$ and their derivatives.  The number of
functions and variables is free.  For deciding the existence of $I$
only, the explicit occurrence of the variables $x^i$ is arbitrary.  In
order to actually calculate $I$ explicitly, $D$ must have the property
that all terms in $D$ must either contain an unknown function of $x^k$
or must be formally integrable w.r.t.\ $x^k.$ That means if $I$ exists
then only a special explicit occurrence of $x^k$ can prevent the
calculation of $I$ and furthermore only in those terms which do not
contain any unknown function of $x^k$.  If such terms occur in $D$ and
$I$ exists then $I$ can still be expressed as a polynomial in the
$f^i, f^i,_j, \ldots$ and terms containing indefinite integrals with
integrands explicit in $x^k$.

\paragraph*{Algorithm:}

Successive partial integration of the term with the highest
$x^k$-derivative of any $f^i$.  By that the differential order
w.r.t.\ $x^k$ is reduced successively.  This procedure is always
applicable because steps involve only differentiations and the
polynomial integration ($\int h^n\frac{\partial h}{\partial x}dx =
h^{n+1}/(n+1)$) where $h$ is a partial derivative of some function
$f^i$.  For a more detailed description see \cite{Wolf:2000}.

\paragraph*{Stop:}

Iteration stops if no term with any $x^k$-derivative of any $f^i$ is
left.  If any $f^i(x^k)$ occurs in the remaining un-integrated terms
then $I$ is not expressible with $f^i$ and its derivatives only.  In
case no $f^i(x^k)$ occurs, any remaining terms can contain $x^k$ only
explicitly.  Whether they can be integrated or not depends on their
formal integrability.  For their integration the REDUCE integrator is
applied.

\paragraph*{Speed up:}

The partial integration as described above preserves derivatives with
respect to other variables.  For example, the three terms $f,_x, f
f,_{xxx}, f,_{xxy}$ cannot combine somehow to the same terms in the
integral because if one ignores $x$-derivatives then it is clear that
$f, f^2$ and $f,_y$ are three functionally independent expressions
with respect to $x$-integrations.  This allows the following drastic
speed up for large expressions.  It is possible to partition the
complete sum of terms into partial sums such that each of them has to
be integrable on its own.  That is managed by generating a label for
each term and collecting terms with the same label into partial sums.
The label is produced by dropping all $x$-derivatives from all
functions to be computed and dropping all factors which are not powers
of derivatives of functions to be computed.

The partitioning into partial sums has two effects.  Firstly, if the
integration of one partial sum fails then the remaining sums do not
have to be tried for integration.  Secondly, doing partial integration
for each term means doing many subtractions.  It is much faster to
subtract terms from small sums than from large sums.

\paragraph*{Example:}

We apply the above algorithm to
\begin{equation*}
  D := 2f,_yg' + 2f,_{xy}g + gg'^3 + xg'^4 + 3xgg'^2g'' = 0
\end{equation*}
with $f = f(x,y), \; g = g(x), \; '\equiv d/dx$.  Starting with terms
containing $g$ and at first with the highest derivative $g,_{xx},$ the
steps are
\[ \begin{array}{rcccl}
  \int 3xgg,_x^2g,_{xx} dx
  & = & \int d(xgg,_x^3)
  & - & \int \left( \partial_x(xg) g,_x^3\right) dx \\ \\
  & = & xgg,_x^3 & - & \int g,_x^3(g + xg,_x) dx,
\end{array} \]
\[ I := I + xgg,_x^3 \]
\[ D := D - g,_x^3(g + xg,_x) - 3xgg,_x^2g,_{xx} \]
The new terms $- g,_x^3(g + xg,_x)$ are of lower order than $g,_{xx}$
and so in the expression $D$ the maximal order of $x$-derivatives of
$g$ is lowered.  The conditions that $D$ is exact are the following.
\begin{itemize}
\item The leading derivative must occur linearly before each partial
  integration step.
\item After the partial integration of the terms with first-order
  $x$-derivatives of $f$ the remaining $D$ must not contain $f$ or
  other derivatives of $f$, because such terms cannot be integrated
  w.r.t.\ $x$ without specifying $f$.
\end{itemize}
The result of $x$- and $y$-integration in the above example is
(remember $g=g(x)$)
\[ 0 = 2fg + xygg,_x^3 + c_1(x) + c_2(y) \; \; (=I). \]
\package{Crack} can now eliminate $f$ and substitute
for it in all other equations.

\paragraph*{Generalization:}

If after applying the above basic algorithm, terms are left which
contain functions of $x^k$ but each of these functions depends only on
a subset of all $x^i, \; 1\leq i\leq n$, then a generalized version of
the above algorithm can still provide a formal expression for the
integral $I$ (see \cite{Wolf:2000}).  The price consists of additional
differential conditions, but they are equations in fewer variables
than occur in the integrated equation.  Integrating for example
\begin{equation}
\tilde{D} = D + g^2(y^2 + x\sin y + x^2e^y) \label{crack-Dnew}
\end{equation}
by introducing as few new functions and additional conditions as
possible gives for the integral $\tilde{I}$
\begin{eqnarray*}
\tilde{I} & = & 2fg + xygg,_{x}^{3} + c_1(x) + c_2(y) \\
          &   & + \frac{1}{3}y^3c_3'' - \cos y(xc_3'' - c_3)
+ e^y(x^2c_3'' - 2xc_3' + 2c_3)
\end{eqnarray*}
with $c_3 = c_3(x), \; '\equiv d/dx$ and the single additional
condition $g^2 = c_3'''$.  The integration of the new terms of
\eqref{crack-Dnew} is achieved by partial integration again, for
example
\begin{eqnarray*}
\int g^2x^2 dx & = & x^2\int g^2 dx - \int (2x\!\int g^2 dx) dx \\
              & = & x^2\int g^2 dx - 2x\int\!\!\int g^2 dx
                    + 2 \int\!\!\int\!\!\int g^2 dx \\
              & = & x^2c_3'' - 2xc_3' + 2c_3.
\end{eqnarray*}

\paragraph*{Characterization:}

This algorithm is a decision algorithm which does not involve any
heuristic.  After integration, the new equation is still a polynomial
in $f^i$ and in the new constant or function of integration.
Therefore the algorithms for bringing the system into standard form
can still be applied to the PDE-system after the equation $D = 0$ is
replaced by $I = 0$.

The complexity of algorithms for bringing a PDE-system into a standard
form depends nonlinearly on the order of these equations because of
the nonlinearly increasing number of different leading derivatives and
by that the number of equations generated intermediately by such an
algorithm.  It therefore in general pays off to integrate equations
during such a standard form algorithm.

If an $f^i$, which depends on all variables, can be eliminated after
an integration, then depending on its length it is in general helpful
to substitute $f^i$ in other equations and to reduce the number of
equations and functions by one.  This is especially profitable if the
replaced expression is short and contains only functions of fewer
variables than $f^i$.

\paragraph*{Test:}

The corresponding test input is
\begin{verbatim}
depend f,x,y;
depend g,x;
crack({2*df(f,y)*df(g,x)+2*df(f,x,y)*g+g*df(g,x)**3
       +x*df(g,x)**4+3*x*g*df(g,x)**2*df(g,x,2)
       +g**2*(y**2+x*sin y+x**2*e**y)},
      {}, {f,g}, {});
\end{verbatim}
The meaning of the REDUCE command \texttt{depend} is to declare that
$f$ depends in an unknown way on $x$ and $y$.  For more details on the
algorithm see \cite{Wolf:2000}.

\subsubsection{Direct Separation of PDEs}

As a result of repeated integrations the functions in the remaining
equations have fewer and fewer variables.  It therefore may happen
that after a substitution an equation results where at least one
variable occurs only explicitly and not as an argument of an unknown
function.  Consequently all coefficients of linearly independent
expressions in this variable can be set to zero individually.

\paragraph*{Example:}

$f = f(x,y), \;\; g = g(x), \;\; x,y,z$ are independent variables.
The equation is
\begin{equation}
0 = f,_y + z(f^2+g,_x) + z^2(g,_x+yg^2) \label{crack-sep}
\end{equation}
$x$-separation? $\rightarrow$ no \\
$y$-separation? $\rightarrow$ no \\
$z$-separation? $\rightarrow$ yes: $0 \,=\, f,_y \,=\, f^2+g,_x \,=\,
g,_x+yg^2$ \\
$y$-separation? $\rightarrow$ yes: $0 = g,_x = g^2$
(from the third equation from the $z$-separation)

If $z^2$ had been replaced in \eqref{crack-sep} by a third function
$h(z)$ then direct separation would not have been possible.  The
situation changes if $h$ is a parametric function which is assumed to
be independently given and which should not be calculated, i.e.\ $f$
and $g$ should be calculated for any arbitrary given $h(z)$.  Then the
same separation could have been done with an extra treatment of the
special case $h,_{zz} = 0$, i.e.\ $h$ linear in $z$.  This different
treatment of unknown functions makes it necessary to input explicitly
the functions to be calculated as the third argument to
\package{Crack}.  The input in this case would be
\begin{verbatim}
depend f,x,y;
depend g,x;
depend h,z;
crack({df(f,y)+z*f**2+(z+h)*df(g,x)+h*y*g**2}, {},
      {f,g}, {z});
\end{verbatim}
The fourth parameter for \package{Crack} is necessary to make clear
that in addition to the variables of $f$ and $g$, $z$ is also an
independent variable.

If the flag \texttt{independence\_} is not \texttt{nil} then
\package{Crack} will stop if linear independence of the explicit
expressions of the separation variable (in the example $1,z,z^2$) is
not clear and ask interactively whether separation should be done or
not.

\subsubsection{Indirect Separation of PDEs}

For the above direct separation a precondition is that at least one
variable occurs only explicitly or as an argument of parametric
functions.  The situation where each variable is an argument of at least
one function but no function contains all independent variables of an
equation needs a more elaborate treatment.

The steps are these
\begin{itemize}
\item A variable $x_a$ is chosen which occurs in as few functions as
  possible.  This variable will be separated directly later which
  requires that all unknown functions $f_i$ containing $x_a$ are to be
  eliminated.  Therefore, as long as $F:=\{f_i\}$ is not empty do the
  following:
  \begin{itemize}
  \item Choose the function $f_i(y_p)$ in $F$ with the smallest number
    of variables $y_p$ and with $z_{ij}$ as those variables on which
    $f_i$ does not depend.
  \item Identify all different products $P_{ik}$ of powers of
    $f_i$-derivatives and of $f_i$ in the equation.  Determine the
    $z_{ij}$-dependent factors $C_{ik}$ of the coefficients of
    $P_{ik}$ and store them in a list.
  \item For each $C_{il}$ ($i$ fixed, $l=1,\ldots$) choose a $z_{ij}$
    and:
    \begin{itemize}
    \item divide by $C_{il}$ the equation and all following elements
      $C_{im}$ with $m>l$ of this list, such that these elements are
      still the actual coefficients in the equation after the
      division,
    \item differentiate the equation and the $C_{im}, m>l$
      w.r.t.\ $z_{ij}$.
    \end{itemize}
  \end{itemize}
\item The resulting equation no longer contains any unknown function
  of $x_a$ and can be separated w.r.t.\ $x_a$ directly in case $x_a$
  still occurs explicitly.  In both cases the equation(s) is (are)
  free of $x_a$ afterwards and inverting the sequence of integration
  and multiplication of all those equations (in case of direct
  separability) will also result in an equation(s) free of $x_a$.
  More exactly, the steps are
  \begin{itemize}
  \item multiplication of the equation(s) and the $C_{im}$ with $m<l$
    by the elements of the $C_{ik}$-lists in exactly the inverse
    order,
  \item integration of these exact PDEs and the $C_{im}$
    w.r.t.\ $z_{ij}$.
  \end{itemize}
\item The equations originating that way are used to evaluate those
  functions which do not depend on $x_a$ and which survived in the
  above differentiations.  Substituting these functions in the
  original equation may enable direct separability w.r.t.\ variables
  on which the $f_i$ do not depend on.
\item The whole procedure is repeated for another variable $x_b$ if
  the original DE could not be separated directly and still has the
  property that it contains only functions of a subset of all
  variables in the equation.
\end{itemize}
The additional bookkeeping of coefficients $C_{ik}$ and their updating
by division, differentiation, integration and multiplication is done
to use them as integrating factors for the backward integration.  The
following example makes this clearer.  The equation is
\begin{equation}
0 = f(x) g(y) - \frac{1}{2}xf'(x) - g'(y) - (1+x^2)y. \label{crack-isep}
\end{equation}
The steps are (equal levels of indentation in the example correspond to
those in the algorithm given above)
\begin{itemize}
\item $x_1:=x, \, F=\{f\}$
  \begin{itemize}
  \item Identify $f_1:=f, \; \; \; \; \; y_1:=x, \; \; \; \; \; z_{11}:=y$
  \item and $P_1=\{f',f\}, \; \; \; \; \; C_1=\{1,g\}$
    \begin{itemize}
    \item Divide $C_{12}$ and \eqref{crack-isep} by $C_{11}=1$ and
      differentiate w.r.t.\ $z_{11}=y:$
      \begin{eqnarray}
        0 & = & fg' - g'' - (1+x^2) \label{crack-isep2} \\
        C_{12} & = & g' \nonumber
      \end{eqnarray}
    \item Divide \eqref{crack-isep2} by $C_{12}=g'$ and differentiate
      w.r.t.\ $z_{11}=y$:
      \[ 0 = - (g''/g')' - (1+x^2)(1/g')' \]
    \end{itemize}
  \end{itemize}
\item Direct separation w.r.t.\ $x$ and integration:
  \[ \begin{array}{rclclcl}
    x^2: 0 & = & (1/g')' & \Rightarrow & c_1g' =  1 & \Rightarrow &
    g = y/c_1 + c_2 \\
    x^0: 0 & = & (g''/g')' & \Rightarrow & c_3g' = g'' & \Rightarrow &
    c_3 = 0
  \end{array} \]
\item Substitution of $g$ in the original DE
  \[ 0 = (y/c_1+c_2)f - \frac{1}{2}xf' - 1/c_1 - (1+x^2)y \]
  provides a form which allows \package{Crack} standard methods to
  succeed by direct separation w.r.t.\ $y$
  \[ \begin{array}{rclcl}
    y^1: 0 & = & f/c_1 - 1 - x^2               & \Rightarrow & f'  =  2c_1x \\
    y^0: 0 & = & c_2f - \frac{1}{2}xf' - 1/c_1 & \Rightarrow & 0   =
    c_2c_1(1+x^2) - c_1x^2 - 1/c_1
  \end{array} \]
  and direct separation w.r.t.\ $x$:
  \begin{eqnarray*}
    x^0:  0 & = & c_2c_1 - c_1 \\
    x^2:  0 & = & c_2c_1 - 1/c_1 \\
    & \Rightarrow &  0 = c_1 - 1/c_1 \\
    & \Rightarrow & c_1 = \pm 1 \Rightarrow c_2 = 1.
  \end{eqnarray*}
\end{itemize}
We get the two solutions $f = 1 + x^2, g = 1 + y$ and $f = - 1 - x^2,
g = 1 - y$.  The corresponding input to \package{Crack} would be
\begin{verbatim}
depend f,x;
depend g,y;
crack({f*g-x*df(f,x)/2-df(g,y)-(1+x**2)*y},{},{f,g},{});
\end{verbatim}

\subsubsection{Solving Standard ODEs}

For solving standard ODEs the package \package{ODESolve} by Malcolm
MacCallum and Francis Wright \cite{MacCallum:1989} is applied.  This
package is distributed with REDUCE and can be used independently of
\package{Crack}.  The syntax of \package{ODESolve} is quite similar to
that of \package{Crack}:
\begin{flushleft}\tt
~~~~~depend \textit{function}, \textit{variable}; \\
~~~~~odesolve(\textit{ODE}, \textit{function}, \textit{variable});
\end{flushleft}
The applicability of \package{ODESolve} is increased by a
\package{Crack}-subroutine which recognizes such PDEs in which there
is only one unknown function of all variables and all occurring
derivatives of this function are only derivatives w.r.t.\ one variable
of only one partial derivative.  For example the PDE for $f(x,y)$
\[ 0 = f,_{xxy} + f,_{xxyy} \]
can be viewed as a first order ODE in $y$ for $f,_{xxy}$.

\subsection*{Acknowledgement}

Andreas Brand is the author of a number of core modules of
\package{Crack}.  The currently used data structure and program
structure of the kernel of \package{Crack} are due to him.  He
contributed to the development of \package{Crack} until 1997.

Francis Wright contributed code to REDUCE that provides
simplifications of expressions involving symbolic derivatives and
integrals.  Also, \package{Crack} makes extensive use of the REDUCE
program \package{ODESolve} written by Malcolm MacCallum and Francis
Wright.

Arrigo Triulzi contributed in supporting the use of different total
orderings of derivatives in doing pseudo-differential Gr\"{o}bner
Basis computations.

Work on this package has been supported by the Konrad Zuse Institute /
Berlin through a fellowship of T.W..  Winfried Neun and Herbert Melenk
are thanked for many discussions and constant support.  Many of the
low level control features have been provided by Winfried Neun.  He
ported Parallel REDUCE to a Linux PC Beowulf cluster and helped in
adapting \package{Crack} to it.

Anthony Hearn provided free copies of REDUCE to us as a REDUCE
developers group which also is thankfully acknowledged.
