;;; sl-on-cl.lisp --- Standard Lisp on Common Lisp

;; Copyright (C) 2018-2026 Francis J. Wright

;; Author: Francis J. Wright <https://sourceforge.net/u/fjwright>
;; Time-stamp: <2026-02-15 17:38:30 franc>
;; Created: 4 November 2018

;; Currently supported implementations of Common Lisp:
;; - SBCL (Steel Bank Common Lisp); see https://www.sbcl.org/
;; - CLISP; see https://clisp.sourceforge.io/
;; - CCL (Clozure Common Lisp); see https://ccl.clozure.com/
;; - ECL (Embeddable Common Lisp); see https://ecl.common-lisp.dev/

;; Support for Armed Bear Common Lisp by Rainer Sch√∂pf, but not yet complete!
;; Support for Clozure Common Lisp by Marco Ferraris.

;; This file implements a superset of Standard Lisp that is a subset
;; of PSL and CSL in a package called STANDARD-LISP with nickname SL.
;; It does not provide a Standard Lisp REPL and is intended only
;; for running REDUCE (which provides its own REPL) on Common Lisp.
;; This implementation of Standard Lisp is lower-case.  It uses case
;; inversion of symbol names and is case-sensitive internally.

;; For Common Lisp documentation see
;; https://www.lispworks.com/documentation/HyperSpec/Front/

;; The implementation of Standard Lisp is in the package
;; STANDARD-LISP-IMPLEMENTATION, with nickname SLIM.  Its external
;; symbols are inherited by the STANDARD-LISP package via the
;; defpackage :use option.

;; Only SLIM uses common-lisp and SL uses only SLIM.  SL contains only
;; required common-lisp external symbols that are imported directly
;; and SLIM external symbols, and so should not contain any extraneous
;; symbols.  Most symbols are interned directly in SL.  NB: It is
;; *essential* that all symbols used in Standard Lisp are interned in
;; SL.  Symbol properties used internally within SLIM use symbols such
;; as :%ftype% and :%fluid% that are in the keyword package, and so
;; are intentionally inaccessible from REDUCE.

;; The names of SLIM internal symbols begin with %, and if they are
;; special variables they also end with %.

;; The DEBUG feature may be initially added by build.sh:
#+DEBUG (eval-when (:compile-toplevel :load-toplevel :execute)
          (push :DEBUG *features*))

(declaim (optimize #-DEBUG speed #+DEBUG debug #+DEBUG safety))
#+(and SBCL (not DEBUG))
(declaim (sb-ext:muffle-conditions sb-ext:compiler-note style-warning))

;; Use Common Lisp math functions if possible, cf.
;; "support/fastmath.red".  OK for SBCL and CCL, but CLISP
;; trigonometric function accuracy can be poor for very large
;; arguments, and tan can lead to division by zero, so use
;; "arith/math.red" for safety:
#+(and (or SBCL CCl LISPMATH) (not NOLISPMATH))
(eval-when (:compile-toplevel :load-toplevel :execute)
  (push :LISPMATH *features*))

#+SBCL (eval-when (:compile-toplevel :load-toplevel :execute)
         (require :sb-posix)
         (require :sb-introspect))

#+CLISP (eval-when (:compile-toplevel :load-toplevel :execute)
          (setq custom:*suppress-check-redefinition* t
                #-DEBUG custom:*compile-warnings* #-DEBUG nil))

#+CCL (eval-when (:compile-toplevel :load-toplevel :execute)
        (require :asdf)             ; used for various OS interactions
        (setq ccl:*warn-if-redefine* nil
              #-DEBUG ccl::*suppress-compiler-warnings* #-DEBUG t))

#+ABCL (eval-when (:compile-toplevel :load-toplevel :execute)
         (require :abcl-contrib)
         (require :asdf-jar))

(defpackage :standard-lisp-implementation
  (:nicknames :slim)
  (:documentation
   "Implementation of lower-case Standard Lisp on Common Lisp")
  (:use :common-lisp)

  ;; Best to use the shadow option here and not separate calls of the
  ;; shadow function, mainly because the shadow function is not
  ;; evaluated at compile time!
  (:shadow :equal :vectorp :get :expt :float
           :eval :function :print :prin1 :terpri
           :load :string-downcase :mod :number)

  #+SBCL (:import-from :sb-ext :quit :gc)
  #+SBCL (:import-from :sb-posix :getenv)

  #+CLISP (:import-from :ext :quit :gc :getenv)

  #+ABCL (:import-from :ext :getenv)

  #+CCL (:import-from :ccl :quit :getenv :setenv :gc)

  #+ECL (:import-from :ext :quit :getenv :setenv)
  )

(defpackage :standard-lisp
  (:nicknames :sl)
  (:documentation "Lower-case Standard Lisp on Common Lisp")
  (:use :standard-lisp-implementation))

(in-package :standard-lisp-implementation)

;; The following definitions roughly follow the order in the Standard
;; Lisp Report.

;;; System GLOBAL Variables
;;; =======================

(defvar *comp nil
  "*COMP = NIL global
The value of !*COMP controls whether or not PUTD compiles the
function defined in its arguments before defining it. If !*COMP is
NIL the function is defined as an EXPR. If !*COMP is something
else the function is first compiled. Compilation will produce certain
changes in the semantics of functions particularly FLUID type access.")

(defvar emsg* nil
  "EMSG* = NIL global
Will contain the MESSAGE generated by the last ERROR call.")

(defconstant $eof$ '$eof$
  "$EOF$ = <an uninterned identifier> global
The value of !$EOF!$ is returned by all input functions when the end
of the currently selected input file is reached.")

(defconstant $eol$ (values (cl:intern (string #\Newline) :sl)) ; cf. PSL & CSL
  "$EOL$ = <an uninterned identifier> global
The value of !$EOL!$ is returned by READCH when it reaches the
end of a logical input record. Likewise PRINC will terminate its
current line (like a call to TERPRI) when !$EOL!$ is its argument.")

(defvar *gc nil
  "*GC = NIL global
!*GC controls the printing of garbage collector messages. If NIL
no indication of garbage collection may occur. If non-NIL various
system dependent messages may be displayed.")

(export '(*comp emsg* $eof$ $eol$ *gc))

(import '(nil) :sl)                ; the list form (nil) is necessary!
;; NIL = NIL global
;; NIL is a special global variable. It is protected from being modifed
;; by SET or SETQ.

;; **********************************************************************
;; Make REDUCE case-insensitive for now to facilitate comparison
;; with the test output from CSL/PSL REDUCE.  Later, could make it
;; case-sensitive with a switch *legacy that enables *raise for
;; compatibility with legacy REDUCE.
;; **********************************************************************

(defvar *raise t
  "*RAISE = NIL fluid
Follow the PSL convention: If !*RAISE is non-NIL all characters input
through Standard LISP input functions will be converted to a standard
case.  Currently, this is upper case on SBCL and lower case on CLISP.
If !*RAISE is NIL characters will be input as is.")

(import 't :sl)
;; T = T global
;; T is a special global variable. It is protected from being modifed by
;; SET or SETQ.

;; Not Standard LISP but PSL and assumed by REDUCE:

(defvar *echo nil
  "*echo = [Initially: nil] switch
The switch echo is used to control the echoing of input. When (on echo)
is placed in an input file, the contents of the file are echoed on the standard
output device. Dskin does not change the value of *echo, so one may say
(on echo) before calling dskin, and the input will be echoed.")

(defvar *redefmsg t
  "*redefmsg = [Initially: t] switch
If *redefmsg is not nil, the message
*** Function `FOO' has been redefined
is printed whenever a function is redefined by PUTD.")
;; Also applies to DE & DM.

(export '(*raise *echo *redefmsg))

(declaim (ftype (cl:function (symbol) null) %redefmsg))

(defun %redefmsg (fname)
  "Optionally warn about function redefinition."
  ;; Assume fname is input quoted.
  (when (and *redefmsg (fboundp fname))
    ;; (warn "Function ~a has been redefined" fname)
    ;; Warnings are currently suppressed!
    ;; (format t "~&*** Function `~(~a~)' has been redefined~%" fname)
    (format t "~&*** Function `~a' has been redefined~%" fname)))

;;; FUNCTIONS
;;; =========

(deftype function (&rest etc) `(or symbol cons (cl:function ,@etc)))

(deftype filehandle () '(or cons null))

(deftype number () '(or integer double-float))

;; NB: CLISP only accepts (typespec var*) as an abbreviation for (type
;; typespec var*) for standardized atomic type specifiers, which I
;; think is a bug!

;; First, some utility functions used only internally:

(defmacro %defalias (newname oldname &optional docstring)
  "Make NEWNAME a new name for function OLDNAME and return NEWNAME.
Both NEWNAME and OLDNAME should be symbols.
The optional third argument DOCSTRING specifies the documentation
string for NEWNAME; if it is omitted or nil, NEWNAME uses the
documentation string for OLDNAME."
  (declare (symbol newname oldname) (type (or null simple-string) docstring))
  ;; Eval when compiling to suppress undefined function warnings.
  `(eval-when (:compile-toplevel :load-toplevel :execute)
     ;; For ABCL, autoloaded functions must be loaded before copying
     ;; the function cell. Otherwise only the autoload stub is
     ;; copied.  The call to resolve does this.
     #+ABCL (when (ext:autoloadp ',oldname) (ext:resolve ',oldname))
     ;; New functions (like getv) will not be defined at compile time,
     ;; so can only be aliased at run time!
     (when (fboundp ',oldname)
       (setf (symbol-function ',newname) (symbol-function ',oldname))
       ;; symbol-function includes docstring.
       ,@(when docstring
           `((setf (documentation ',newname 'cl:function) ,docstring)))
       ',newname)))

(declaim (ftype (cl:function (t t) boolean) eqcar))

(export 'eqcar)                         ; used internally

(defun eqcar (u v)
  "Return true if U is a cons cell and its car is eq to V."
  (and (consp u) (eq (car u) v)))

(declaim (ftype (cl:function (character) character) %character-invert-case))

(defun %character-invert-case (c)
  "Invert the case of character C (if it is a letter)."
  (if (cl:both-case-p c)
      (if (cl:lower-case-p c)
          (cl:char-upcase c)
          (cl:char-downcase c))
      c))

(declaim (ftype (cl:function (simple-string) simple-string) %string-invert-case))

(defun %string-invert-case (s)
  "Return a copy of string S with the case of each letter inverted."
  ;; The consequences are undefined if a symbol name is ever modified!
  (cl:map 'simple-string #'%character-invert-case s))

(declaim (ftype (cl:function (character) symbol)
                %intern-character-preserve-case %intern-character-invert-case))

(defun %intern-character-preserve-case (c)
  "Convert character C to an interned (case-preserved) symbol."
  (values (cl:intern (string c) :sl)))

(defun %intern-character-invert-case (c)
  "Convert character C to an interned (case-inverted) symbol."
  (values (cl:intern (string (%character-invert-case c)) :sl)))


;;; Elementary Predicates
;;; =====================

(import 'cl:atom :sl)
;; ATOM(U:any):boolean eval, spread
;; Returns T if U is not a pair.
;; EXPR PROCEDURE ATOM(U);
;;    NULL PAIRP U;

(declaim (ftype (cl:function (t) boolean) sl::codep sl::constantp))

(%defalias sl::codep cl:compiled-function-p
  "CODEP(U:any):boolean eval, spread
Returns T if U is a function-pointer.")
;; This means compiled code only!

(defun sl::constantp (u)
  "CONSTANTP(U:any):boolean eval, spread
Returns T if U is a constant (a number, string, function-pointer, or vector).
EXPR PROCEDURE CONSTANTP(U);
   NULL OR(PAIRP U, IDP U);"
  (null (or (consp u) (symbolp u))))

(import 'cl:eq :sl)
;; EQ(U:any, V:any):boolean eval, spread
;; Returns T if U points to the same object as V. EQ is not a reliable
;; comparison between numeric arguments.

;; The following code seems to cause problems if used in eq or equal.

;; (defun eq (u v)
;;   "EQ(U:any, V:any):boolean eval, spread
;; Returns T if U points to the same object as V. EQ is not a reliable
;; comparison between numeric arguments."
;;   ;; After evaluating (setq gg intern(setq g (gensym))) in PSL/CSL
;;   ;; then (eq g gg) gives true, but in Common Lisp the equivalent
;;   ;; gives false, so...
;;   (if (and (cl:symbolp u) (cl:symbolp v)) ; both symbols
;;       ;; Look for both symbols NOW in the current package:
;;       (let ((uu (find-symbol (symbol-name u)))
;;             (vv (find-symbol (symbol-name v))))
;;         (and uu vv (cl:eq uu vv)))
;;       (cl:eq u v)))

(declaim (ftype (cl:function (t t) boolean) sl::eqn equal))

(defun sl::eqn (u v)
  "EQN(U:any, V:any):boolean eval, spread
Returns T if U and V are EQ or if U and V are numbers and have
the same value and type."               ; i.e. the same SL type!
  ;;  eql/equal may not be true of two floats even when they represent
  ;;  the same value.  = is used to compare mathematical values.
  ;;  (eql/equal -0.0 0.0) is false in SBCL although true in CLISP!
  (if (and (floatp u) (floatp v)) (= u v) (eql u v)))

(export 'equal)                         ; used internally

(%defalias equal cl:equalp
  ;; This definition is not strictly correct but it seems to be the
  ;; best compromise!
  "EQUAL(U:any, V:any):boolean eval, spread
Returns T if U and V are the same. Dotted-pairs are compared
recursively to the bottom levels of their trees. Vectors must
have identical dimensions and EQUAL values in all
positions. Strings must have identical characters. Function
pointers must have EQ values. Other atoms must be EQN equal.")

(declaim (ftype (cl:function (t) boolean) sl::fixp sl::idp))

(%defalias sl::fixp cl:integerp
  "FIXP(U:any):boolean eval, spread
Returns T if U is an integer (a fixed number).")

(import 'cl:floatp :sl)
;; FLOATP(U:any):boolean eval, spread
;; Returns T if U is a floating point number.

(%defalias sl::idp cl:symbolp
  "IDP(U:any):boolean eval, spread
Returns T if U is an id.")

(declaim (inline minusp)
         (ftype (cl:function (t) boolean) sl::minusp))

(defun sl::minusp (u)
  "MINUSP(U:any):boolean eval, spread
Returns T if U is a number and less than 0. If U is not a number
or is a positive number, NIL is returned.
EXPR PROCEDURE MINUSP(U);
   IF NUMBERP U THEN LESSP(U, 0) ELSE NIL;"
  (and (realp u) (cl:minusp u)))

(import 'cl:null :sl)
;; NULL(U:any):boolean eval, spread
;; Returns T if U is NIL.
;; EXPR PROCEDURE NULL(U);
;;    U EQ NIL;

(import 'cl:numberp :sl)
;; NUMBERP(U:any):boolean eval, spread
;; Returns T if U is a number (integer or floating).
;; EXPR PROCEDURE NUMBERP(U);
;;    IF OR(FIXP U, FLOATP U) THEN T ELSE NIL;

(declaim (inline sl::onep vectorp sl::zerop)
         (ftype (cl:function (t) boolean)
                sl::onep sl::pairp vectorp sl::zerop))

(defun sl::onep (u)
  "ONEP(U:any):boolean eval, spread.
Returns T if U is a number and has the value 1 or 1.0. Returns NIL
otherwise.
EXPR PROCEDURE ONEP(U);
   OR(EQN(U, 1), EQN(U, 1.0));"
  (equalp u 1))

(%defalias sl::pairp cl:consp
  "PAIRP(U:any):boolean eval, spread
Returns T if U is a dotted-pair.")

(import 'cl:stringp :sl)
;; STRINGP(U:any):boolean eval, spread
;; Returns T if U is a string.

(export 'vectorp)                       ; used internally

(defun vectorp (u)
  "VECTORP(U:any):boolean eval, spread
Returns T if U is a vector."
  ;; Must exclude strings, which are also vectors in CL.
  ;; (and (vectorp u) (not (stringp u)))
  (typep u '(vector t)))

(defun sl::zerop (u)
  "ZEROP(U:any):boolean eval, spread
Returns T if U is a number and has the value 0 or 0.0. Returns
NIL otherwise.
EXPR PROCEDURE ZEROP(U);
   OR(EQN(U, 0), EQN(U, 0.0));"
  (and (numberp u) (cl:zerop u)))


;;; Functions on Dotted-Pairs
;;; =========================

(import 'cl:car :sl)
;; CAR(U:dotted-pair):any eval, spread
;; CAR(CONS(a, b)) --> a. The left part of U is returned. The type
;; mismatch error occurs if U is not a dotted-pair.

(import 'cl:cdr :sl)
;; CDR(U:dotted-pair):any eval, spread
;; CDR(CONS(a, b)) --> b. The right part of U is returned. The type
;; mismatch error occurs if U is not a dotted-pair.

;; The composites of CAR and CDR are supported up to 4 levels:
(import '(cl:caar cl:cadr cl:cdar cl:cddr cl:caaar cl:caadr cl:cadar
          cl:caddr cl:cdaar cl:cdadr cl:cddar cl:cdddr cl:caaaar
          cl:caaadr cl:caadar cl:caaddr cl:cadaar cl:cadadr cl:caddar
          cl:cadddr cl:cdaaar cl:cdaadr cl:cdadar cl:cdaddr cl:cddaar
          cl:cddadr cl:cdddar cl:cddddr)
        :sl)

(import 'cl:cons :sl)
;; CONS(U:any, V:any):dotted-pair eval, spread
;; Returns a dotted-pair which is not EQ to anything and has U as its
;; CAR part and V as its CDR part.

(import 'cl:list :sl)
;; LIST([U:any]):list noeval, nospread, or macro
;; A list of the evaluation of each element of U is returned. The order of
;; evaluation need not be first to last as the following definition implies.
;; FEXPR PROCEDURE LIST(U);
;;    EVLIS U;

(import 'cl:rplaca :sl)
;; RPLACA(U:pair, V:any):pair eval, spread
;; The car of the pair U is replaced by V and the modified pair U is
;; returned.  A type mismatch error occurs if U is not a pair.

(import 'cl:rplacd :sl)
;; RPLACD(U:pair, V:any):pair eval, spread
;; The cdr of the pair U is replaced by V and the modified pair U is
;; returned.  A type mismatch error occurs if U is not a pair.

;; PSL functions:

(import '(cl:first cl:second cl:third cl:fourth cl:rest) :sl)

(declaim (inline sl::lastpair sl::lastcar sl::nth sl::pnth)
         (ftype (cl:function (t) t) sl::lastpair sl::lastcar))

(defun sl::lastpair (l)
  "(lastpair L:pair): any expr
Returns the last pair of a L. It is often useful to think of this as a
pointer to the last element for use with destructive functions such as
rplaca. If L is not a pair then a type mismatch error occurs.
\(de lastpair (l)
  (if (or (atom l) (atom (cdr l)))
    l
    (lastpair (cdr l))))"
  ;; The inconsistent description above is from the PSL manual!
  (if (atom l) l (cl:last l)))

(defun sl::lastcar (l)
  "(lastcar L:pair): any expr
Returns the last element of the pair L. A type mismatch error results
if L is not a pair.
\(de lastcar (l)
  (if (atom l) l (car (lastpair l))))"
  ;; The inconsistent description above is from the PSL manual!
  (if (atom l) l (car (cl:last l))))

(declaim (ftype (cl:function (list fixnum) t) sl::nth sl::pnth))

(defun sl::nth (l n)
  "(nth L:pair N:integer): any expr
Returns the Nth element of the list L. If L is atomic or contains
fewer than N elements, an out of range error occurs.
\(de nth (l n)
    (cond ((null l) (range-error))
          ((onep n) (first l))
          (t (nth (rest l) (sub1 n)))))
Note that this definition is not compatible with Common LISP. The
Common LISP definition reverses the arguments and defines the car
of a list to be the zeroth element."
  (cl:nth (1- n) l))

(defun sl::pnth (l n)
  "(pnth L:list N:integer): any expr
Returns a list starting with the nth element of the list L. Note
that the result is a pointer to the nth element of L, a
destructive function like rplaca can be used to modify the
structure of L. If L is atomic or contains fewer than N elements,
an out of range error occurs.
\(de pnth (l n)
    (cond ((onep n) l)
          ((not (pairp l)) (range-error))
          (t (pnth (rest l) (sub1 n)))))"
  (nthcdr (1- n) l))


;;; Identifiers
;;; ===========

(defmacro %error (message &rest args)
  "Report an error detected internally in sl-on-cl with message
MESSAGE possibly followed by arguments ARGS as for `format'."
  `(cl:error ,message ,@args))

(declaim (ftype (cl:function (symbol) character) %id-to-char-invert-case))

(defun %id-to-char-invert-case (c)
  "As `cl:character', but case-inverted."
  (%character-invert-case (character c)))

(declaim (ftype (cl:function (list) t) sl::compress))

(defun sl::compress (u)                 ; PSL spec
  "COMPRESS(U:id-list):{atom-vector} eval, spread
U is a list of single character identifiers which is built into a
Standard LISP entity and returned.  Recognized are lists, numbers,
strings, and identifiers with the escape character prefixing special
characters.  Identifiers are not interned.  Function pointers may not
be compressed.  If an entity cannot be parsed out of U an error
occurs:
***** Poorly formed atom in COMPRESS"
  (labels
      ((compress () ; This internal function recursively process lists.
         ;; Concatenate the characters into a string and then handle any !
         ;; characters as follows:
         ;; A string begins with " and should retain any ! characters without
         ;; change.
         ;; A number begins with - or a digit and should not contain any !
         ;; characters.
         ;; Otherwise, assume an identifier and replace ! by \, but !! by \!
         (let (u0)                      ; first element
           (compress-skip-spaces)       ; skip leading spaces
           (if (or (null u)
                   (cl:member (setq u0 (car u))
                              '(sl::\' sl::\) sl::\, sl::\% sl::\[ sl::\\ sl::\`))) ; PSL
               (%error "Poorly formed S-expression in COMPRESS"))
           (cond
             ;; LIST?
             ((eq u0 'sl::\() (setq u (cdr u))
              (compress-skip-spaces)    ; skip leading spaces
              (loop
                    while (not (eq (car u) 'sl::\)))
                    collect (compress)
                    do (compress-skip-spaces)))
             ;; STRING?
             ((eq u0 'sl::\")
              ;; In Standard Lisp, "" in a string represents ":
              (loop with newu while (setq u (cdr u)) do
                    (when (eq (car u) 'sl::\")
                      (setq u (cdr u))
                      (if (not (and u (eq (car u) 'sl::\"))) ; end of string
                          (return-from compress
                            (cl:map 'string #'%id-to-char-invert-case
                                    (nreverse newu)))))
                    (push (car u) newu))
              ;; String not terminated:
              (%error "Poorly formed S-expression in COMPRESS"))
             ;; NUMBER?
             ((or (digit u0) (char= (character u0) #\-))
              ;; (eq u0 '-) fails because u0 is in SL but - is (an operator) in CL.
              (multiple-value-bind (obj pos)
                  (read-from-string (cl:map 'string #'character u))
                (setq u (nthcdr pos u))
                obj))
             ;; IDENTIFIER
             (t
              ;; Delete a single ! but replace !! by !
              ;; In PSL, an identifier can contain any of the special characters
              ;; + - $ & * / : ; | < = > ? ^ _ { } ~ @
              ;; and hence not any of
              ;; space ! " ' ( ) , . # % [ \ ] `
              ;; unless they are escaped with ! (which must be handled specially).
              (loop with newu do
                    (cond ((or (null u)
                               (cl:member (car u)
                                          '(sl::\  sl::\" sl::\' sl::\( sl::\) sl::\,
                                            sl::\% sl::\[ sl::\\ sl::\] sl::\`)))
                           (return
                             (make-symbol ; uninterned symbol
                              (cl:map 'string #'character (nreverse newu)))))
                          ((eq (car u) 'sl::!) ; ignore ! but keep WHATEVER follows it
                           (if (setf u (cdr u))
                               (push (car u) newu)))
                          (t (push (car u) newu)))
                    (setf u (cdr u)))))))
       ;;
       (compress-skip-spaces ()
         (loop while (eq (car u) 'sl::\ ) do (setq u (cdr u)))))
    ;;
    (compress)))

;; The following potential succinct new version of compress causes a
;; problem reading "rlisp/tok.red" that I can't track down, so it is
;; commented out for now.

;; (defun sl::compress (u)                 ; PSL spec
;;   "COMPRESS(U:id-list):{atom-vector} eval, spread
;; U is a list of single character identifiers which is built into a
;; Standard LISP entity and returned.  Recognized are lists, numbers,
;; strings, and identifiers with the escape character prefixing special
;; characters.  Identifiers are not interned.  Function pointers may not
;; be compressed.  If an entity cannot be parsed out of U an error
;; occurs:
;; ***** Poorly formed atom in COMPRESS"
;;   (let ((*readtable* %sl-readtable%))
;;     (read-from-string
;;      ;; When reading a string, it must be followed by something:
;;      (concatenate 'string (cl:map 'string #'character u) " ")
;;      nil $eof$)))

(declaim (ftype (cl:function (t) list) explode))

(export 'explode)                       ; used internally (recursive)

(defun explode (u)                      ; PSL spec
  "(explode U:any): id-list expr
Explode returns a list of interned single-character identifiers
representing the characters required to print the S-expression U in a
way that could be read by Lisp.  It is implemented by effectively
printing (using prin1) to a list.  E.g.
1 lisp> (explode 'foo)
\(f o o)
2 lisp> (explode '(a . b))
\(!( a !  !. !  b !))"
  ;; Add support for vectors?  Share code with print routines?
  (if (consp u)
      ;; Exploding a cons:
      (let ((ll (list (explode (car u)) (list 'sl::\())))
        (loop while (consp (setq u (cdr u)))
              do (push (list 'sl::\ ) ll)
              do (push (explode (car u)) ll))
        (when u
          (push (list 'sl::\  'sl::\. 'sl::\ ) ll)
          (push (explode u) ll))
        (push (list 'sl::\)) ll)
        (cl:apply #'nconc (nreverse ll)))
      ;; Exploding an atom:
      (typecase u
        (string
         ;; Add leading and trailing " and convert internal " to "":
         (nconc
          (list 'sl::\")
          (loop for c across u
                collect (%intern-character-invert-case c)
                when (char= c #\") collect 'sl::\")
          (list 'sl::\")))
        (integer
         (cl:map 'list #'%intern-character-preserve-case
                 (princ-to-string u)))
        (cl:float
         (cl:map 'list #'%intern-character-invert-case
                 (%prin-float-to-string u)))
        (t
         ;; Identifier, function-pointer, etc -- insert ! before
         ;; an upper-case letter, leading digit or _, or special
         ;; character (except _):
         (loop with s = (princ-to-string u) and c
               for i below (cl:length s)
               do (setq c (aref s i))
               unless (or (upper-case-p c) ; case-inverted!
                          (and (not (eql i 0))
                               (or (digit-char-p c) (char= c #\_))))
               collect 'sl::\!
               collect (%intern-character-preserve-case c))))))

(defvar %gensym-counter% 0
  "A non-negative integer used in constructing the name of the next
symbol generated by the function gensym.")

(declaim (ftype (cl:function () symbol) sl::gensym))

(defun sl::gensym ()
  "GENSYM():identifier eval, spread
Creates an identifier which is not interned on the OBLIST and
consequently not EQ to anything else."
  (prog1
      (make-symbol (format nil "G~4,'0d" %gensym-counter%))
    (incf %gensym-counter%)))

(declaim (ftype (cl:function (t) boolean) sl::gensymp))

(defun sl::gensymp (u)                  ; from pslrend
  (and (symbolp u) (not (cl:find-symbol (cl:symbol-name u)))))

(declaim (ftype (cl:function ((or symbol simple-string)) symbol)
                sl::intern))

(defun sl::intern (u)
  "INTERN(U:{id,string}):id eval, spread
INTERN searches the OBLIST for an identifier with the same print
name as U and returns the identifier on the OBLIST if a match is
found. Any properties and global values associated with U may be
lost. If U does not match any entry, a new one is created and
returned. If U has more than the maximum number of characters
permitted by the implementation (the minimum number is 24) an
error occurs:
***** Too many characters to INTERN"
  (values (cl:intern (if (symbolp u)
                         (cl:symbol-name u)       ; symbol
                         (%string-invert-case u)) ; string
                     :sl)))

(declaim (ftype (cl:function (symbol) symbol) sl::remob))

(defun sl::remob (u)
  "REMOB(U:id):id eval, spread
If U is present on the OBLIST it is removed. This does not affect U
having properties, flags, functions and the like. U is returned."
  (unintern u :sl) u)


;;; Property List Functions
;;; =======================

;; In file "rlisp/superv.red" is the statement
;;
;; FLAG('(DEFLIST FLAG FLUID GLOBAL REMFLAG REMPROP UNFLUID),'EVAL);
;;
;; which means that the functions listed are evaluated even with `ON
;; DEFN', which is necessary to ensure that some source code reads
;; correctly.  However, `REMPROP' is usually followed by `PUT' to
;; reinstate whatever property was removed, but `PUT' is not flagged
;; `EVAL', so this reinstatement doesn't happen because evaluating
;; `PUT' at the wrong time can cause similar problems, e.g. with
;; `rlisp88'.  Hence, viewing code with `ON DEFN' can break subsequent
;; code.  For example, inputting "rlisp/module.red" with `ON DEFN'
;; removes the `STAT' property from `LOAD_PACKAGE', which then no
;; longer works correctly.  This is a major problem for the way I
;; generate fasl files!
;;
;; I therefore provide a workaround to make the functions DEFLIST,
;; FLAG, REMFLAG and REMPROP save the property list of any identifier
;; before modifying it if it has not already been saved, and provide a
;; function to reinstate the saved property list.  I use this facility
;; when generating fasl files and in `OFF DEFN' (see "eslrend.red"),
;; so that ESL REDUCE should be immune to this `ON DEFN' side-effect.
;;
;; However, this facility only applies to reading REDUCE code and must
;; be disabled when loading a Lisp file, i.e. when the variable
;; `*load-pathname*' is non-nil.  This is particularly important when
;; building REDUCE.

(defvar *defn nil)

(export '*defn)

(defvar %saved-plist-alist% nil
  "Association list of symbols and their saved property lists.
Its value should normally be nil, except while ON DEFN.")

(declaim (ftype (cl:function (symbol) null) %save-plist))

(defun %save-plist (symbol)
  "Save property list of symbol SYMBOL if not already saved.
Do not do this if Lisp file load in progress."
  (or *load-pathname*
      (cl:assoc symbol %saved-plist-alist% :test #'eq)
      (push (cons symbol (cl:copy-tree (symbol-plist symbol)))
            %saved-plist-alist%))
  nil)

(declaim (ftype (cl:function () null) %reinstate-plists))

(defun %reinstate-plists ()
  "Reinstate all saved property lists.
Do not do this if Lisp file load in progress."
  (unless *load-pathname*
    (cl:mapc #'(lambda (s) (setf (symbol-plist (car s)) (cdr s)))
             %saved-plist-alist%)
    (setf %saved-plist-alist% nil))
  nil)

(declaim (ftype (cl:function (list symbol) null) flag))

(export 'flag)                          ; used internally

(defun flag (u v)
  "FLAG(U:id-list, V:id):NIL eval, spread
U is a list of ids which are flagged with V. The effect of FLAG is
that FLAGP will have the value T for those ids of U which were
flagged. Both V and all the elements of U must be identifiers or the
type mismatch error occurs."
  (when *defn (cl:mapc #'%save-plist u))
  (cl:mapc #'(lambda (x) (put x v t)) u)
  nil)

(declaim (inline sl::flagp)
         (ftype (cl:function (t t) boolean) sl::flagp))

(defun sl::flagp (u v)
  "FLAGP(U:any, V:any):boolean eval, spread
Returns T if U has been previously flagged with V, else NIL. Returns
NIL if either U or V is not an id."
  (when (and (symbolp u) (symbolp v)) (cl:get u v)))

(declaim (ftype (cl:function (t symbol) t) get))

(export 'get)                           ; used internally

(defun get (u ind)
  "GET(U:any, IND:id):any eval, spread
Returns the property associated with indicator IND from the
property list of U. If U does not have indicator IND, NIL is
returned.  GET cannot be used to access functions (use GETD
instead)."
  ;; MUST return nil if u is not a symbol.
  (when (symbolp u) (cl:get u ind)))

(declaim (ftype (cl:function (symbol symbol t) t) put))

(export 'put)                           ; used internally

(defun put (u ind prop)
  "PUT(U:id, IND:id, PROP:any):any eval, spread
The indicator IND with the property PROP is placed on the
property list of the id U. If the action of PUT occurs, the value
of PROP is returned. If either of U and IND are not ids the type
mismatch error will occur and no property will be placed. PUT
cannot be used to define functions (use PUTD instead)."
  (setf (cl:get u ind) prop))

(declaim (ftype (cl:function (list symbol) null) sl::remflag))

(defun sl::remflag (u v)
  "REMFLAG(U:any-list, V:id):NIL eval, spread
Removes the flag V from the property list of each member of the
list U. Both V and all the elements of U must be ids or the type
mismatch error will occur."
  (when *defn (cl:mapc #'%save-plist u))
  (cl:mapc #'(lambda (x) (cl:remprop x v)) u)
  nil)

(declaim (ftype (cl:function (t symbol) t) sl::remprop))

(defun sl::remprop (u ind)
  "REMPROP(U:any, IND:any):any eval, spread
Removes the property with indicator IND from the property list of U.
Returns the removed property or NIL if there was no such indicator."
  (prog1 (get u ind)
    (when *defn (%save-plist u))
    (cl:remprop u ind)))


;;; Function Definition
;;; ===================

(declaim (inline fluidp)
         (ftype (cl:function (t) boolean) fluidp))

(export 'fluidp)                        ; used internally

(defun fluidp (u)
  "FLUIDP(U:any):boolean eval, spread
If U has been declared fluid then t is returned, otherwise nil is returned."
  (get u :%fluid%))

(declaim (inline globalp)
         (ftype (cl:function (t) boolean) globalp))

(export 'globalp)                       ; used internally

(defun globalp (u)
  "GLOBALP(U:any):boolean eval, spread
If U has been declared global then t is returned, otherwise nil is returned."
  (get u :%global%))

;; NOTE that Standard Lisp macros are nospread and therefore take a
;; single parameter that gets the list of actual arguments, so `DM'
;; and `PUTD' must convert the macro parameter into an &rest
;; parameter.  Also, when a Standard Lisp macro is called it receives
;; its name as its first argument, i.e. the single parameter evaluates
;; to the COMPLETE function call, so `DM' and `PUTD' must modify the
;; macro argument list within the body lambda expression.

;; Ref. Standard LISP Report, page 9: "When a macro invocation is
;; encountered, the body of the macro, a lambda expression, is invoked
;; as a NOEVAL, NOSPREAD function with the macro's invocation bound as
;; a list to the macros single formal parameter."

;; REDUCE handles macros specially, assuming they are Standard LISP
;; macros, whereas SL functions that are actually defined as Common
;; Lisp macros need to be handled by REDUCE as if they were EXPRs.
;; Therefore, it is important that the function type defaults to EXPR,
;; so only macros defined using DM or PUTD are given the property
;; :%FTYPE% with value :%MACRO%.  The :%FTYPE% property is required so
;; that macros defined in REDUCE can be distinguished from Common Lisp
;; macros.  Normal functions defined using DE or PUTD are given the
;; property :%FTYPE% with value :%EXPR% just for symmetry, but this
;; property value is not actually used by GETD.

(export 'de)                            ; used internally

(defmacro de (fname params &rest fn)    ; PSL definition
  "(de Fname:id PARAMS:id-list [FN:form]): id macro
Defines the function named FNAME, of type expr. The forms FN are made
into a lambda expression with the formal parameter list PARAMS, and
this is used as the body of the function.  Previous definitions of the
function are lost. The name of the defined function, FNAME, is
returned."
  (declare (symbol fname) (list params fn))
  `(progn
     (%redefmsg ',fname)
     (put ',fname :%ftype% :%expr%)
     (defun ,fname ,params ,@fn)
     ;; It makes no sense to include code to compile this function
     ;; when the function definition is being compiled into a fasl
     ;; file, so examine *COMP when the macro is expanded/compiled and
     ;; ensure that *COMP is nil when fasl files are being generated.
     ;; Splice in *list* of content or nil.
     ,@(if *comp `((values (compile ',fname))))))

;; *** df appears not to be required, so is not implemented. ***
;; DF(FNAME:id, PARAM:id-list, FN:any):id noeval, nospread
;; The function FN with formal parameter PARAM is added to the set
;; of defined functions with the name FNAME. Any previous definitions
;; of the function are lost. The function created is of type FEXPR. If
;; the !*COMP variable is T the FEXPR is first compiled. The name
;; of the defined function is returned.
;; FEXPR PROCEDURE DF(U);
;;    PUTD(CAR U, 'FEXPR, LIST('LAMBDA, CADR U, CADDR U));

(export 'dm)                            ; used internally

(defmacro dm (mname param fn)
  "DM(MNAME:id, PARAM:id-list, FN:any):id noeval, nospread
The macro FN with the formal parameter PARAM is added to the set
of defined functions with the name MNAME. Any previous
definitions of the function are overwritten. The function created
is of type MACRO. The name of the macro is returned.
FEXPR PROCEDURE DM(U);
   PUTD(CAR U, 'MACRO, LIST('LAMBDA, CADR U, CADDR U));"
  (declare (symbol mname) (list param fn))
  `(progn
     (%redefmsg ',mname)
     (put ',mname :%ftype% :%macro%)
     ;; Save the (uncompiled) SL macro form:
     ;; (put ',mname '%macro% '(macro lambda ,param ,fn)) ; not currently used
     ;; param must be a list containing a single identifier, which
     ;; must therefore be spliced into the macro definition.
     ;; Spread the arguments and include macro name as first arg:
     (defmacro ,mname (&whole ,@param &rest r)
       ;; The parameter r should probably be a gensym to avoid
       ;; potential name clashes!
       (declare (ignore r))
       ,fn)
     ,@(if *comp `((values (compile ',mname)))))) ; see DE

(declaim (ftype (cl:function (t) list) getd))

(export 'getd)                          ; used internally

(defun getd (fname)
  "GETD(FNAME:any):{NIL, dotted-pair} eval, spread
If FNAME is not the name of a defined function, return NIL. If
FNAME is a defined function then return the dotted-pair
\(TYPE:ftype . DEF:{function-pointer, lambda})."
  (and (symbolp fname) (fboundp fname)
       (cond
         ;; MACRO if fname defined using SL dm macro:
         ((eq (cl:get fname :%ftype%) :%macro%)
          ;; Return the (uncompiled) SL macro form:
          ;; This may need more work!
          ;; A CL macro expansion needs an environment.
          ;; Try the null environment (nil) initially.
          ;; (The parameter x should perhaps be a gensym.)
          (cons 'sl::macro
                `(lambda (x)
                   (funcall ,(macro-function fname) x nil))))
         ;; FEXPR for CL (but not SL) macro or special operator:
         ((or (macro-function fname) (special-operator-p fname))
          (cons 'sl::fexpr (symbol-function fname)))
         ;; EXPR otherwise:
         ((compiled-function-p (setq fname (symbol-function fname)))
          (cons 'sl::expr fname))
         (t (let ((f (function-lambda-expression fname)))
              ;; Note that a CL lambda expression may contain
              ;; declarations and a documentation string, and the
              ;; body MAY BE wrapped in a block form, i.e.
              ;; (lambda params [decls] [doc] (block name body))
              ;; [A compiled CLISP function may not contain a block!]
              ;; Extract the function body:
              (setq fname (car (last f))) ; block or body form
              (when (eqcar fname 'block) (setq fname (caddr fname)))
              (cons 'sl::expr `(lambda ,(cadr f) ,fname)))))))

(declaim (ftype (cl:function (symbol symbol function) symbol) putd))

(export 'putd)                          ; used internally

(defun putd (fname type body)
  "PUTD(FNAME:id, TYPE:ftype, BODY:function):id eval, spread
Creates a function with name FNAME and definition BODY of type
TYPE. If PUTD succeeds the name of the defined function is
returned. The effect of PUTD is that GETD will return a
dotted-pair with the functions type and definition. Likewise the
GLOBALP predicate will return T when queried with the function
name. If the function FNAME has already been declared as a
GLOBAL or FLUID variable the error:
***** FNAME is a non-local variable
occurs and the function will not be defined. If function FNAME
already exists a warning message will appear:
*** FNAME redefined
The function defined by PUTD will be compiled before definition if
the !*COMP global variable is non-NIL."
  ;; NB: Compilation is done by de and dm.
  (when (or (globalp fname) (fluidp fname)) ; only if explicitly declared
    (%error "~a is a non-local variable" fname))
  (%redefmsg fname)
  ;; body = (lambda (u) body-form) or function-pointer
  (let (*redefmsg)                  ; don't report redefinitions twice
    (case type
      (sl::expr                         ; normal function
       (cond ((eqcar body 'lambda)
              (cl:eval `(de ,fname ,(cadr body) ,@(cddr body))))
             ((functionp body)
              (setf (symbol-function fname) body)
              (put fname :%ftype% :%expr%))
             (t (%error "Invalid expr body in PUTD"))))
      (sl::macro                  ; SL macro (implemented as CL macro)
       (cond ((eqcar body 'lambda)
              (if (eq (car (caddr body)) 'funcall)
                  ;; This "hybrid form" is returned by getd.
                  (progn
                    (setf (macro-function fname) (cadr (caddr body)))
                    (put fname :%ftype% :%macro%))
                  ;; This "pure source form" is used in "rlisp/block.red".
                  (cl:eval `(dm ,fname ,(cadr body) ,@(cddr body)))))
             ;; ((functionp body)       ; This case should not happen!
             ;;  (setf (macro-function fname) body)
             ;;  (put fname :%ftype% :%macro%))
             (t (%error "Invalid macro body in PUTD"))))
      ;; I hope putd doesn't get called for a fexpr!
      ;; (fexpr         ; CL special operator or macro (but not SL macro)
      ;;  (setf (symbol-function fname) body) ; FAILS FOR BOTH TYPES!
      ;;  (put fname :%ftype% :%fexpr%))
      (t (%error "Invalid type in PUTD"))))
  fname)

(declaim (ftype (cl:function (symbol) list) sl::remd))

(defun sl::remd (fname)
  "REMD(FNAME:id):{NIL, dotted-pair} eval, spread
Removes the function named FNAME from the set of defined
functions. Returns the (ftype . function) dotted-pair or NIL as
does GETD. The global/function attribute of FNAME is removed and
the name may be used subsequently as a variable."
  (let ((def (getd fname)))
    (when def
      (fmakunbound fname)
      (cl:remprop fname :%ftype%))
    def))

(declaim (ftype (cl:function (symbol symbol function) symbol) sl::compd))

(defun sl::compd (name type body)
  "(compd NAME:id TYPE:ftype BODY:lambda): NAME:id expr
This is a compiling analogue of the function putd.
It is used in \"rsupport.red\" to compile inlines, etc."
  (let ((*comp t)) (putd name type body)))


;;; Variables and Bindings
;;; ======================

;; Note that FLUID and GLOBAL forms must be evaluated when the LISP
;; version of a REDUCE file is generated for compilation, i.e. with ON
;; DEFN, and they normally are because in file "rlisp/superv.red" is
;; the statement
;;
;; FLAG('(DEFLIST FLAG FLUID GLOBAL REMFLAG REMPROP UNFLUID),'EVAL);
;;
;; However, if one of these functions is preceded by LISP or SYMBOLIC
;; then it is not evaluated!  If LISP or SYMBOLIC is flagged EVAL then
;; it causes havoc, so don't precede these functions by LISP or
;; SYMBOLIC.  This is almost always redundant in REDUCE because if the
;; first argument of a function is quoted then the function is
;; automatically evaluated in symbolic mode.

(declaim (ftype (cl:function (list) null) %fluid))

(defun %fluid (idlist)
  "Declare each identifier X in list IDLIST to be FLUID and return nil.
If X is already FLUID then do nothing; if X is already GLOBAL then
display a warning and do nothing else.
This internal function is called only by FLUID."
  (cl:mapc
   #'(lambda (x)
       (unless (fluidp x)
         (if (globalp x)
             ;; A warning, as for PSL, is more convenient than an error!
             (warn "GLOBAL ~a cannot be changed to FLUID" x)
             (progn
               ;; defvar is a macro, so ...
               (cl:eval `(defvar ,x nil "Standard LISP fluid variable."))
               (put x :%fluid% t)))))
   idlist)
  nil)

(export 'fluid)                         ; used internally

(defmacro fluid (idlist)
  ;; Must be a CL macro to be active at compile time!
  "FLUID(IDLIST:id-list):NIL eval, spread
The ids in IDLIST are declared as FLUID type variables (ids not
previously declared are initialized to NIL). Variables in IDLIST
already declared FLUID are ignored. Changing a variable's type
from GLOBAL to FLUID is not permissible and results in the error:
***** ID cannot be changed to FLUID"
  ;; The single argument IDLIST must EVALUATE to an id-list before
  ;; FLUID can be evaluated.  (Usually, it is a quoted id-list.)
  ;; Provided IDLIST evaluates to an id-list, FLUID is probably being
  ;; evaluated at compile or load time, and it is appropriate to use
  ;; the id-list within the macro expansion.  Otherwise, FLUID is
  ;; being evaluated at run time.  (NB: If progn appears as a
  ;; top-level form, then all forms within that progn are considered
  ;; by the compiler to be top-level forms.)
  (handler-case
      ;; If IDLIST fails to evaluate, do not evaluate it during macro
      ;; expansion.
      `(progn
         (eval-when (:compile-toplevel)
           (declaim (special ,@(cl:eval idlist))))
         (eval-when (:load-toplevel :execute)
           (%fluid ,idlist))
         nil)
    (cl:error ()
      ;; Assume a run-time call, e.g. as in
      ;; if not fluidp y and not globalp y then fluid list y;
      ;; in procedure switch in "rlisp/switch.red".
      `(%fluid ,idlist))))

(declaim (ftype (cl:function (list) null) %global))

(defun %global (idlist)
  "Declare each identifier X in list IDLIST to be GLOBAL and return nil.
If X is already GLOBAL then do nothing; if X is already FLUID then
display a warning and do nothing else.
This internal function is called only by GLOBAL."
  (declare (list idlist))
  (cl:mapc
   #'(lambda (x)
       (unless (globalp x)
         (if (fluidp x)
             ;; A warning, as for PSL, is more convenient than an error!
             (warn "FLUID ~a cannot be changed to GLOBAL" x)
             (progn
               ;; Cannot proclaim a CONSTANT variable SPECIAL.
               (unless (cl:constantp x) ; nil, t, $eol$, $eof$, etc.
                 ;; defvar is a macro, so ...
                 (cl:eval `(defvar ,x nil "Standard LISP global variable.")))
               (put x :%global% t)))))
   idlist)
  nil)

(export 'global)                        ; used internally

(defmacro global (idlist)
  ;; Must be a CL macro to be active at compile time!
  "GLOBAL(IDLIST:id-list):NIL eval, spread
The ids of IDLIST are declared GLOBAL type variables. If an id
has not been declared previously it is initialized to
NIL. Variables already declared GLOBAL are ignored. Changing a
variables type from FLUID to GLOBAL is not permissible and
results in the error:
***** ID cannot be changed to GLOBAL"
  ;; See comments in FLUID.
  (handler-case
      ;; If IDLIST fails to evaluate, do not evaluate it during macro
      ;; expansion.
      `(progn
         (eval-when (:compile-toplevel)
           ;; Cannot proclaim a CONSTANT variable SPECIAL.
           (declaim (special ,@(remove-if #'cl:constantp (cl:eval idlist)))))
         (eval-when (:load-toplevel :execute)
           (%global ,idlist))
         nil)
    (cl:error ()
      ;; Assume a run-time call, e.g. as in
      ;; global list s;
      ;; in procedure ps!:unknown!-crule in "tps/tpscomp.red".
      `(%global ,idlist))))

(import 'cl:set :sl)
;; Auto fluid not implemented!
;; SET(EXP:id, VALUE:any):any eval, spread
;; EXP must be an identifier or a type mismatch error occurs. The
;; effect of SET is replacement of the item bound to the identifier
;; by VALUE. If the identifier is not a local variable or has not
;; been declared GLOBAL it is automatically declared FLUID with the
;; resulting warning message:
;; *** EXP declared FLUID
;; EXP must not evaluate to T or NIL or an error occurs:
;; ***** Cannot change T or NIL

(import 'cl:setq :sl)
;; Auto fluid not implemented!
;; SETQ(VARIABLE:id, VALUE:any):any noeval, nospread
;; If VARIABLE is not local or GLOBAL it is by default declared
;; FLUID and the warning message:
;; *** VARIABLE declared FLUID
;; appears. The value of the current binding of VARIABLE is replaced
;; by the value of VALUE. VARIABLE must not be T or NIL or an
;; error occurs:
;; ***** Cannot change T or NIL
;; MACRO PROCEDURE SETQ(X);
;;    LIST('SET, LIST('QUOTE, CADR X), CADDR X);

(declaim (ftype (cl:function (list) null) sl::unfluid))

(defun sl::unfluid (idlist)
  "UNFLUID(IDLIST:id-list):NIL eval, spread
The variables in IDLIST that have been declared as FLUID
variables are no longer considered as fluid variables. Others are
ignored. This affects only compiled functions as free variables
in interpreted functions are automatically considered fluid."
  (cl:mapc #'(lambda (x) (if (fluidp x) (cl:remprop x 'fluid)))
           idlist)
  nil)

;; SL declarations for special variables defined above:
(fluid '(*comp *gc *raise))
(global '(emsg*))


;;; Program Feature Functions
;;; =========================

(import 'cl:go :sl)
;; GO(LABEL:id) noeval, nospread
;; GO alters the normal flow of control within a PROG function. The
;; next statement of a PROG function to be evaluated is immediately
;; preceded by LABEL. A GO may only appear in the following situations:
;; 1. At the top level of a PROG referencing a label which also
;;    appears at the top level of the same PROG.
;; 2. As the consequent of a COND item of a COND appearing on the
;;    top level of a PROG.
;; 3. As the consequent of a COND item which appears as the
;;    consequent of a COND item to any level.
;; 4. As the last statement of a PROGN which appears at the top
;;    level of a PROG or in a PROGN appearing in the consequent of a
;;    COND to any level subject to the restrictions of 2 and 3.
;; 5. As the last statement of a PROGN within a PROGN or as the
;;    consequent of a COND in a PROGN to any level subject to the
;;    restrictions of 2, 3 and 4.
;; If LABEL does not appear at the top level of the PROG in which
;; the GO appears, an error occurs:
;; ***** LABEL is not a known label
;; If the GO has been placed in a position not defined by rules 1-5,
;; another error is detected:
;; ***** Illegal use of GO to LABEL

(import 'cl:prog :sl)
;; PROG(VARS:id-list, [PROGRAM:{id, any}]):any noeval, nospread
;; VARS is a list of ids which are considered fluid when the PROG is
;; interpreted and local when compiled. The PROGs variables are
;; allocated space when the PROG form is invoked and are deallocated
;; when the PROG is exited. PROG variables are initialized to
;; NIL. The PROGRAM is a set of expressions to be evaluated in order
;; of their appearance in the PROG function. Identifiers appearing
;; in the top level of the PROGRAM are labels which can be
;; referenced by GO. The value returned by the PROG function is
;; determined by a RETURN function or NIL if the PROG "falls
;; through".

(import 'cl:progn :sl)
;; PROGN([U:any]):any noeval, nospread
;; U is a set of expressions which are executed sequentially. The
;; value returned is the value of the last expression.

(import 'cl:prog1 :sl)                      ; PSL
;; (prog1 [U:form]): any macro
;; Prog1 evaluates its arguments in order, like progn, but returns the
;; value of the first.

(import 'cl:prog2 :sl)
;; PROG2(A:any, B:any)any eval, spread
;; Returns the value of B.
;; EXPR PROCEDURE PROG2(A, B);
;;    B;

(import 'cl:return :sl)
;; RETURN(U:any) eval, spread
;; Within a PROG, RETURN terminates the evaluation of a PROG
;; and returns U as the value of the PROG. The restrictions on the
;; placement of RETURN are exactly those of GO. Improper placement
;; of RETURN results in the error:
;; ***** Illegal use of RETURN


;;; Error Handling
;;; ==============

(define-condition sl-error1 (cl:error)
  ()
  (:documentation "Standard Lisp error without error number or message"))

(declaim (ftype (cl:function () nil) sl::error1))

(defun sl::error1 ()
  "This is the simplest error return, without a message printed.
It can be defined as ERROR(99,NIL) if necessary.
In PSL it is throw('!$error!$,99)."
  ;; This error function is called by rederr.
  (cl:error 'sl-error1))

(define-condition sl-error (cl:error)
  ((errno :initarg :errno) (errmsg :initarg :errmsg))
  (:documentation "Standard Lisp error with an error number and message")
  (:report (lambda (condition stream)
             (with-slots (errno errmsg) condition
               (format stream "Standard Lisp error ~a: ~a." errno errmsg)))))

(declaim (ftype (cl:function (integer t) nil) sl::error))

(defun sl::error (number message)
  "ERROR(NUMBER:integer, MESSAGE:any) eval, spread
NUMBER and MESSAGE are passed back to a surrounding ERRORSET (the
Standard LISP reader has an ERRORSET). MESSAGE is placed in the
global variable EMSG!* and the error number becomes the value of
the surrounding ERRORSET. FLUID variables and local bindings are
unbound to return to the environment of the ERRORSET. Global
variables are not affected by the process."
  (setq emsg* message)
  (cl:error 'sl-error :errno number :errmsg message))

(defvar *debug nil
  "If non-nil then `errorset' always prints a backtrace for errors
as if its argument `tr' were true.")

(export '*debug)

;; The backtrace code below is mostly undocumented and dug out of the
;; source code for the various Lisp systems.  It is therefore
;; unreliable!

(declaim (inline %print-backtrace)
         (ftype (cl:function () null) %print-backtrace))

(defun %print-backtrace ()
  "Print backtrace to default output stream."
    #+SBCL (sb-debug:print-backtrace)
    #+CLISP (system::print-backtrace)   ; See clisp/src/reploop.lisp
    #+CCL (format t "~&~{~s~%~}" (ccl:backtrace-as-list))
    )

;; Limit length of backtrace:
#+SBCL (setq sb-debug:*backtrace-frame-count* 20) ; default 1000
#+CLISP
(ext:without-package-lock ("SYSTEM")
  (setq system::*debug-print-frame-limit* 20)) ; default unlimited

(declaim (ftype (cl:function (t boolean boolean) t) sl::errorset))

(defun sl::errorset (u msgp tr)
  "ERRORSET(U:any, MSGP:boolean, TR:boolean):any eval, spread
If an error occurs during the evaluation of U, the value of
NUMBER from the ERROR call is returned as the value of
ERRORSET. In addition, if the value of MSGP is non-NIL, the
MESSAGE from the ERROR call is displayed upon both the standard
output device and the currently selected output device unless the
standard output device is not open. The message appears prefixed
with 5 asterisks. The MESSAGE list is displayed without top level
parentheses. The MESSAGE from the ERROR call will be available in
the global variable EMSG!*. The exact format of error messages
generated by Standard LISP functions described in this document
are not fixed and should not be relied upon to be in any
particular form. Likewise, error numbers generated by Standard
LISP functions are implementation dependent.
If no error occurs during the evaluation of U, the value of
  (LIST (EVAL U)) is returned.
If an error has been signaled and the value of TR is non-NIL a
trace-back sequence will be initiated on the selected output
device. The trace-back will display information such as unbindings of
FLUID variables, argument lists and so on in an implementation
dependent format."
  ;; TO DO: output to both stdout and currently selected output
  ;; device
  (handler-case (list (eval u))         ; protected form
    (sl-error1 ()
      ;; Handle calls of SL error1 function. (???)
      ;; Used like throw-catch; no message and normally no backtrace.
      (when *debug (%print-backtrace))
      nil)
    (sl-error (condition)
      ;; Handle calls of SL error function.
      (if msgp
          (let ((msg (slot-value condition 'errmsg)))
            ;; If MESSAGE is a list then it is displayed without top
            ;; level parentheses:
            (format t "~&***** ~:[~a~;~{~a~^ ~}~]~%" (listp msg) msg)))
      (when (or tr *debug) (%print-backtrace))
      (slot-value condition 'errno))
    (cl:error (condition)
      ;; Handle CL and SL internal errors. (???)
      (if msgp (format t "~&***** ~a~%" condition))
      (when (or tr *debug) (%print-backtrace))
      nil)))


;;; Vectors
;;; =======

(declaim (inline sl::getv sl::igetv)
         (ftype (cl:function (simple-vector unsigned-byte) t) sl::getv sl::igetv))

(defun sl::getv (v index)
  "GETV(V:vector, INDEX:integer):any eval, spread
Returns the value stored at position INDEX of the vector V. The
type mismatch error may occur. An error occurs if the INDEX does
not lie within 0...UPBV(V) inclusive:
***** INDEX subscript is out of range"
  (aref v index))

(%defalias sl::igetv sl::getv)

(declaim (inline sl::mkvect)
         (ftype (cl:function (fixnum) simple-vector) sl::mkvect))

(defun sl::mkvect (uplim)               ; PSL
  "(mkvect UPLIM:integer): vector expr
Defines and allocates space for a vector with UPLIM+1 elements accessed
as 0 ... UPLIM. Each element is initialized to nil. If UPLIM is -1, an
empty vector is returned. An error occurs if UPLIM is less than -1 or if the
amount of available memory is insufficient for a vector of this size:
***** A vector of size UPLIM cannot be allocated"
  ;; uplim = -1 used in redlog/rltools/lto.red!
  (make-array (1+ uplim) :initial-element nil))

(declaim (inline sl::putv sl::iputv)
         (ftype (cl:function (simple-vector unsigned-byte t) t)
                sl::putv sl::iputv))

(defun sl::putv (v index value)
  "PUTV(V:vector, INDEX:integer, VALUE:any):any eval, spread
Stores VALUE into the vector V at position INDEX. VALUE is
returned. The type mismatch error may occur. If INDEX does not
lie in 0...UPBV(V) an error occurs:
***** INDEX subscript is out of range"
  (setf (aref v index) value))

(%defalias sl::iputv sl::putv)

(declaim (inline sl::upbv)
         (ftype (cl:function (t) (or fixnum null)) sl::upbv))

(defun sl::upbv (u)
  "UPBV(U:any):NIL,integer eval, spread
Returns the upper limit of U if U is a vector, or NIL if it is not."
  (and (vectorp u) (1- (cl:length u))))

(declaim
 (inline sl::getv8)
 (ftype (cl:function ((simple-array (signed-byte 8) (*)) unsigned-byte)
                     (signed-byte 8))
        sl::getv8))

(defun sl::getv8 (v index)              ; CSL
  (aref v index))

(declaim
 (inline sl::mkvect8)
 (ftype (cl:function (unsigned-byte) (simple-array (signed-byte 8) (*)))
        sl::mkvect8))

(defun sl::mkvect8 (uplim)              ; CSL
  "Make a vector of 8-bit signed integers, cf. mkvect."
  (make-array (1+ uplim) :element-type '(signed-byte 8) :initial-element 0))

(declaim
 (inline sl::putv8)
 (ftype (cl:function
         ((simple-array (signed-byte 8) (*)) unsigned-byte (signed-byte 8))
         (signed-byte 8))
        sl::putv8))

(defun sl::putv8 (v index value)        ; CSL
  (setf (aref v index) value))

(declaim
 (inline sl::getv16)
 (ftype (cl:function ((simple-array (signed-byte 16) (*)) unsigned-byte)
                     (signed-byte 16))
        sl::getv16))

(defun sl::getv16 (v index)             ; CSL
  (aref v index))

(declaim
 (inline sl::mkvect16)
 (ftype (cl:function (unsigned-byte) (simple-array (signed-byte 16) (*)))
        sl::mkvect16))

(defun sl::mkvect16 (uplim)             ; CSL
  "Make a vector of 16-bit signed integers, cf. mkvect."
  (make-array (1+ uplim) :element-type '(signed-byte 16) :initial-element 0))

(declaim
 (inline sl::putv16)
 (ftype (cl:function
         ((simple-array (signed-byte 16) (*)) unsigned-byte (signed-byte 16))
         (signed-byte 16))
        sl::putv16))

(defun sl::putv16 (v index value)       ; CSL
  (setf (aref v index) value))


;;; Boolean Functions and Conditionals
;;; ==================================

(import 'cl:and :sl)
;; AND([U:any]):extra-boolean noeval, nospread
;; AND evaluates each U until a value of NIL is found or the end of the
;; list is encountered. If a non-NIL value is the last value it is returned,
;; or NIL is returned.
;; FEXPR PROCEDURE AND(U);
;; BEGIN
;;    IF NULL U THEN RETURN NIL;
;; LOOP: IF NULL CDR U THEN RETURN EVAL CAR U
;;       ELSE IF NULL EVAL CAR U THEN RETURN NIL;
;;    U := CDR U;
;;    GO LOOP
;; END;

(import 'cl:cond :sl)
;; COND([U:cond-form]):any noeval, nospread
;; The antecedents of all U's are evaluated in order of their
;; appearance until a non-NIL value is encountered. The consequent
;; of the selected U is evaluated and becomes the value of the
;; COND. The consequent may also contain the special functions GO
;; and RETURN subject to the restraints given for these functions in
;; \"Program Feature Functions\", section 3.7 on page 22. In these
;; cases COND does not have a defined value, but rather an
;; effect. If no antecedent is non-NIL the value of COND is NIL. An
;; error is detected if a U is improperly formed:
;; ***** Improper cond-form as argument of COND

(import 'cl:not :sl)
;; NOT(U:any):boolean eval, spread
;; If U is NIL, return T else return NIL (same as function NULL).
;; EXPR PROCEDURE NOT(U);
;;    U EQ NIL;

(import 'cl:or :sl)
;; OR([U:any]):extra-boolean noeval, nospread
;; U is any number of expressions which are evaluated in order of their
;; appearance. When one is found to be non-NIL it is returned as the
;; value of OR. If all are NIL, NIL is returned.
;; FEXPR PROCEDURE OR(U);
;; BEGIN SCALAR X;
;; LOOP: IF NULL U THEN RETURN NIL
;;        ELSE IF (X := EVAL CAR U) THEN RETURN X;
;;    U := CDR U;
;;    GO LOOP
;; END;


;;; Arithmetic Functions
;;; ====================

;; All floats should be double precision.

(import 'cl:abs :sl)
;; ABS(U:number):number eval, spread
;; Returns the absolute value of its argument.
;; EXPR PROCEDURE ABS(U);
;;    IF LESSP(U, 0) THEN MINUS(U) ELSE U;

(declaim (ftype (cl:function (number) number) sl::add1))

(%defalias sl::add1 cl:1+
  "ADD1(U:number):number eval, spread
Returns the value of U plus 1 of the same type as U (fixed or floating).
EXPR PROCEDURE ADD1(U);
   PLUS2(U, 1);")

(declaim (ftype (cl:function (number number) number) sl::difference))

(%defalias sl::difference cl:-
  "DIFFERENCE(U:number, V:number):number eval, spread
The value U - V is returned.")

;; The Euclidean division property of the integers state that for u, v
;; in Z, v /= 0, there exist a unique quotient q and remainder r such
;; that u = qv + r (0 <= |r| < |v|).

;; In PSL:
;; divide( 5,  3) = ( 1 .  2)
;; divide( 5, -3) = (-1 .  2)
;; divide(-5,  3) = (-1 . -2)
;; divide(-5, -3) = ( 1 . -2)

;; If u and v have the same sign then the quotient q is positive; if u
;; and v have opposite signs then q is negative.  The remainder r has
;; the same sign as u.

;; The following definition agrees with that above:

(declaim (inline sl::divide)
         (ftype (cl:function (number number) cons) sl::divide))

(defun sl::divide (u v)
  "DIVIDE(U:number, V:number):dotted-pair eval, spread
The dotted-pair (quotient . remainder) is returned. The quotient
part is computed the same as by QUOTIENT and the remainder
the same as by REMAINDER. An error occurs if division by zero is
attempted:
***** Attempt to divide by 0 in DIVIDE
EXPR PROCEDURE DIVIDE(U, V);
   (QUOTIENT(U, V) . REMAINDER(U, V));"
  (multiple-value-call #'cons (truncate u v)))

(declaim (inline sl::expt)
         (ftype (cl:function (number number) number) sl::expt))

(defun sl::expt (u v)
  "EXPT(U:number, V:integer):number eval, spread
Returns U raised to the V power. A floating point U to an integer
power V does not have V changed to a floating number before
exponentiation."
  ;; The REDUCE definition is more general; see above type declamation!
  #+CLISP (ext:without-floating-point-underflow (cl:expt u v))
  #-CLISP (cl:expt u v))

;; Prevent use of the definition of expt in "arith/math.red":
(flag '(sl::expt) 'sl::lose)

(declaim (inline sl::fix)
         (ftype (cl:function (number) integer) sl::fix))

(defun sl::fix (u)
  "FIX(U:number):integer eval, spread
Returns an integer which corresponds to the truncated value of U.
The result of conversion must retain all significant portions of U. If
U is an integer it is returned unchanged."
  (values (truncate u)))

(declaim (inline float)
         (ftype (cl:function (number) double-float) float))

(export 'float)                         ; used internally

(defun float (u)
  "FLOAT(U:number):floating eval, spread
The floating point number corresponding to the value of the
argument U is returned.  Some of the least significant digits of
an integer may be lost do to the implementation of floating point
numbers.  FLOAT of a floating point number returns the number
unchanged.  If U is too large to represent in floating point an
error occurs:
***** Argument to FLOAT is too large"
  ;; Floats must be double precision:
  (cl:float u 1d0))

(declaim (ftype (cl:function (number number) boolean)
                sl::greaterp sl::lessp sl::geq sl::leq))

(%defalias sl::greaterp cl:>
  "GREATERP(U:number, V:number):boolean eval, spread
Returns T if U is strictly greater than V, otherwise returns NIL.")

(%defalias sl::lessp cl:<
  "LESSP(U:number, V:number):boolean eval, spread
Returns T if U is strictly less than V, otherwise returns NIL.")

;; The definitions of geq and leq in "rlisp/rsupport.red" don't work
;; correctly on CL with mixed integer and float arguments, and these
;; definitions should be a bit faster:
(%defalias sl::geq cl:>=)
(%defalias sl::leq cl:<=)
;; Flagged lose in "clprolo.red".

;; The function neq is defined in "rlisp/rsupport.red", but this
;; definition should be a bit faster:
(declaim (inline sl::neq)
         (ftype (cl:function (t t) boolean) sl::neq))

(defun sl::neq (u v) (not (equal u v))) ; use SL equal!

(flag '(sl::neq) 'sl::lose)

(import 'cl:max :sl)
;; MAX([U:number]):number noeval, nospread, or macro
;; Returns the largest of the values in U. If two or more values are the
;; same the first is returned.
;; MACRO PROCEDURE MAX(U);
;;    EXPAND(CDR U, 'MAX2);

(declaim (ftype (cl:function (number number) number) sl::max2 sl::min2))

(%defalias sl::max2 cl:max
  "MAX2(U:number, V:number):number eval, spread
Returns the larger of U and V. If U and V are the same value U is
returned (U and V might be of different types).
EXPR PROCEDURE MAX2(U, V);
   IF LESSP(U, V) THEN V ELSE U;")

(import 'cl:min :sl)
;; MIN([U:number]):number noeval, nospread, or macro
;; Returns the smallest of the values in U. If two or more values are the
;; same the first of these is returned.
;; MACRO PROCEDURE MIN(U);
;;    EXPAND(CDR U, 'MIN2);

(%defalias sl::min2 cl:min
  "MIN2(U:number, V:number):number eval, spread
Returns the smaller of its arguments. If U and V are the same value,
U is returned (U and V might be of different types).
EXPR PROCEDURE MIN2(U, V);
   IF GREATERP(U, V) THEN V ELSE U;")

(declaim (ftype (cl:function (number) number) sl::minus))

(%defalias sl::minus cl:-
  "MINUS(U:number):number eval, spread
Returns -U.
EXPR PROCEDURE MINUS(U);
   DIFFERENCE(0, U);")

(declaim (ftype (cl:function (&rest number) number) sl::plus))

(%defalias sl::plus cl:+
  "PLUS([U:number]):number noeval, nospread, or macro
Forms the sum of all its arguments.
MACRO PROCEDURE PLUS(U);
   EXPAND(CDR U, 'PLUS2);")

(declaim (ftype (cl:function (number number) number)
                sl::plus2 sl::quotient sl::remainder))

(%defalias sl::plus2 cl:+
  "PLUS2(U:number, V:number):number eval, spread
Returns the sum of U and V.")

(declaim (inline sl::quotient))

(defun sl::quotient (u v)
  "QUOTIENT(U:number, V:number):number eval, spread
The quotient of U divided by V is returned. Division of two positive
or two negative integers is conventional. When both U and V are
integers and exactly one of them is negative the value returned is
the negative truncation of the absolute value of U divided by the
absolute value of V. An error occurs if division by zero is attempted:
***** Attempt to divide by 0 in QUOTIENT"
  ;; Could perhaps implement this better using generic functions!
  (if (or (floatp u) (floatp v))
      #+CLISP (ext:without-floating-point-underflow (/ u v))
      #-CLISP (/ u v)
      (values (truncate u v))))

(%defalias sl::remainder cl:rem
  "REMAINDER(U:number, V:number):number eval, spread
If both U and V are integers the result is the integer remainder of
U divided by V. If either parameter is floating point, the result is
the difference between U and V*(U/V) all in floating point. If either
number is negative the remainder is negative. If both are positive or
both are negative the remainder is positive. An error occurs if V is
zero:
***** Attempt to divide by 0 in REMAINDER
EXPR PROCEDURE REMAINDER(U, V);
   DIFFERENCE(U, TIMES2(QUOTIENT(U, V), V));")

(declaim (ftype (cl:function (number) number) sl::sub1))

(%defalias sl::sub1 cl:1-
  "SUB1(U:number):number eval, spread
Returns the value of U less 1. If U is a FLOAT type number, the
value returned is U less 1.0.
EXPR PROCEDURE SUB1(U);
   DIFFERENCE(U, 1);")

(declaim (ftype (cl:function (&rest number) number) sl::times))

#+CLISP
(progn
  (declaim (inline sl::times))
  (defun sl::times (&rest args)
    "TIMES([U:number]):number noeval, nospread, or macro
Returns the product of all its arguments.
MACRO PROCEDURE TIMES(U);
   EXPAND(CDR U, 'TIMES2);"
    (ext:without-floating-point-underflow (cl:apply #'* args))))

#-CLISP
(%defalias sl::times cl:*
  "TIMES([U:number]):number noeval, nospread, or macro
Returns the product of all its arguments.
MACRO PROCEDURE TIMES(U);
   EXPAND(CDR U, 'TIMES2);")

(declaim (ftype (cl:function (number number) number) sl::times2))

(%defalias sl::times2 cl:*
  "TIMES2(U:number, V:number):number eval, spread
Returns the product of U and V.")

;; Small integer (fixnum) arithmetic operators defined in
;; alg/farith.red:

(declaim (inline sl::iplus2 sl::itimes2)
         (ftype (cl:function (fixnum fixnum) fixnum)
                sl::iplus2 sl::itimes2))

(defun sl::iplus2 (u v) (+ u v))

(defun sl::itimes2 (u v) (* u v))

(declaim (inline sl::isub1 sl::iadd1 sl::iminus)
         (ftype (cl:function (fixnum) fixnum)
                sl::isub1 sl::iadd1 sl::iminus))

(defun sl::isub1 (u) (1- u))

(defun sl::iadd1 (u) (1+ u))

(defun sl::iminus (u) (- u))

(declaim (inline sl::idifference sl::iquotient sl::iremainder)
         (ftype (cl:function (fixnum fixnum) fixnum)
                sl::idifference sl::iquotient sl::iremainder))

(defun sl::idifference (u v) (- u v))

(defun sl::iquotient (u v) (values (truncate u v)))

(defun sl::iremainder (u v) (rem u v))

(declaim (inline sl::igreaterp sl::ilessp)
         (ftype (cl:function (fixnum fixnum) boolean)
                sl::igreaterp sl::ilessp))

(defun sl::igreaterp (u v) (> u v))

(defun sl::ilessp (u v) (< u v))

(declaim (inline sl::iminusp)
         (ftype (cl:function (fixnum) boolean) sl::iminusp))

(defun sl::iminusp (u) (cl:minusp u))

;; iequal is defined in CSL (but not PSL).  It is called with a list
;; as its first argument in sqrt2top in int/df2q.red, so it does not
;; always have integer arguments!  But I assume it will not be called
;; with float arguments.

(declaim (ftype (cl:function (t t) boolean) sl::iequal))

(%defalias sl::iequal eql)

;; Small integer (fixnum) arithmetic operators required but not defined:

(declaim (inline sl::itimes)
         (ftype (cl:function (fixnum fixnum) fixnum) sl::itimes))

(defun sl::itimes (u v) (* u v)) ; used as a binary operator in dipoly/torder

(declaim (inline sl::izerop)
         (ftype (cl:function (fixnum) boolean) sl::izerop))

(defun sl::izerop (u) (cl:zerop u))     ; used in plot/plotexp3


;;; Floating Point Math Functions
;;; =============================

(import '(floor ceiling round) :sl)

;; Prevent use of the definitions in "arith/math.red":
(flag '(floor ceiling round) 'sl::lose)

;; Elementary transcendental functions may be called with integer
;; arguments, which are automatically coerced to the lowest precision
;; float type available.  This would lead to loss of precision and
;; type errors.  So explicitly convert the arguments to double-float.

#+LISPMATH
(progn
  (declaim
   (inline sl::sin sl::cos sl::tan sl::asin sl::acos sl::atan sl::atan2
           sl::sinh sl::cosh sl::tanh sl::asinh sl::acosh sl::atanh
           sl::sqrt sl::exp sl::log sl::ln sl::logb)
   (ftype (cl:function (number) double-float)
          sl::sin sl::cos sl::tan sl::asin sl::acos sl::atan
          sl::sinh sl::cosh sl::tanh sl::asinh sl::acosh sl::atanh
          sl::sqrt sl::exp sl::log sl::ln)
   (ftype (cl:function (number number) double-float)
          sl::atan2 sl::logb))

  (defun sl::sin (x) (cl:sin (float x)))
  (defun sl::cos (x) (cl:cos (float x)))
  (defun sl::tan (x) (cl:tan (float x)))
  (defun sl::asin (x) (cl:asin (float x)))
  (defun sl::acos (x) (cl:acos (float x)))
  (defun sl::atan (x) (cl:atan (float x)))
  (defun sl::atan2 (x y) (cl:atan (float x) (float y)))
  (defun sl::sinh (x) (cl:sinh (float x)))
  (defun sl::cosh (x) (cl:cosh (float x)))
  (defun sl::tanh (x) (cl:tanh (float x)))
  (defun sl::asinh (x) (cl:asinh (float x)))
  (defun sl::acosh (x) (cl:acosh (float x)))
  (defun sl::atanh (x) (cl:atanh (float x)))
  (defun sl::sqrt (x) (cl:sqrt (float x)))
  (defun sl::exp (x) (cl:exp (float x)))
  (defun sl::log (x) (cl:log (float x)))
  (defun sl::ln (x) (cl:log (float x)))
  (defun sl::logb (x y) (cl:log (float x) (float y)))

  ;; Prevent use of the definitions in "arith/math.red":
  (flag '(sl::sin sl::cos sl::tan sl::asin sl::acos sl::atan sl::atan2
          sl::sinh sl::cosh sl::tanh sl::asinh sl::acosh sl::atanh
          sl::sqrt sl::exp sl::log sl::ln sl::logb)
        'sl::lose))


;;; Map Composite Functions
;;; =======================

(declaim (inline sl::map sl::mapc)
         (ftype (cl:function (list function) null) sl::map sl::mapc))

(defun sl::map (x fn)
  "MAP(X:list, FN:function):any eval, spread
Applies FN to successive CDR segments of X and returns NIL.
EXPR PROCEDURE MAP(X, FN);
   WHILE X DO << FN X; X := CDR X >>;"
  (cl:mapl fn x)
  nil)

(defun sl::mapc (x fn)
  "MAPC(X:list, FN:function):any eval, spread
Applies FN to successive CAR segments of X and returns NIL.
EXPR PROCEDURE MAPC(X, FN);
   WHILE X DO << FN CAR X; X := CDR X >>;"
  (cl:mapc fn x)
  nil)

(declaim (inline sl::mapcan sl::mapcar sl::mapcon sl::maplist)
         (ftype (cl:function (list function) list)
                sl::mapcan sl::mapcar sl::mapcon sl::maplist))

(defun sl::mapcan (x fn)
  "MAPCAN(X:list, FN:function):any eval, spread
Returns a concatenated list of FN applied to successive CAR elements of X.
EXPR PROCEDURE MAPCAN(X, FN);
   IF NULL X THEN NIL
      ELSE NCONC(FN CAR X, MAPCAN(CDR X, FN));"
  (cl:mapcan fn x))

(defun sl::mapcar (x fn)
  "MAPCAR(X:list, FN:function):any eval, spread
Returns a constructed list of FN applied to each CAR of list X.
EXPR PROCEDURE MAPCAR(X, FN);
   IF NULL X THEN NIL
      ELSE FN CAR X . MAPCAR(CDR X, FN);"
  (cl:mapcar fn x))

(defun sl::mapcon (x fn)
  "MAPCON(X:list, FN:function):any eval, spread
Returns a concatenated list of FN applied to successive CDR segments of X.
EXPR PROCEDURE MAPCON(X, FN);
   IF NULL X THEN NIL
      ELSE NCONC(FN X, MAPCON(CDR X, FN));"
  (cl:mapcon fn x))

(defun sl::maplist (x fn)
  "MAPLIST(X:list, FN:function):any eval, spread
Returns a constructed list of FN applied to successive CDR segments of X.
EXPR PROCEDURE MAPLIST(X, FN);
   IF NULL X THEN NIL
      ELSE FN X . MAPLIST(CDR X, FN);"
  (cl:maplist fn x))


;;; Composite Functions
;;; ===================

;; Common Lisp uses the test function eql by default
;; (see the CLHS 17.2.1 Satisfying a Two-Argument Test,
;; e.g. http://www.lispworks.com/documentation/HyperSpec/Body/17_ba.htm),
;; whereas Standard Lisp uses the test function equal, which must
;; therefore always be supplied to CL functions as the :test keyword
;; argument.

(declaim (inline sl::append)
         (ftype (cl:function (t t) t) sl::append))

(defun sl::append (u v)
  "(append U:any V:any):any expr
Returns a constructed list in which the last element of U is followed by the
first element of V. The list U is copied, but V is not."
  ;; Some REDUCE code assumes the PSL definition, which allows U to
  ;; have any type:
  (if (consp u) (cl:append u v) v))

(declaim (ftype (cl:function (t t) list) sl::assoc))

(defun sl::assoc (u v)                  ; PSL definition
  "(assoc U:any V:any): pair, nil expr
If U occurs as the car portion of an element of the a-list V, the pair in which
U occurred is returned, otherwise nil is returned. The function equal is used
to test for equality.
\(de assoc (u v)
  (cond ((not (pairp v)) nil)
        ((and (pairp (car v)) (equal u (caar v))) (car v))
        (t (assoc u (cdr v)))))"
  (and (consp v)
       (loop for x in v do
             (if (and (consp x) (equal u (car x)))
                 (return x)))))

(declaim (ftype (cl:function (list symbol) list) sl::deflist))

(defun sl::deflist (u ind)
  "DEFLIST(U:dlist, IND:id):list eval, spread
A \"dlist\" is a list in which each element is a two element list: (ID:id
PROP:any). Each ID in U has the indicator IND with property
PROP placed on its property list by the PUT function. The value
of DEFLIST is a list of the first elements of each two element list.
Like PUT, DEFLIST may not be used to define functions.
EXPR PROCEDURE DEFLIST(U, IND);
   IF NULL U THEN NIL
      ELSE << PUT(CAAR U, IND, CADAR U);
              CAAR U >> . DEFLIST(CDR U, IND);"
  (cl:mapcar #'(lambda (x)
                 (if *defn (%save-plist (car x)))
                 (put (car x) ind (cadr x))
                 (car x))
             u))

(declaim (inline sl::delete)
         (ftype (cl:function (t list) list) sl::delete))

(defun sl::delete (u v)
  "DELETE(U:any, V:list):list eval, spread
Returns V with the first top level occurrence of U removed from it.
EXPR PROCEDURE DELETE(U, V);
   IF NULL V THEN NIL
      ELSE IF CAR V = U THEN CDR V
      ELSE CAR V . DELETE(U, CDR V);"
  (cl:remove u v :test #'equal :count 1))

(declaim (ftype (cl:function (t) boolean) digit))

(export 'digit)                         ; used internally

(defun digit (u)
  "DIGIT(U:any):boolean eval, spread
Returns T if U is a digit, otherwise NIL.
EXPR PROCEDURE DIGIT(U);
   IF MEMQ(U, '(!0 !1 !2 !3 !4 !5 !6 !7 !8 !9))
      THEN T ELSE NIL;"
  (handler-case (not (not (digit-char-p (character u))))
    (cl:error () nil)))

(declaim (ftype (cl:function (t) (integer 0)) sl::length))

(defun sl::length (x)
  "LENGTH(X:any):integer eval, spread
The top level length of the list X is returned.
EXPR PROCEDURE LENGTH(X);
   IF ATOM X THEN 0
      ELSE PLUS(1, LENGTH CDR X);"
  ;; The above recursive definition uses too much stack.
  ;; The CL length function cannot be used because it does not accept
  ;; atoms or improper lists (with a non-nil final cdr)!
  ;; This iterative implementation is based on the description of
  ;; list-length in the CLHS:
  (do ((n 0 (1+ n))                     ; counter
       (p x (cdr p)))                   ; pointer
      ;; When pointer hits an atom, return the count:
      ((atom p) n)))

(declaim (ftype (cl:function (t) boolean) sl::liter))

(defun sl::liter (u)
  "LITER(U:any):boolean eval, spread
Returns T if U is a character of the alphabet, NIL otherwise.
EXPR PROCEDURE LITER(U);
   IF MEMQ(U, '(!A !B !C !D !E !F !G !H !I !J !K !L !M
                !N !O !P !Q !R !S !T !U !V !W !X !Y !Z
                !a !b !c !d !e !f !g !h !i !j !k !l !m
                !n !o !p !q !r !s !t !u !v !w !x !y !z))
      THEN T ELSE NIL;"
  (handler-case (alpha-char-p (character u))
    (cl:error () nil)))

(declaim (ftype (cl:function (t t) list) sl::member sl::memq))

(defun sl::member (a l)
  "(member A:any L:any): extra-boolean expr
Returns nil if A is not equal to some top level element of the list L;
otherwise it returns the remainder of L whose first element is equal
to A."
  ;; This is the PSl definition, which accepts *anything* as its second argument!
  ;; REDUCE (crack in particular) requires this flexibility.
  ;; The second argument to Common Lisp member must be a proper list.
  ;; (cond ((atom l) nil)
  ;;       ((equal a (car l)) l)
  ;;       (t (member a (cdr l))))
  (loop for tail on l do
        (when (atom tail) (return))
        (when (equal a (car tail)) (return tail))))

(declaim (inline sl::memq))

(defun sl::memq (a l)
  "(memq A:any L:any): extra-boolean expr
Returns nil if A is not eq to some top level element of the list L;
otherwise it returns the remainder of L whose first element is equal
to A."
  ;; This is the PSl definition, which accepts *anything* as its second argument!
  ;; REDUCE probably requires this flexibility.
  ;; The second argument to Common Lisp member must be a proper list.
  ;; (cond ((atom l) nil)
  ;;       ((eq a (car l)) l)
  ;;       (t (memq a (cdr l))))
  (and (consp l) (cl:member a l :test #'cl:eq)))

(import 'cl:nconc :sl)
;; NCONC(U:list, V:list):list eval, spread
;; Concatenates V to U without copying U. The last CDR of U is
;; modified to point to V.
;; EXPR PROCEDURE NCONC(U, V);
;; BEGIN SCALAR W;
;;    IF NULL U THEN RETURN V;
;;    W := U;
;;    WHILE CDR W DO W := CDR W;
;;    RPLACD(W, V);
;;    RETURN U
;; END;

(declaim (ftype (cl:function (list list) list) sl::pair))

(defun sl::pair (u v)
  ;; Could implement as pairlis, but pairlis doesn't guarantee the
  ;; ordering in the result list.
  "PAIR(U:list, V:list):alist eval, spread
U and V are lists which must have an identical number of elements.
If not, an error occurs (the 000 used in the ERROR call is arbitrary
and need not be adhered to). Returned is a list where each element
is a dotted-pair, the CAR of the pair being from U, and the CDR
the corresponding element from V.
EXPR PROCEDURE PAIR(U, V);
   IF AND(U, V) THEN (CAR U . CAR V) . PAIR(CDR U, CDR V)
      ELSE IF OR(U, V) THEN ERROR(000,
         \"Different length lists in PAIR\")
      ELSE NIL;"
  (if (/= (cl:length u) (cl:length v))
      (%error "Different length lists in PAIR")
      (cl:map 'list #'cons u v)))

(declaim (ftype (cl:function (list) list) sl::reverse))

(defun sl::reverse (u)
  "REVERSE(U:list):list eval, spread
Returns a copy of the top level of U in reverse order.
EXPR PROCEDURE REVERSE(U);
BEGIN SCALAR W;
   WHILE U DO << W := CAR U . W;
                 U := CDR U >>;
   RETURN W
END;"
  ;; Must accept an improper (i.e. dotted) list or an atom!
  (do (w) ((atom u) w)
    (setq w (cons (car u) w)
          u (cdr u))))

(declaim (ftype (cl:function (list) list)  sl::reversip))

(%defalias sl::reversip cl:nreverse)       ; PSL function

(declaim (ftype (cl:function (t list (function ())) t) sl::sassoc))

(defun sl::sassoc (u v fn)
  "SASSOC(U:any, V:alist, FN:function):any eval, spread
Searches the alist V for an occurrence of U. If U is not in the alist
the evaluation of function FN is returned.
EXPR PROCEDURE SASSOC(U, V, FN);
   IF NULL V THEN FN()
      ELSE IF U = CAAR V THEN CAR V
      ELSE SASSOC(U, CDR V, FN);"
  (or (cl:assoc u v :test #'equal) (funcall fn)))

(declaim (ftype (cl:function (list function) list)  sl::sort))

;; (import 'cl:sort :sl)                       ; CSL function
(%defalias sl::sort cl:sort)
;; Defined this way so that it can be redefined in "rtools/sort.red"
;; because this is what happens with CSL and PSL!  (The function sort
;; is built into CSL and for PSL it is defined as an alias for gsort
;; in "pslrend.red".)

(declaim (inline sl::sublis sl::subla)
         (ftype (cl:function (list t) t) sl::sublis sl::subla))

(defun sl::sublis (x y)
  "SUBLIS(X:alist, Y:any):any eval, spread
The value returned is the result of substituting the CDR of each
element of the alist X for every occurrence of the CAR part of that
element in Y.
EXPR PROCEDURE SUBLIS(X, Y);
   IF NULL X THEN Y
      ELSE BEGIN SCALAR U;
                 U := ASSOC(Y, X);
                 RETURN IF U THEN CDR U
                        ELSE IF ATOM Y THEN Y
                        ELSE SUBLIS(X, CAR Y) .
                             SUBLIS(X, CDR Y)
                 END;"
  (cl:sublis x y :test #'equal))

(defun sl::subla (x y)                  ; PSL function
  "Eq version of sublis; replaces atoms only."
  (cl:sublis x y :test #'eq))

(declaim (inline sl::subst)
         (ftype (cl:function (t t t) t) sl::subst))

(defun sl::subst (u v w)
  "SUBST(U:any, V:any, W:any):any eval, spread
The value returned is the result of substituting U for all occurrences
of V in W.
EXPR PROCEDURE SUBST(U, V, W);
   IF NULL W THEN NIL
      ELSE IF V = W THEN U
      ELSE IF ATOM W THEN W
      ELSE SUBST(U, V, CAR W) . SUBST(U, V, CDR W);"
  (cl:subst u v w :test #'equal))

;; This function is used in several places in REDUCE, but I can't find
;; a reference to it anywhere!  The documentation string below is
;; based on that in Emacs Lisp:
(declaim (inline sl::rassoc)
         (ftype (cl:function (t list) list) sl::rassoc))

(defun sl::rassoc (key list)
  "Return non-nil if KEY is equal to the cdr of an element of LIST.
The value is actually the first element of LIST whose cdr equals KEY."
  (cl:rassoc key list :test #'equal))


;;; The Interpreter
;;; ===============

;; In "alg/reval.red" is the code
;; deflist('( ... (!*sq (lambda (x) nil))),'rtypefn);
;; which leads in "alg/elem.red" to (apply (lambda (x) nil) (!*sq ...))
;; and this fails in Common Lisp because a lambda form is not a function!
;; It might be better to add the function call to the code in reval,
;; but try this for now...

;; (defun %lam2fn (fn)
;;   "Make a lambda expression acceptable as a function by evaluating it."
;;   (declare ((or list function) fn))
;;   (the function (if (eqcar fn 'lambda) (eval fn) fn)))

;; (defun apply (fn args)
;;   "Treat a lambda expression as an operator.
;; Otherwise revert to the Common Lisp apply."
;;   (cl:apply (%lam2fn fn) args))

(declaim (inline sl::apply)
         (ftype (cl:function (function list) t) sl::apply))

(defun sl::apply (fn args)
  "Treat a lambda expression as an operator.
Otherwise revert to the Common Lisp apply."
  (cl:apply (coerce fn 'cl:function) args))

;; APPLY(FN:{id,function}, ARGS:any-list):any eval, spread
;; APPLY returns the value of FN with actual parameters ARGS. The
;; actual parameters in ARGS are already in the form required for
;; binding to the formal parameters of FN. Implementation specific
;; portions described in English are enclosed in boxes.
;; EXPR PROCEDURE APPLY(FN, ARGS);
;; BEGIN SCALAR DEFN;
;;    IF CODEP FN THEN RETURN
;;       | Spread the actual parameters in ARGS
;;    | following the conventions: for calling
;;    | functions, transfer to the entry point
;;    | of the function, and return the value
;;    | returned by the function.;
;;    IF IDP FN THEN RETURN
;;    IF NULL(DEFN := GETD FN) THEN
;;       ERROR(000, LIST(FN, \"is an undefined function\"))
;;    ELSE IF CAR DEFN EQ 'EXPR THEN
;;       APPLY(CDR DEFN, ARGS)
;;    ELSE ERROR(000,
;;       LIST(FN, \"cannot be evaluated by APPLY\"));
;;    IF OR(ATOM FN, NOT(CAR FN EQ 'LAMBDA)) THEN
;;       ERROR(000,
;;          LIST(FN, \"cannot be evaluated by APPLY\"));
;;    RETURN
;;       | Bind the actual parameters in ARGS to
;;       | the formal parameters of the lambda
;;       | expression. If the two lists are not
;;       | of equal length then ERROR(000, \"Number
;;       | of parameters do not match\"); The value
;;       | returned is EVAL CADDR FN.
;; END;

(declaim (inline evlis)
         (ftype (cl:function (list) list) evlis))

(export 'evlis)                         ; used internally

(defun evlis (u)
  "EVLIS(U:any-list):any-list eval, spread
EVLIS returns a list of the evaluation of each element of U.
EXPR PROCEDURE EVLIS(U);
   IF NULL U THEN NIL
      ELSE EVAL CAR U . EVLIS CDR U;"
  (cl:mapcar #'eval u))

(declaim (ftype (cl:function (t) t) eval))

(export 'eval)                          ; used internally

(defun eval (u)
  "Treat (function foo) the same as the operator foo.
Otherwise revert to the Common Lisp eval."
  (if (and (consp u) (functionp (car u)))
      (cl:apply (car u) (evlis (cdr u)))
      (cl:eval u)))

;; EVAL(U:any):any eval, spread
;; The value of the expression U is computed. Error numbers are
;; arbitrary. Portions of EVAL involving machine specific coding are
;; expressed in English enclosed in boxes.
;; EXPR PROCEDURE EVAL(U);
;; BEGIN SCALAR FN;
;;    IF CONSTANTP U THEN RETURN U;
;;    IF IDP U THEN RETURN
;;       | U is an id. Return the value most
;;       | currently bound to U or if there
;;       | is no such binding: ERROR(000,
;;       | LIST(\"Unbound:\", U));
;;    IF PAIRP CAR U THEN RETURN
;;    IF CAAR U EQ 'LAMBDA THEN APPLY(CAR U, EVLIS CDR U)
;;    ELSE ERROR(000, LIST(CAR U,
;;       \"improperly formed LAMBDA expression\"))
;;    ELSE IF CODEP CAR U THEN
;;       RETURN APPLY(CAR U, EVLIS CDR U);
;;    FN := GETD CAR U;
;;    IF NULL FN THEN
;;       ERROR(000, LIST(CAR U, \"is an undefined function\"))
;;    ELSE IF CAR FN EQ 'EXPR THEN
;;       RETURN APPLY(CDR FN, EVLIS CDR U)
;;    ELSE IF CAR FN EQ 'FEXPR THEN
;;       RETURN APPLY(CDR FN, LIST CDR U)
;;    ELSE IF CAR FN EQ 'MACRO THEN
;;       RETURN EVAL APPLY(CDR FN, LIST U)
;; END;

(declaim (ftype (cl:function (cons function) t) expand))

(export 'expand)                        ; recursive

(defun expand (l fn)
  "EXPAND(L:list, FN:function):list eval, spread
FN is a defined function of two arguments to be used in the expansion
of a MACRO. EXPAND returns a list in the form:
   (FN L0 (FN L1 ... (FN Ln-1 Ln) ... ))
where n is the number of elements in L, Li is the ith element of L.
EXPR PROCEDURE EXPAND(L,FN);
   IF NULL CDR L THEN CAR L
      ELSE LIST(FN, CAR L, EXPAND(CDR L, FN));"
  ;; NB: This function need not return a list, since CAR L may be
  ;; anything!
  (if (null (cdr l))
      (car l)
      (list fn (car l) (expand (cdr l) fn))))

(defmacro sl::function (fn)
  "FUNCTION(FN:function):function noeval, nospread
The function FN is to be passed to another function. If FN is to have
side effects its free variables must be fluid or global. FUNCTION is
like QUOTE but its argument may be affected by compilation. We
do not consider FUNARGs in this report."
  ;; In Common Lisp, fn must be a *defined* function or a lambda
  ;; expression.  The symbol car satisfies fboundp and (lambda ...)
  ;; satisfies functionp, so
  ;; (if (or (eqcar fn 'lambda) (fboundp `,fn))
  ;; But with the test above, the eds package will not build because
  ;; (function list) evaluates to #<FUNCTION LIST>, which cannot be
  ;; serialized so faslout fails.  At least temporarily, this should
  ;; work:
  (if (eqcar fn 'lambda)
      `(cl:function ,fn)
      `(cl:quote ,fn)))

(import 'cl:quote :sl)
;; QUOTE(U:any):any noeval, nospread
;; Stops evaluation and returns U unevaluated.
;; FEXPR PROCEDURE QUOTE(U);
;;    CAR U;


;;; Input and Output
;;; ================

;; An output filehandle is a (possibly dotted) list of the form
;; ('file output-stream) or ('pipe output-stream . process).
;; On CLISP, process is nil.

;; An input filehandle is a pair of the form
;; (input-stream . echo-stream).

;; Filehandles should probably be structures rather than lists!

(declaim (ftype (cl:function (filehandle) filehandle) sl::close))

(defun sl::close (filehandle)
  "CLOSE(FILEHANDLE:any):any eval, spread
Closes the file with the internal name FILEHANDLE writing any
necessary end of file marks and such. The value of FILEHANDLE
is that returned by the corresponding OPEN. The value returned is
the value of FILEHANDLE. An error occurs if the file can not be
closed.
***** FILEHANDLE could not be closed"
  ;; A null filehandle represents standard IO; ignore it.
  (if filehandle
      (prog1 filehandle
        (case (car filehandle)
          (sl::file
           ;; Output file stream ('file output-stream):
           (cl:close (cadr filehandle)))
          #+SBCL
          (sl::pipe
           ;; Output pipe stream ('pipe output-stream . process):
           (sb-ext:process-close (cddr filehandle)) ; closes output-stream
           (sb-ext:process-kill (cddr filehandle) 9)) ; 9 = SIGKILL
          #+CLISP
          (sl::pipe
           ;; Output pipe stream ('pipe output-stream):
           (cl:close (cadr filehandle))) ; closes output-stream
          (t
           ;; Input filehandle -- close echo stream then input stream:
           (cl:close (cdr filehandle))
           (cl:close (car filehandle)))))))

(declaim (ftype (cl:function () null) sl::eject))

(defun sl::eject ()
  "EJECT():NIL eval, spread
Skip to the top of the next output page. Automatic EJECTs are
executed by the print functions when the length set by the PAGE-
LENGTH function is exceeded."
  nil)

(defvar %linelength% 80
  "Current Standard LISP line length accessed via function `LINELENGTH'.")

(declaim (ftype (cl:function ((or fixnum null)) fixnum) sl::linelength))

(defun sl::linelength (len)
  "LINELENGTH(LEN:{integer, NIL}):integer eval, spread
If LEN is an integer the maximum line length to be printed before
the print functions initiate an automatic TERPRI is set to the value
LEN. No initial Standard LISP line length is assumed. The previous
line length is returned except when LEN is NIL. This special case
returns the current line length and does not cause it to be reset. An
error occurs if the requested line length is too large for the currently
selected output file or LEN is negative or zero.
***** LEN is an invalid line length"
  (if len
      (if #|(or (not (integerp len))|# (<= len 0);)
          (%error "~a is an invalid line length" len)
          (prog1 %linelength% (setq %linelength% len)))
      %linelength%))

(declaim (ftype (cl:function () fixnum) sl::lposn))

(defun sl::lposn ()
  "LPOSN():integer eval, spread
Returns the number of lines printed on the current page. At the top
of a page, 0 is returned."
  0)

(declaim (ftype (cl:function (simple-string &optional boolean) pathname)
                %tidy-pathname))

(defun %tidy-pathname (path-string &optional ensure-dir)
  "Return the full pathname of PATH-STRING (which need not exist).
If the first component of PATH-STRING is an environment variable of
the form `$name' then replace it by its value, which need not end with
a directory separator.  On MS Windows, directory separators can be
either \ or /.  If ENSURE-DIR is non-nil then ensure that PATH-STRING
represents a directory (by appending a directory separator if
necessary).  Called by `open', `cd', `filep', `file-write-date'."
  #+(or WIN32 CYGWIN) ;; convert \ to /:
  (setq path-string (substitute #\/ #\\ path-string))
  (when ensure-dir
    ;; Ensure directory by ensuring trailing /:
    (when (char/= (schar path-string (1- (cl:length path-string))) #\/)
      (setq path-string (concatenate 'string path-string "/"))))
  (let* ((path-pathname
          #+SBCL (sb-ext:native-pathname path-string)
          #-SBCL (pathname path-string)
          )
         (dir (pathname-directory path-pathname))
         root)
    (when (and (consp dir)
               (eq (car dir) :relative)         ; relative filename
               (stringp (setq root (cadr dir))) ; root := root component
               (char= (schar root 0) #\$)       ; root start with $
               (setq root (getenv (subseq root 1)))) ; root := new root
      #+(or WIN32 CYGWIN) ;; convert \ to /:
      (setq root (substitute #\/ #\\ root))
      ;; Ensure trailing /:
      (when (char/= (schar root (1- (cl:length root))) #\/)
        (setq root (concatenate 'string root "/")))
      (setq root                        ; root as pathname
            #+SBCL (sb-ext:native-namestring root)
            #-SBCL (pathname root)
            dir                         ; new full directory
            (cl:append (pathname-directory root) (cddr dir))
            path-pathname               ; new full pathname
            (make-pathname
             :device (pathname-device root)
             :directory dir :defaults path-pathname)))
    path-pathname))

;; CLISP user variable CUSTOM:*DEVICE-PREFIX* controls translation
;; between Cygwin pathnames (e.g., #P"/cygdrive/c/gnu/clisp/") and
;; native Win32 pathnames (e.g., #P"C:\\gnu\\clisp\\").

(declaim (ftype (cl:function (simple-string symbol) filehandle) sl::open))

(defun sl::open (file how)
  "OPEN(FILE:any, HOW:id):any eval, spread
Open the file with the system dependent name FILE for output if
HOW is EQ to OUTPUT, or input if HOW is EQ to INPUT. If the
file is opened successfully, a value which is internally associated with
the file is returned. This value must be saved for use by RDS and
WRS. An error occurs if HOW is something other than INPUT or
OUTPUT or the file can't be opened.
***** HOW is not option for OPEN
***** FILE could not be opened"
  (case how
    (sl::input
     (let ((fh (cl:open (%tidy-pathname file) :direction :input)))
       ;; An input filehandle is a pair of the form
       ;; (input-stream . echo-stream):
       (cons fh (make-echo-stream fh *standard-output*))))
    (sl::output
     (list 'sl::file
           (cl:open (%tidy-pathname file) :direction :output
                    :if-exists :supersede :if-does-not-exist :create)))
    (t (%error "~a is not option for OPEN" how))))

(declaim (inline sl::pagelength)
         (ftype (cl:function (integer) null) sl::pagelength))

(defun sl::pagelength (len)
  (declare (ignore len))
  "PAGELENGTH(LEN:{integer, NIL}):integer eval, spread
Sets the vertical length (in lines) of an output page. Automatic page
EJECTs are executed by the print functions when this length is
reached. The initial vertical length is implementation specific. The
previous page length is returned. If LEN is 0, no automatic page
ejects will occur."
  nil)

(defconstant %tab-width% 8
  "Outputting a Tab character increments `%posn%' to the next integer
multiple of `%tab-width%'.")

(defvar %posn% 0
  "Number of characters in the current line output by Standard LISP.
Except that Tab increments `%posn%' the next integer multiple of
`%tab-width%', and Newline resets `%posn%' to 0.
Set by the functions `%prin-string', `terpri' and `readch'.
Accessed (read-only) via the function `posn'.
It's value should be between 0 and `%linelength%' inclusive.")

(declaim (inline sl::posn)
         (ftype (cl:function () fixnum) sl::posn))

(defun sl::posn ()
  "POSN():integer eval, spread
Returns the number of characters in the output buffer. When the
buffer is empty, 0 is returned."
  %posn%)

(defvar %prin-space-maybe% nil
  "True if there is a pending space to print.")

(declaim (inline %prin-space-maybe)
         (ftype (cl:function () boolean) %prin-space-maybe))

(defun %prin-space-maybe ()
  "Record that a space should be printed and return t unless at the
beginning of a line."
  (when (> %posn% 0)
    (setq %prin-space-maybe% t)))

(declaim (ftype (cl:function (simple-string) null) %prin-string))

(defun %prin-string (s)
  "Print string S preceded by a newline or space if necessary.
Check and update `%posn%' to keep it <= `%linelength%'.
This is the only function that actually produces graphical output.
(S already contains any ! escape characters required.)"
  ;; This code is designed to reproduce the output in
  ;; "regressions/2011-08-31-linelength.rlg", but without visibly
  ;; overflowing!
  (let ((len (cl:length s)) overflowed)
    (when %prin-space-maybe% (incf %posn%))
    ;; Compute %posn% AFTER printing S here to determine whether to
    ;; break the line:
    (do ((i 0 (1+ i)))
        ((= i len))
      (case (schar s i)
        (#\Tab           ; invisible, so no overflow (same for Space?)
         (setq %posn% (* (1+ (floor %posn% %tab-width%)) %tab-width%)))
        (#\Newline
         (when (> (1+ %posn%) %linelength%) (setq overflowed t))
         (setq %posn% 0))
        (otherwise
         (when (> (incf %posn%) %linelength%) (setq overflowed t)))))
    (if overflowed
        (progn
          (cl:terpri) (setq %posn% 0)
          ;; Re-compute %posn% AFTER printing S here because the effect
          ;; of Tabs will have changed:
          (do ((i 0 (1+ i)))
              ((= i len))
            (case (schar s i)
              (#\Tab (setq %posn% (* (1+ (floor %posn% %tab-width%)) %tab-width%)))
              (#\Newline (setq %posn% 0))
              (otherwise (incf %posn%)))))
        (when %prin-space-maybe% (write-char #\Space)))
    (setq %prin-space-maybe% nil)
    (write-string s))
  nil)

;; PRINC(U:id):id eval, spread
;; U must be a single character id such as produced by EXPLODE or
;; read by READCH or the value of !$EOL!$. The effect is the character
;; U displayed upon the currently selected output device. The value of
;; !$EOL!$ causes termination of the current line like a call to TERPRI.

;; The SL definition of PRINC is not used in REDUCE since PRINC is
;; redefined in rlisp/rsupport.red as
;; symbolic procedure princ u; prin2 u;
;; so define it that way below and then flag it lose in clprolo.red.

(declaim (inline terpri)
         (ftype (cl:function () null) terpri))

(export 'terpri)                        ; used internally

(defun terpri ()
  "TERPRI():NIL
The current print line is terminated."
  (setq %posn% 0) (cl:terpri) nil)

(declaim (inline print)
         (ftype (cl:function (t) t) print))

(export 'print)                         ; used internally

(defun print (u)
  "PRINT(U:any):any eval, spread
Displays U in READ readable format and terminates the print line.
The value of U is returned.
EXPR PROCEDURE PRINT(U);
<< PRIN1 U; TERPRI(); U >>;"
  (prin1 u) (terpri) u)

(declaim (ftype (cl:function (t) t) prin1 prin2  sl::princ))

(export 'prin1)                         ; used internally

(defun prin1 (u)
  "PRIN1(U:any):any eval, spread
U is displayed in a READ readable form. The format of display is the
result of EXPLODE expansion; special characters are prefixed with the
escape character !, and strings are enclosed in \"...\".  Lists are
displayed in list-notation and vectors in vector-notation.  The value
of U is returned."
  (typecase u
    (symbol (%prin-string (%prin1-id-to-string u)))
    (string (%prin-string (%prin1-string-to-string u)))
    (cl:float (%prin-string (%prin-float-to-string u)))
    (vector (%prin-vector u #'prin1))
    (atom (%prin-string (prin1-to-string u)))
    ;; ((eq (car u) 'quote) (%prin-string "'") (prin1 (cadr u)))
    ;; CSL doesn't treat quote specially
    (t (%prin-cons u #'prin1)))
  u)

(declaim (inline %princ-id-to-string)
         (ftype (cl:function (symbol) simple-string)
                %princ-id-to-string %prin1-id-to-string))

(defun %princ-id-to-string (u)
  "Convert identifier U to a string without any escapes."
  (%string-invert-case (cl:symbol-name u)))

(export 'prin2)                         ; recursive

(defun prin2 (u)
  "PRIN2(U:any):any eval, spread
U is displayed upon the currently selected print device but output is
not READ readable.  The value of U is returned. Items are displayed as
described in the EXPLODE function with the exceptions that the escape
character does not prefix special characters and strings are not
enclosed in \"...\".  Lists are displayed in list-notation and vectors
in vector-notation.  The value of U is returned."
  (typecase u
    (symbol (%prin-string (%princ-id-to-string u)))
    (string (%prin-string u))
    (cl:float (%prin-string (%prin-float-to-string u)))
    (vector (%prin-vector u #'prin2))
    (atom (%prin-string (princ-to-string u)))
    ;; ((eq (car u) 'quote) (%prin-string "'") (prin2 (cadr u)))
    ;; CSL doesn't treat quote specially
    (t (%prin-cons u #'prin2)))
  u)

(%defalias sl::princ prin2)

(defun %prin1-id-to-string (u)
  "Convert identifier U to a string including appropriate `!' escapes."
  ;; Insert ! before an upper-case letter, leading digit or _, or
  ;; special character (except _):
  (coerce
   (loop with s = (cl:symbol-name u) and c
         for i below (cl:length s)
         do (setq c (aref s i))
         unless (or (upper-case-p c)    ; case-inverted!
                    (and (not (eql i 0))
                         (or (digit-char-p c) (char= c #\_))))
         collect #\!
         collect (%character-invert-case c))
   'string))

(declaim (ftype (cl:function (simple-string) simple-string)
                %prin1-string-to-string))

(defun %prin1-string-to-string (s)
  "Add delimiting \"s and escape internal \"s as \"\" in string S."
  (loop with p = 0 and q and v = (list "\"")
        ;; v must be a new cons to allow destructive reverse
        do
        (setq q (position #\" s :start p))
        (if q (incf q))
        (setq v (cons "\"" (cons (subseq s p q) v))
              p q)
        while q
        finally (return
                  (cl:apply #'concatenate 'string (nreverse v)))))

(declaim (ftype (cl:function (double-float) simple-string)
                %prin-float-to-string))

(defun %prin-float-to-string (u)
  "Print a float to a string, rounded to 6 significant digits."
  ;; Must be able to handle 2.0^1023 and 2.0^(-1022), used in
  ;; "arith/rounded.red", and 1.797e+308, used in
  ;; "regressions/2020-10-25-safe-fp.tst"!
  (if (cl:zerop u) "0.0"
      (let* ((absu (abs u))
             (e (floor (cl:log absu 10d0)))) ; decimal exponent
        ;; |u| = m 10^e, where 0 <= m < 10, so (for e >= 0) the
        ;; integer part of u contains e+1 digits.  To make u
        ;; contain d significant digits, multiply by a scale
        ;; factor s = 10^(d-e-1), round and divide s out again.
        (if (plusp e)
            (setq u (fround (* u (cl:expt 10d0 (- 5 e)))))
            ;; The multiplication by s is done in two steps to avoid
            ;; overflow!
            (setq u (* u (cl:expt 10d0 (- e)))
                  u (fround (* u 1d5))))
        ;; Now u is an integer-valued float with 6 significant digits.
        (if (or (>= absu 999999.5d0) (< absu 0.0001d0))
            ;; Use exponential (e) format, e.g. 9.99999e-05
            (progn
              ;; Special case: if 999999.5 <= absu < 1000000.0
              ;; then it rounds up to 1000000 with 7 significant
              ;; digits!
              (when (eql (abs u) 1d6) (setq u (* u 1d-1)) (incf e))
              ;; Trim up to 4 trailing 0s from mantissa:
              (let* ((m (format nil "~,5f" (* u 1d-5))) ; mantissa string
                     (l (1- (cl:length m)))) ; index of last mantissa digit
                (do ((f l (1- f))) ; index of first 0 to remove (maybe)
                    ((or (char/= (elt m f) #\0)
                         (= (- l f) 4))
                     (when (/= f l) (setq m (subseq m 0 (1+ f))))))
                (if (minusp e)
                    (format nil "~ae-~2,'0d" m (- e))
                    (format nil "~ae+~2,'0d" m e))))
            ;; Use fixed (f) format, e.g. 99999.9
            (format nil "~f" (/ u (cl:expt 10d0 (- 5 e))))))))

(declaim (ftype (cl:function (simple-vector cl:function) null) %prin-vector))

(defun %prin-vector (u prinfn)
  "Print vector U delimited by [ and ] using PRINFN to print each element."
  (loop initially (%prin-string "[") (funcall prinfn (aref u 0))
        for i from 1 below (cl:length u) do
        (%prin-space-maybe) (funcall prinfn (aref u i))
        finally (%prin-string "]"))
  nil)

(declaim (ftype (cl:function (cons cl:function) null) %prin-cons))

(defun %prin-cons (u prinfn)
  "Print cons cell U using PRINFN."
  (%prin-string "(")
  (funcall prinfn (car u))
  (%prin-cdr (cdr u) prinfn)
  (%prin-string ")")
  nil)

(declaim (ftype (cl:function (t cl:function) null) %prin-cdr))

(defun %prin-cdr (u prinfn)
  "If U is non-nil then print it or its elements spaced appropriately.
U is the cdr of a cons cell: nil, an atom or another cons cell.
Cons cell elements are printed using PRINFN."
  (typecase u
    (null)                              ; do nothing
    (atom
     (%prin-space-maybe) (%prin-string ".")
     (%prin-space-maybe) (funcall prinfn u))
    (t (%prin-space-maybe)
       (funcall prinfn (car u))
       (%prin-cdr (cdr u) prinfn)))
  nil)

(declaim (ftype (cl:function () filehandle) %default-read-stream))

(defun %default-read-stream ()
  "The default read stream using the current value of *standard-input*."
  (cons *standard-input* *standard-input*))

(defparameter %default-read-stream% (%default-read-stream)
  "The default read stream using the initial value of *standard-input*.
This must be re-set when Standard Lisp is started to work in a saved
CLISP memory image.")

(defvar %read-stream% %default-read-stream%
  "The current input filehandle: a cons pair of the form
\(input-stream . echo-stream).
This must be re-set when Standard Lisp is started to work in a saved
CLISP memory image.")

(declaim (ftype (cl:function () stream) %read-stream))

(defun %read-stream ()
  "Return the appropriate input stream depending on the value of *echo."
  (or (and *echo (cdr %read-stream%)) (car %read-stream%)))

(declaim (ftype (cl:function (filehandle) filehandle) sl::rds))

(defun sl::rds (filehandle)
  "RDS(FILEHANDLE:any):any eval, spread
Input from the currently selected input file is suspended and
further input comes from the file named. FILEHANDLE is a system
dependent internal name which is a value returned by OPEN. If
FILEHANDLE is NIL the standard input device is selected. When end
of file is reached on a non-standard input device, the standard
input device is reselected. When end of file occurs on the
standard input device the Standard LISP reader terminates. RDS
returns the internal name of the previously selected input file.
***** FILEHANDLE could not be selected for input"
  (prog1
      %read-stream%
    (setq %read-stream%
          (if (and filehandle (open-stream-p (car filehandle)))
              filehandle
              %default-read-stream%))))

(defparameter %sl-readtable% (copy-readtable)
  "Readtable implementing Standard Lisp syntax.
% introduces a comment and ! is the single-escape character.")
;; Cannot redefine *readtable* directly because it would come into
;; effect immediately during a load of the uncompiled file and break
;; the syntax below!
(set-syntax-from-char #\% #\; %sl-readtable%)
(set-syntax-from-char #\; #\A %sl-readtable%)
(set-syntax-from-char #\! #\\ %sl-readtable%)
(set-syntax-from-char #\\ #\A %sl-readtable%)
(set-syntax-from-char #\# #\A %sl-readtable%)
(set-syntax-from-char #\| #\A %sl-readtable%)

(defparameter %string-readtable% (copy-readtable %sl-readtable%)
  "Readtable implementing Standard Lisp string syntax.
No escape characters are defined.")
(set-syntax-from-char #\! #\A %string-readtable%)

;; ***** NEED BETTER HANDLING FOR %CL-READ-STRING! *****

(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf (symbol-function '%cl-read-string)
        (get-macro-character #\" *readtable*)))

(declaim (ftype (cl:function (stream character) simple-string) %sl-read-string))

(defun %sl-read-string (stream closech)
  ;; This accumulates chars until it sees same char that invoked it,
  ;; namely closech. See the function read-string in
  ;; "sbcl-1.4.14/src/code/reader.lisp".
  (let* ((*readtable* %string-readtable%)
         (s (%cl-read-string stream closech)))
    (loop while ;; following character is "
          (char= (peek-char nil stream nil $eof$ t) closech)
          do ;; read and ignore it
          (read-char stream nil $eof$ t)
          ;; then read and concatenate the following string
          (setq s (concatenate 'string s (string closech)
                               (%cl-read-string stream closech))))
    s))

(set-macro-character #\" #'%sl-read-string nil %sl-readtable%)

;; The read functions (rather than open or rds) must select the echo
;; stream dynamically because REDUCE sets *echo AFTER open and rds
;; have been called.  They do this by calling the function
;; %read-stream, which returns either the input stream or the echo
;; stream depending on the value of *echo.

(declaim (ftype (cl:function () t) sl::read))

(defun sl::read ()
  "READ():any
The next expression from the file currently selected for
input. Valid input forms are: vector-notation, dot-notation,
list-notation, numbers, function-pointers, strings, and
identifiers with escape characters. Identifiers are interned on
the OBLIST (see the INTERN function in \"Identifiers\"). READ
returns the value of !$EOF!$ when the end of the currently
selected input file is reached."
  (let ((*readtable* %sl-readtable%))
    ;; The case sensitivity mode is one of the symbols :upcase,
    ;; :downcase, :preserve, or :invert.
    ;; (setf (readtable-case *readtable*)
    ;;       (if *raise :downcase :preserve))
    ;; Using read-preserving-whitespace rather than read seems to be
    ;; more consistent with PSL and CSL: it leaves the EOL to be read
    ;; by REDUCE, which counts input lines in each file into the value
    ;; of curline* and this is used in rlisp88.tst.
    (cl:read-preserving-whitespace (%read-stream) nil $eof$)))

(declaim (ftype (cl:function () symbol) sl::readch))

(defun sl::readch ()
  "READCH():id
Returns the next interned character from the file currently selected
for input. Two special cases occur. If all the characters in an input
record have been read, the value of !$EOL!$ is returned. If the file
selected for input has all been read the value of !$EOF!$ is returned.
Comments delimited by % and end-of-line are not transparent to READCH."
  ;; This function must perform any required case conversion.
  (let ((c (read-char (%read-stream) nil $eof$)))
    (if (eq c $eof$)
        $eof$                           ; not a char!
        (progn
          (when *echo                   ; track output position
            ;; Revise as for %prin-string?
            (setq %posn% (if (char= c #\Newline) 0 (1+ %posn%))))
          (if *raise
              ;; down-case (because REDUCE is now LC, not UC!)
              (%intern-character-preserve-case (cl:char-upcase c))
              ;; preserve case
              (%intern-character-invert-case c))))))

(declaim (inline %default-write-stream)
         (ftype (cl:function () filehandle) %default-write-stream))

(defun %default-write-stream ()
  "The default write stream using the current value of *standard-output*."
  (list 'sl::file *standard-output*))

(defparameter %default-write-stream% (%default-write-stream)
  "The default write stream using the initial value of *standard-output*.
This must be re-set when Standard Lisp is started to work in a saved
CLISP memory image.")

(defvar %write-stream% %default-write-stream%
  "The current output filehandle: a dotted-list of the form
\('file . output-stream) or ('pipe output-stream . process).
This must be re-set when Standard Lisp is started to work in a saved
CLISP memory image.")

(declaim (ftype (cl:function (filehandle) filehandle) sl::wrs))

(defun sl::wrs (filehandle)
  "WRS(FILEHANDLE:any):any eval, spread
Output to the currently active output file is suspended and further
output is directed to the file named. FILEHANDLE is an internal
name which is returned by OPEN. The file named must have been
opened for output. If FILEHANDLE is NIL the standard output
device is selected. WRS returns the internal name of the previously
selected output file.
***** FILEHANDLE could not be selected for output"
  (prog1
      %write-stream%
    (setq *standard-output* (cadr %default-write-stream%)
          %write-stream% %default-write-stream%)
    (when filehandle
      (ecase (car filehandle)
        (sl::file
         ;; Output file stream ('file output-stream):
         (if (open-stream-p (cadr filehandle))
             (setq *standard-output* (cadr filehandle)
                   %write-stream% filehandle)))
        (sl::pipe
         ;; Output pipe stream ('pipe output-stream . process):
         (if (open-stream-p (cadr filehandle))
             (setq *standard-output* (cadr filehandle)
                   %write-stream% filehandle)))))))

(declaim (ftype (cl:function (simple-string symbol) filehandle) sl::pipe-open))

(defun sl::pipe-open (command how)
  "Run COMMAND asynchronously with input via the pipe returned as a
stream by this function."
  (case how
    (sl::output
     #+SBCL
     ;; An output filehandle is a dotted-list of the form ('file .
     ;; output-stream) or ('pipe output-stream . process):
     (let ((p
            #+win32
	     (sb-ext:run-program "cmd" (list "/c" command)
                                 :wait nil :search t :input :stream
                                 :escape-arguments nil)
	     #+unix
	     (sb-ext:run-program "sh" (list "-c" command)
				 :wait nil :search t :input :stream)))
       (cons 'sl::pipe (cons (sb-ext:process-input p) p)))
     #+CLISP
     ;; An output filehandle is a dotted-list of the form ('file .
     ;; output-stream) or ('pipe output-stream . nil):
     ;; (list 'pipe (ext:run-shell-command command :input :stream :wait nil)))
     (list 'sl::pipe (ext:make-pipe-output-stream command)))
    (t (%error "~a is not (currently) an option for PIPE-OPEN" how))))

(declaim (inline sl::channelflush)
         (ftype (cl:function (filehandle) null) sl::channelflush))

(defun sl::channelflush (filehandle)    ; PSL
  "Flush FILEHANDLE if it is a pipe stream."
  ;; filehandle = ('pipe output-stream . process)
  (when (eq (car filehandle) 'sl::pipe)
    (finish-output (cadr filehandle)))
  nil)

(declaim (inline sl::flush)
         (ftype (cl:function () null) sl::flush))

(defun sl::flush ()                     ; CSL
  "Flush the current output stream."
  (finish-output (cadr %write-stream%))
  nil)


;;; PSL/CSL functions and some other required functions
;;; ===================================================

;; In the Standard Lisp world, "character" means either a symbol whose
;; name is one character long or an ASCII character code.

(defconstant %short-day-names%
  #("Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun")
  "A vector of names of the days abbreviated to 3 letters.")

(defconstant %short-month-names%
  #("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")
  "A vector of names of the months abbreviated to 3 letters.")

(declaim (ftype (cl:function () simple-string) sl::date-and-time sl::date))

(defun sl::date-and-time ()             ; CSL
  "Return a string of the form \"Fri Feb 01 18:38:36 2019\"."
  (multiple-value-bind
        (second minute hour date month year day)
      (get-decoded-time)
    (format nil "~a ~a ~2,'0d ~2,'0d:~2,'0d:~2,'0d ~d"
            (aref %short-day-names% day)
            (aref %short-month-names% (1- month))
            date hour minute second year)))

(defun sl::date ()                      ; PSL
  "(date): string expr
The date in the form \"day-month-year\"
1 lisp> (date)
\"21-Jan-1997\""
  (multiple-value-bind
        (second minute hour date month year)
      (get-decoded-time)
    (declare (ignore second minute hour))
    (format nil "~2,'0d-~a-~d"
            date (aref %short-month-names% (1- month)) year)))

(declaim (ftype (cl:function () unsigned-byte)  sl::datestamp))

(%defalias sl::datestamp cl:get-universal-time
  "The number of seconds that have elapsed since some epoch.
This version uses the Common Lisp epoch at the beginning of the year
1900, whereas the CSL version uses the \"Unix time\" epoch at the
beginning of the year 1970.  The difference of 70 years is
70*31,536,000 = 2,207,520,000 seconds.  This function should not be
used to determine an absolute date or time!")

(declaim ((rational 0) %milliseconds-per-internal-time-unit%))

(defconstant %milliseconds-per-internal-time-unit%
  ;; `internal-time-units-per-second' is a positive integer
  ;; representing the number of internal time units in one second.  In
  ;; SBCL, CLISP and 64-bit CCL, it's value is 1000000, so an internal
  ;; time unit is one microsecond.
  (/ 1000 internal-time-units-per-second)
  "Multiplier to convert internal time units to milliseconds.")

(declaim (ftype (cl:function () (integer 0)) sl::time))

(defun sl::time ()                      ; PSL
  "(time): integer expr
Elapsed time from some arbitrary initial point in milliseconds."
  ;; This is used for timing computations, so use run time.
  (values (round (* (get-internal-run-time)
                    %milliseconds-per-internal-time-unit%))))

(declaim (ftype (cl:function ((integer 0)) (integer 0)) %nth-room-value))

#+CLISP
(defun %nth-room-value (n)
  "Return the Nth multiple value provided by CLISP `room' function.
Counting starts at 0.  Suppress the printed output."
  (with-open-stream (*standard-output* (make-broadcast-stream))
    (nth-value n (room nil))))

(declaim (ftype (cl:function () (integer 0)) sl::gctime))

(defun sl::gctime ()
  "The total time (in milliseconds) spent in garbage collection."
  ;; cf. time () defined above.
  ;; For CCL, only documented in "ccl/lib/time.lisp".
  (values (round (* #+SBCL sb-ext:*gc-run-time*
                    #+CLISP (%nth-room-value 5)
                    #+CCL (ccl:gctime)
                    %milliseconds-per-internal-time-unit%))))

(declaim (ftype (cl:function () list) sl::oblist))

(defun sl::oblist ()                    ; CSL
  "Return the Standard Lisp object list.
That is, the list of interned identifiers or the symbol table for the
current package."
  (let (lst)
    (do-symbols (s :sl) (push s lst))
    lst))

(declaim (ftype (cl:function () null) sl::reclaim))

(defun sl::reclaim ()
  "(reclaim): nil expr
Reclaim is the user level call to the garbage collector. Active data
in the heap is made contiguous and all tagged pointers into the heap
from active local stack frames, the binding stack and the symbol table
are relocated. If *gc is t, prints some statistics. Increments gcknt*
and updates gctime*."
  #+SBCL (sb-ext:gc :full t)
  #+CLISP (ext:gc)
  #+CCL (ccl:gc)
  )

(defvar gcknt* 0
  "gcknt* = [Initially: 0] global
Records the number of times that the garbage collector has been
invoked.  Gcknt* may be reset to another value to record counts
incrementally, as desired.")

(export 'gcknt*)

#+SBCL (progn                          ; <use sb-ext:*after-gc-hooks*>

(defvar %previous-gc-run-time% 0
  "Total (internal) GC time up to previous garbage collection.")

(declaim (ftype (cl:function () null) %gc-reporting %run-gc-hook))

(defun %gc-reporting ()
  "Increment garbage collection count and optionally output a report.
A function hung on the garbage collection hook."
  (incf gcknt*)
  (if *gc
      (format t "*** Garbage collection number ~a completed in ~ams.~%"
              gcknt*
              (round (* (- sb-ext:*gc-run-time* %previous-gc-run-time%)
                        %milliseconds-per-internal-time-unit%))))
  (setq %previous-gc-run-time% sb-ext:*gc-run-time*)
  nil)

(push #'%gc-reporting sb-ext:*after-gc-hooks*)

;; The file "rlisp/inter.red" defines procedures `with!-timeout` and
;; similar that use garbage collection to provide an interrupt by
;; assigning a function to the variable `!*gc!-hook!*`:

(defvar *gc-hook* nil
  "Can be assigned a REDUCE procedure to be run at GC time.")

(export '*gc-hook*)

;; For example, this works:
;; (setq *gc-hook* (lambda () (format *terminal-io* "Running hook!")))

(defun %run-gc-hook ()
  "Run the REDUCE procedure (if any) assigned to the variable *gc-hook*."
  (when *gc-hook* (funcall *gc-hook*))
  nil)

(push #'%run-gc-hook sb-ext:*after-gc-hooks*)

)                                     ; </use sb-ext:*after-gc-hooks*>

;; The code below doesn't seem to work!  Needs further investigation.
;; #+CLISP
;; (progn                         ; prototype to create *gc-hook*
;;   (defconstant %old-gc% (symbol-function 'ext:gc))
;;   (ext:without-package-lock ("EXT")
;;     (defun gc ()
;;       (funcall %old-gc%)
;;       (format t "Garbage collection called."))))

(declaim (ftype (cl:function () (integer 0)) sl::gtheap))

(defun sl::gtheap ()
  "Size of the free dynamic space in bytes."
  #+SBCL (- (sb-ext:dynamic-space-size)
            (let* ((s (with-output-to-string (*standard-output*)
                        (room nil)))
                   (p (position-if #'digit-char-p s)))
              (read-from-string
               (remove #\, (subseq s p (position #\Space s :start p))))))
  #+CLISP (%nth-room-value 1)
  #+(not (or SBCL CLISP)) 0)

(declaim (ftype (cl:function (t) list)
                explode2  sl::explodec sl::explode2uc sl::explode2lc))

(export 'explode2)                      ; used internally

(defun explode2 (u)                     ; PSL
  "(explode2 U:atom-vector): id-list expr
PRIN2-like version of EXPLODE without escapes or double quotes."
  ;; NB: invert case because of symbol name case inversion!
  (typecase u
    (string (cl:map 'list #'%intern-character-invert-case u))
    (cl:float (cl:map 'list #'%intern-character-invert-case
                      (%prin-float-to-string u)))
    (t (cl:map 'list #'%intern-character-preserve-case
               (princ-to-string u)))))

(%defalias sl::explodec explode2)       ; see "pslrend.red"

(defun sl::explode2uc (u)               ; see "pslrend.red"
  "Upper-case version of explode2."
  ;; NB: downcase because of symbol name case inversion!
  (cl:map 'list #'%intern-character-preserve-case
          (cl:string-downcase
           (typecase u
             (string u)
             (cl:float (%prin-float-to-string u))
             (t (princ-to-string u))))))

(defun sl::explode2lc (u)               ; defined in "pslrend.red"
  "Lower-case version of explode2."
  ;; NB: upcase because of symbol name case inversion!
  (cl:map 'list #'%intern-character-preserve-case
          (cl:string-upcase
           (typecase u
             (string u)
             (cl:float (%prin-float-to-string u))
             (t (princ-to-string u))))))

(declaim (ftype (cl:function (unsigned-byte) list) sl::explodehex))

(defun sl::explodehex (u)
  "Explode an unsigned integer to a list of hexadecimal digits.
Hex digits are represented as identifiers using lower case letters."
  (cl:map 'list #'%intern-character-preserve-case
          (with-output-to-string (s)
            (write u :base 16 :stream s))))

(declaim (ftype (cl:function (t) list) sl::explodecn sl::exploden))

(defun sl::explodecn (u)
  "Like explodec but returns a list of the numeric codes of the
characters involved, e.g. explodecn \"#alpha;\" => (945)."
  (cl:mapcar #'(lambda (x) (cl:char-code (character x)))
             (explode2 u)))

(defun sl::exploden (u)
  "Like explode but returns a list of integer codes.
Note some codes can be bigger than 0xff."
  (cl:mapcar #'(lambda (x) (cl:char-code (character x)))
             (explode u)))

(declaim (inline concat2)
         (ftype (cl:function (string string) ; might not be simple!
                             simple-string)
                concat2))

(export 'concat2)                       ; used internally

(defun concat2 (s1 s2)
  "Concatenates its two string arguments, returning the newly created string."
  (concatenate 'string s1 s2))

(declaim (inline concat)
         (ftype (cl:function (&rest string) ; might not be simple!
                             simple-string)
                concat))

(export 'concat)                        ; used internally

(defun concat (&rest s)
  "Concatenates all of its string arguments, returning the newly created string."
  ;; Flagged variadic in clprolo.
  (cl:apply #'concatenate 'string s))

;; (%defalias sl::allocate-string cl:make-string ; PSL
;;   "(allocate-string SIZE:integer): string expr
;; Constructs and returns a string with SIZE characters. The contents of
;; the string are not initialized.")

(declaim (inline sl::string2list)
         (ftype (cl:function (simple-string) list) sl::string2list))

(defun sl::string2list (s)              ; PSL
  "(string2list S:string): inum-list expr
Creates a list of length (add1 (size S)), converting the ASCII
characters into small integers.
lisp> (string2list \"STRING\")
\(83 84 82 73 78 71)"
  (cl:map 'list #'cl:char-code s))

(declaim (ftype (cl:function ((or (unsigned-byte 21) symbol)) character)
                %character))

(defun %character (x)
  "Generalize cl:character to accept also a character code."
  (if (integerp x)
      ;; (if (<= 0 x 255)                  ; (and (<= 0 x) (<= x 255))
          ;; Was 127, but then reading rlisp/tok.red fails!
          ;; Should 128 -> nil as specified for PSL?
          (code-char x)
          ;; (%error "~d is not a character code" x))
      (%id-to-char-invert-case x)))

(declaim (inline sl::list2string)
         (ftype (cl:function (list) simple-string)
                sl::list2string sl::list2widestring))

(defun sl::list2string (l)              ; PSL
  "(list2string L:inum-list): string expr
Allocates a string of the same size as L, and converts small integers
into characters according to their ASCII code. An integer outside the
range of 0 ... 127 will result in an error.
lisp> (list2string '(83 84 82 73 78 71))
\"STRING\"
Identifiers are case-inverted."
  (cl:map 'string #'%character l))

(defun sl::list2widestring (u)          ; same as list2string!
  "Take a list U of integers (each in the range 0-0x0010ffff) and turn
it into a string encoding those using UTF-8.  It will also support use
of identifiers or strings as well as integers, and will use the first
character (N.B. not octet) as the code concerned.
Identifiers are case-inverted."
  ;; This is a re-implementation of the procedure in rlisp/tok.red.
  ;; It must be flagged lose in clprolo.
  ;; It should make string!-store etc. redundant.
  (cl:map 'string #'%character u))

(declaim (inline sl::widestring2list)
         (ftype (cl:function (simple-string) list) sl::widestring2list))

(defun sl::widestring2list (u)
  "Given a string U that may contain bytes that are over 127, return a
list of positive integers corresponding to the characters in it if it
is interpreted as being encoded in UTF-8.  The behaviour if the bytes
are not valid UTF-8 is to be considered undefined."
  ;; This is a re-implementation of the procedure in rlisp/tok.red.
  ;; It must be flagged lose in clprolo.
  ;; It should make moan!-if!-truncated etc. redundant.
  (cl:map 'list #'cl:char-code u))

;; (defun string-store (s i x)              ; PSL
;;   "(string-store S:string I:integer X:char): None Returned expr
;; Stores into a PSL string. String indexes start with 0."
;;   (setf (aref s i) (%character x)))

(declaim (ftype (cl:function (simple-string) (integer 0))  sl::string-length))

(%defalias sl::string-length cl:length  ; PSL
  "(string-length S:string): integer expr
Returns the number of elements in a PSL string. Since indexes start with
index 0, the size is one larger than the greatest legal index. Compare this
function with string-upper-bound, documented below.")

(declaim (inline sl::char-downcase  sl::red-char-downcase sl::char-upcase)
         (ftype (cl:function (symbol) symbol)
                sl::char-downcase  sl::red-char-downcase sl::char-upcase))

(defun sl::char-downcase (c)            ; CSL
  "Convert single-character identifier C to lower case."
  ;; NB: upcase because of symbol name case inversion!
  (values (cl:intern (cl:string-upcase (cl:symbol-name c)) :sl)))

(%defalias sl::red-char-downcase sl::char-downcase) ; PSL

(defun sl::char-upcase (c)              ; CSL
  "Convert single-character identifier C to lower case."
  ;; NB: downcase because of symbol name case inversion!
  (values (cl:intern (cl:string-downcase (cl:symbol-name c)) :sl)))

(declaim (inline sl::int2id)
         (ftype (cl:function ((unsigned-byte 8)) symbol) sl::int2id))

(defun sl::int2id (i)                   ; PSL
  "(int2id I:integer): id expr
Converts an integer to an id; this refers to the I'th id in the id space. Since
0 ... 255 correspond to ASCII characters, int2id with an argument in this
range converts an ASCII code to the corresponding single character id. The
id NIL is always found by (int2id 128)."
  ;; Defined in csl.red as
  ;; inline procedure int2id x; % Turns 8-bit value into name. Only OK is under 0x80
  ;;   intern list2string list x;
  ;; (unless (= i 128) (%intern-character (code-char i)))
  (%intern-character-invert-case (code-char i)))

(declaim (inline sl::id2int sl::char-code)
         (ftype (cl:function (symbol) (unsigned-byte 8)) sl::id2int sl::char-code))

(defun sl::id2int (d)                   ; PSL
  "(id2int D:id): integer expr
Returns the id space position of D as a LISP integer."
  ;; Defined in csl.red as
  ;; inline procedure id2int x; % Gets first octet of UTF-8 form of name
  ;;   car string2list x;
  ;; (if d (cl:char-code (aref (symbol-name d) 0)) 128)
  (cl:char-code (%character-invert-case (aref (cl:symbol-name d) 0))))

(defun sl::char-code (c)                ; PSL
  "Returns the code attribute of C. (In PSL this function is an identity function.)"
  (cl:char-code (character c)))

(declaim (inline sl::id2string sl::symbol-name)
         (ftype (cl:function (symbol) simple-string) sl::id2string sl::symbol-name))

(defun sl::id2string (d)                ; PSL
  "(id2string D:id): string expr
Get name from id space. Id2string returns the print name of its argument
as a string. This is not a copy, so destructive operations should not be performed
on the result. PSL uses an escape convention for notating identifiers
which contain special characters. Any character which follows the character
! is considered to be an alphabetic character. In the example, notice that the
character ! does not appear in the result.
1 lisp> (id2string 'is-!%)
\"is-%\""
  (%string-invert-case (cl:symbol-name d)))

(%defalias sl::symbol-name sl::id2string)

(declaim (inline string-downcase)
         (ftype (cl:function ((or symbol simple-string)) simple-string) string-downcase))

(export 'string-downcase)               ; used internally

(defun string-downcase (u)
  "Convert identifier or string U to a lower-case string."
  (cl:string-downcase (if (symbolp u) (cl:symbol-name u) u)))

(declaim (ftype (cl:function (integer integer) integer)  sl::land  sl::lshift))

(%defalias sl::land cl:logand           ; PSL
  "(land U:integer V:integer): integer expr
Bitwise or logical and. Each bit of the result is independently
determined from the corresponding bits of the operands.")

(%defalias sl::lshift cl:ash            ; PSL
  ;; Not quite right for negative integers N!
  "(lshift N:integer K:integer): integer expr
Shifts N to the left by K bits. The effect is similar to multiplying
by 2 to the K power. Negative values are acceptable for K, and cause a
right shift (in the usual manner). Lshift is a logical shift, so right
shifts do not resemble division by a power of 2.")

(declaim (inline sl::list2vector  sl::list-to-vector)
         (ftype (cl:function (list) simple-vector)
                sl::list2vector  sl::list-to-vector))

(defun sl::list2vector (l)              ; PSL
  "(list2vector L:list): vector expr
Copy the elements of the list into a vector of the same size.
1 lisp> (list2vector '(V E C T O R))
[V E C T O R]"
  (cl:apply #'cl:vector l))

(%defalias sl::list-to-vector sl::list2vector)

(declaim (inline sl::vector2list)
         (ftype (cl:function (simple-vector) list) sl::vector2list))

(defun sl::vector2list (v)             ; PSL (should be flagged lose!)
  "(vector2list V:vector): list expr
Create a list of the same size as V, the elements are copied in a left to right
order.
1 lisp> (vector2list [L I S T])
\(L I S T)"
  (cl:map 'list #'cl:identity v))

(declaim (ftype (cl:function (t) t)  sl::copy))

(%defalias sl::copy cl:copy-tree        ; PSL
  "(copy X:any): any expr
This function returns a copy of X. While each pair is copied, atomic
elements (for example ids, strings, and vectors) are not.")

;; REDUCE needs complexp in various places but also needs to be able
;; to overwrite it, as in rlisp88.tst:
(declaim (ftype (cl:function (t) boolean)  sl::complexp))

(%defalias sl::complexp cl:complexp)

;; The next three PSL definitions are based on those at the end of
;; support/csl.red:

(defmacro sl::bothtimes (u)                 ; PSL
  "Evaluate the expression U at both compile time and load time."
  `(eval-when (:compile-toplevel :load-toplevel :execute) ,u))

(defmacro sl::compiletime (u)               ; PSL
  "Evaluate the expression U at compile time only."
  `(eval-when (:compile-toplevel :execute) ,u))

(flag '(sl::bothtimes sl::compiletime) 'eval) ; evaluate despite "on defn"
;; NB: eval already exported!

(defmacro sl::loadtime (u)                  ; PSL
  "Evaluate the expression U at load time only."
  `(eval-when (:load-toplevel :execute) ,u))

(declaim (ftype (cl:function (symbol) list)  sl::prop  sl::plist))

(%defalias sl::prop cl:symbol-plist)    ; PSL
(%defalias sl::plist cl:symbol-plist)   ; CSL

(declaim (inline sl::setprop)
         (ftype (cl:function (symbol list) list) sl::setprop))

(defun sl::setprop (u l)                ; PSL
  "(setprop U:id L:any): L:any expr
Store item L as the property list of U."
  (setf (symbol-plist u) l))

;; CL union and intersection return different orderings than those in
;; rlisp/rsupport.red, which leads to different (although probably not
;; incorrect) results, so don't use them.  However, union is needed in
;; the build process before it is defined in rlisp/rsupport.red, so
;; define an initial version here, which will be replaced when
;; building rlisp:

;; (declaim (ftype (cl:function (list list) list) union))
;; Declaiming this type breaks crack, which can call union with an
;; atomic argument.  (This is probably a bug in crack!)
(defun sl::union (x y)                      ; PSL
  "(union X:list Y:list): list expr
Returns the union of sets X and Y."
  (cl:union x y :test #'equal))

;; (declaim (ftype (cl:function (number number) number) mod))
;; Declaiming this type breaks cali, which redefines mod!
(%defalias sl::mod cl:mod) ; not just imported because cali redefines mod

(declaim (ftype (cl:function (integer integer) unsigned-byte)
                sl::gcdn sl::lcmn))

(%defalias sl::gcdn cl:gcd)
(%defalias sl::lcmn cl:lcm)

(declaim (ftype (cl:function (symbol symbol) boolean) sl::orderp))

(defun sl::orderp (u v)
  "Return true if U = V or U sorts before V, where U and V are identifiers.
Ordering is lexicographic with upper-case letters sorting before
lower-case letters (i.e. ASCII code U <= ASCII code V)."
  ;; (string<=
  ;;  (%string-invert-case (cl:symbol-name u))
  ;;  (%string-invert-case (cl:symbol-name v)))
  ;; A more efficient character-based implementation
  ;; following that in "support/pslrend.red":
  (let ((u (cl:symbol-name u)) (v (cl:symbol-name v)))
    (do ((i 0 (1+ i)) (j (1- (cl:length u))) (k (1- (cl:length v))) l m)
        (nil)
      (cond ((char/= (setq l (aref u i)) (setq m (aref v i)))
             ;; Undo case inversion of letters before further testing:
             (when (both-case-p l)
               (setq l (if (upper-case-p l)
                           (cl:char-downcase l)
                           (cl:char-upcase l))))
             (when (both-case-p m)
               (setq m (if (upper-case-p m)
                           (cl:char-downcase m)
                           (cl:char-upcase m))))
             (return (char< l m)))
            ((= i j) (return (<= j k)))
            ((= i k) (return nil))))))

(defvar sl::bfz*)

(declaim (ftype (cl:function (double-float) cons) sl::fl2bf))

(defun sl::fl2bf (x)
  "Convert float x to REDUCE binary bigfloat format."
  ;; Replaces version defined in "arith/smlbflot.red".
  (if (cl:zerop x)
      sl::bfz*
      (multiple-value-bind (signif expon sign)
          (integer-decode-float x)
        (cons 'sl::\:rd\: (cons (* sign signif) expon)))))

(flag '(sl::fl2bf) 'sl::lose)

(defvar sl::cursym*)
(defvar sl::curescaped*)

(declaim (ftype (cl:function (t) boolean) sl::yesp))

(defun sl::yesp (u)
  "Ask the user the question that is the value of U.
This may be an atom or a list."
  ;; Redefines yesp and yesp1 defined in "rlisp/inter.red".
  (let ((*print-case* :downcase))
    (if (atom u)
        (y-or-n-p "~a" u)
        (y-or-n-p "~a~{ ~a~}" (car u) (cdr u)))))

(flag '(sl::yesp sl::yesp1) 'sl::lose)

(declaim (ftype (cl:function (t (integer 0)) t) sl::resource-limit))

(defun sl::resource-limit (exprn time_limit)
  "Evaluate EXPRN until TIME_LIMIT seconds have expired.
*** But Lisps other than SBCL currently ignore the timeout! ***
Return (list (eval exprn)) or atomic if there is a timeout,
rather like errorset."
  ;; Tests from REDUCE -- same results using CSL & SBCL:
  ;; resource!-limit("foo", 1); => ("foo")
  ;; resource!-limit(''foo, 0.1); => (foo)
  ;; resource!-limit('(prog () (return 'foo)), 1); => (foo)
  ;; resource!-limit('(prog () a (go a)), 0.1); => nil
  #+SBCL (handler-case
             (sb-ext:with-timeout time_limit (list (eval exprn)))
           (t () nil))
  #-SBCL (declare (ignore time_limit))
  #-SBCL (list (eval exprn)))

(export 'boundp)               ; avoid the definition in alg/simp.red!
(flag '(boundp) 'sl::lose)


;;; Hash Tables
;;; ===========

;; These functions are used in REDUCE and implemented in CSL and PSL,
;; but not really documented anywhere, although fall-back versions are
;; defined in "rlisp/proc.red".

(defmacro sl::mkhash (size type &optional expansion)
  "Create and return a new hash table.
- SIZE is a non-negative integer that determines approximately the
  number of entries that can be inserted without having to enlarge the
  hash table.
- If TYPE is 0 then the test used is eq, otherwise it is cl:equal.
- EXPANSION specifies how much to increase the size of the hash table
  when it becomes full.  This can be an integer greater than zero,
  which is the number of entries to add, or it can be a floating-point
  number greater than 1, which is the ratio of the new size to the old
  size. The default value for this argument is implementation-dependent."
  `(make-hash-table
    :test (if (eql ,type 0) 'eq 'cl:equal) ; should this be equalp?
    :size ,size
    ,@(and expansion `(:rehash-size ,expansion))))

(flag '(sl::mkhash) 'sl::variadic)

(import 'hash-table-p :sl)
;; hash-table-p is true if its argument is a hash table, and otherwise
;; is false.

(import 'gethash :sl)
;; gethash finds the entry in hash-table whose key is key and returns
;; the associated value.  If there is no such entry, gethash returns
;; default, which is nil if not specified.

(declaim (ftype (cl:function (t t t) t) sl::puthash))

(defun sl::puthash (key table val)
  "Make a new entry with the specified key KEY in hash
table TABLE with value VAL.  If an entry with the specified key
already exists, it is removed before the new entry is added."
  (setf (gethash key table) val))

(import 'remhash :sl)
;; remhash removes any entry for key in hash-table. This is a
;; predicate that is true if there was an entry or false if there was
;; not.

(declaim (ftype (cl:function (hash-table) list) sl::hashcontents))

(defun sl::hashcontents (table)
  ;; Not defined in Common Lisp but used in REDUCE.
  ;; So this is a first guess at what it should do!
  "Return the contents of hash table TABLE as an association list."
  (let (alist)
    (maphash #'(lambda (key val) (push (cons key val) alist)) table)
    alist))

(import 'clrhash :sl)
;; This removes all the entries from hash-table and returns the hash
;; table itself.


;;; Operating System Interface
;;; ==========================

;; (defun system (command)                  ; PSL
;;   "(system COMMAND:string):undefined expr
;; Run a (system specific) command interpreter synchronously, pass
;; COMMAND to the interpreter and return the process exit code."
;;   ;; Split off the arguments:
;;   (setq command
;;      (loop with beg and end = 0
;;         while end
;;         do (setq beg (position-if #'(lambda (x) (char/= x #\Space))
;;                                   command :start end))
;;           (unless beg (loop-finish))
;;           (setq end (position #\Space command :start beg))
;;         collect (subseq command beg end)))
;;   (sb-ext:process-exit-code
;;    (sb-ext:run-program "cmd" (cons "/c" command)
;;                     :search t :output t :escape-arguments nil)))

(declaim (ftype (cl:function (simple-string) integer) sl::system))

#+(or SBCL CLISP CCL)      ; to avoid a syntax error with other Lisps!
(defun sl::system (command)    ; PSL
  "(system COMMAND:string):undefined expr
Run a (system specific) command interpreter synchronously, pass
COMMAND to the interpreter and return the process exit code."
       #+SBCL
       (sb-ext:process-exit-code
        #+win32
        (sb-ext:run-program "cmd" (list "/c" command)
                            :search t :output t :escape-arguments nil)
        #+unix
        (sb-ext:run-program "sh" (list "-c" command)
                            :search t :output t))
       ;; Cygwin CLISP behaves as if running on Unix, not Windows.
       ;; ext:shell returns nil for normal exit with status 0!
       #+CLISP (or (ext:shell command) 0)
       #+CCL
       (nth-value
        1
        (ccl:external-process-status    ; returns status, exit code
         #+WINDOWS
         (let ((command
                ;; Split off the arguments:
                (loop with beg and end = 0
                      while end
                      do (setq beg (position-if #'(lambda (x) (char/= x #\Space))
                                                command :start end))
                      (unless beg (loop-finish))
                      (setq end (position #\Space command :start beg))
                      ;; Quoted args seem to fail, so...
                      collect (string-trim "\"" (subseq command beg end)))))
           (ccl:run-program "cmd" (cons "/c" command) :output t))
         #-WINDOWS
         (ccl:run-program "sh" (list "-c" command) :output t)))
       )

(declaim (ftype (cl:function (simple-string) simple-string) sl::system-to-string))

#+SBCL
(defun sl::system-to-string (command)   ; experimental - not tested!
  (with-output-to-string (*standard-output*)
    (system command)))

#+CLISP
(defun sl::system-to-string (command) ; experimental - doesn't seem to work
  (let ((s (ext:run-shell-command command :output :stream)))
    (get-output-stream-string s)))

(declaim (ftype (cl:function () simple-string) sl::pwd))

(defun sl::pwd ()                       ; PSL / Unix
  "(pwd):STRING expr
Return the current working directory in system specific format."
  (namestring (truename *default-pathname-defaults*)))

(declaim (ftype (cl:function (&optional (or null simple-string))
                             (or null simple-string))
                sl::cd sl::chdir))

(defun sl::cd (&optional dir)           ; PSL / Unix
  "(cd DIR:{null,string}):{nil,string} expr
Set the current working directory to string DIR (if supplied, non-nil
and a non-empty string), which need not end with a directory
separator.  If the first component of DIR is an environment variable
of the form `$name' then replace it by its value, which need not end
with a directory separator.  On MS Windows, directory separators can
be either \ or /.  DIR may contain \".\" and \"..\".  If successful,
return the new current directory as a string; otherwise, return nil."
  #-CLISP
  (if (not (and dir (> (cl:length dir) 0)))
      ;; CCL requires truename below because
      ;; *default-pathname-defaults* is initially #P"":
      (namestring (truename *default-pathname-defaults*))
      ;; Substitute any environment variable and ensure directory:
      (let ((dir-pathname (%tidy-pathname dir t)))
        ;; Ensure the directory exists, and return the new simplified
        ;; current working directory as a string:
        (when (setq dir-pathname (probe-file dir-pathname)) ; returns truename
          (namestring (setq *default-pathname-defaults* dir-pathname)))))
  #+CLISP
  ;; CLISP probe-file doesn't accept a directory (with no filename),
  ;; hence this bespoke code:
  (values
   (ignore-errors                  ; avoid error if dir does not exist
     (namestring
      ;; ext:cd crashes with arg nil or ""!
      (cl:apply #'ext:cd (and dir (> (cl:length dir) 0)
                              (list (%tidy-pathname dir t))))))))

(%defalias sl::chdir sl::cd)            ; CSL / MS Windows

(declaim (inline sl::filep)
         (ftype (cl:function (simple-string) (or pathname null)) sl::filep))

(defun sl::filep (file)                 ; PSL
  "Return false if FILE does not exist, otherwise return the truename of
FILE.  Substitutes environment variables in file name."
  (probe-file (%tidy-pathname file)))

(declaim (inline sl::file-write-date)
         (ftype (cl:function (simple-string) (or unsigned-byte null))
                sl::file-write-date))

(defun sl::file-write-date (file)       ; PSL, used in remake
  "Return the time at which FILE was last written (or created), or nil if
such a time cannot be determined.  Substitutes environment variables
in file name."
  (cl:file-write-date (%tidy-pathname file)))

#+SBCL (import 'sb-posix:getpid :sl)
#+CLISP (declaim (ftype (cl:function () unsigned-byte)  sl::getpid)) ; ???
#+CLISP (%defalias sl::getpid os:process-id)
#+CCL (import 'ccl::getpid :sl)

(declaim (inline sl::setenv)
         (ftype (cl:function (simple-string simple-string) unsigned-byte)
                sl::setenv))

#+(or SBCL CLISP)               ; to avoid a warning with other Lisps!
(defun sl::setenv (name value)
  "Create or update an environment variable"
  #+SBCL (sb-posix:setenv name value 1) ; non-zero => overwrite
  #+CLISP (setf (ext:getenv name) value))

(declaim (inline sl::exit)
         (ftype (cl:function (&optional signed-byte) nil) sl::exit))

#+(or SBCL CLISP ABCL CCL ECL)  ; to avoid a warning with other Lisps!
(defun sl::exit (&optional code)
  #+SBCL (sb-ext:exit :code code)
  #+CLISP (ext:exit code)
  #+CCL (ccl:quit code)
  #+ABCL (ext:exit :status code)
  #+ECL (ext:quit code t)               ; kill-all-threads
  )

(export '(getenv))                      ; used internally

(declaim (inline sl::symbol-argcount)
         (ftype (cl:function ((or symbol cl:function)) (integer 0))
                sl::symbol-argcount))

(defun sl::symbol-argcount (fn)    ; used in "rtools/simplertrace.red"
  "Return number of arguments of a function."
  ;; Code provided by Rainer Sch√∂pf.
  #+SBCL (cl:length (sb-introspect:function-lambda-list fn))
  #+CLISP (cl:length (sys::arglist fn))
  #+(or CCL ABCL) (cl:length (arglist fn))
  )


;;; Compile and load
;;; ================

(defparameter %fasl-directory-pathname% ; MUST be absolute
  (let* ((dir (pathname-directory
               (or *load-truename* *default-pathname-defaults*)))
         ;; Should be a list ending with either "fasl.*" or "common-lisp".
         (last-dir-comp (car (last dir))))
    (make-pathname
     :directory
     (cond ((cl:equal (cl:subseq last-dir-comp 0 4) "fasl") ; compiled
            dir)
           ((cl:equal last-dir-comp "common-lisp") ; source
            (cl:append dir (list
                         #+SBCL "fasl.sbcl"
                         #+CLISP "fasl.clisp"
                         #+ABCL "fasl.abcl"
                         #+CCL "fasl.ccl"
                         #+ECLP "fasl.eclp" #+ECLN "fasl.ecln"
                         )))
           (t (%error "Cannot locate fasl directory")))))
  "Absolute pathname of fasl directory.")

(defvar *verboseload nil
  "*verboseload = [Initially: nil] switch
If non-nil, a message is displayed when a request is made to load a
file which has already been loaded, when a file is about to be loaded,
and when the loading of a file is complete.  Since *redefmsg is set to
the value of *verboseload within `load', a non-nil value will also
cause a message to be printed whenever a function is redefined during
a load.")

(defvar options* nil
  "A list of loaded `modules', which are loaded only once.
These are files referenced by symbols rather than strings.")

;; ECL docstring for load [with corrections]:
;; If the filetype is not specified, ECL first tries to load the fasl
;; file with filetype ".fasl" [also, apparently, ".fas"], then tries
;; to load the source file with filetype ".lsp" [also, apparently,
;; ".lisp"], and then tries to load the source file with no filetype.

(export '(*verboseload options*))

#-ECLP
(%defalias %load-extensions cl:load)

(declaim (ftype (cl:function (&rest t) boolean) %load-extensions))

#+ECLP
(defun %load-extensions (&rest args)
  "As cl:load but add a filename extension if missing.
If filename has an extension then load it; otherwise try adding first
the fasl extension (\".fasc\", system dependent) and then the source
extension (\".lisp\")."
  (cl:cond
    ((pathname-type (car args)) (cl:apply #'cl:load args))
    ((cl:apply #'cl:load
               (merge-pathnames (car args) (make-pathname :type "fasc"))
               :if-does-not-exist nil (cdr args)))
    ((cl:apply #'cl:load
               (merge-pathnames (car args) (make-pathname :type "lisp"))
               (cdr args)))))

(declaim (ftype (cl:function ((or symbol simple-string)) boolean) load))

(export 'load)                 ; symbol used internally

(defun load (file)             ; currently only supports a single file
  "(load [FILE:{string, id}]): nil macro
For each argument FILE, an attempt is made to locate a corresponding
file.  If a file is found then it will be loaded by a call on an
appropriate function.  A full file name is constructed by using the
directory specifications in loaddirectories* and the extensions in
loadextensions*.  The strings from each list are used in a left to
right order, for a given string from loaddirectories* each extension
from loadextensions* is used.

Load a \".sl\" file using Standard Lisp read syntax.
(load 'compiler) is a compatibility no-op."
  ;; filename defaults are taken from *default-pathname-defaults*,
  ;; which defaults to the directory in which SBCL was started.
  (let ((*readtable* (copy-readtable nil)) ; normal CL syntax
        (*load-verbose* *verboseload)
        (*redefmsg *verboseload) file-pathname)
    (if (symbolp file)
        (progn
          (when (or (cl:member file options*)    ; already loaded
                    (cl:eq file 'sl::compiler))  ; compatibility no-op
            (return-from load))
          (push file options*)
          (setq file-pathname
                (pathname (cl:string-downcase (cl:symbol-name file)))))
        (progn
          (setq file-pathname (pathname file))
          (if (string-equal (pathname-type file-pathname) "sl")
              (setq *readtable* %sl-readtable%))))
    (if (eqcar (pathname-directory file-pathname) :absolute)
        (%load-extensions file-pathname)
        ;; Relative filename -- look first in fasl directory and then
        ;; in current directory; if not found throw an error:
        (or (%load-extensions (merge-pathnames file-pathname %fasl-directory-pathname%)
                              :if-does-not-exist nil)
            (%load-extensions file-pathname)))))


;;; Faslout/faslend interface
;;; =========================

(defconstant sl::fasl-ext*
  #+SBCL ".fasl"
  #+CLISP ".fas"
  #+ABCL ".abcl"
  ;; #+(and CCL WINDOWS) ".wx64fsl"
  ;; #+(and CCL LINUX) ".lx64fsl"
  ;; #+(and CCL MACOS) ".dx64fsl"          ; ???
  #+CCL (namestring ccl:*.fasl-pathname*)
  #+ECLP ".fasc" #+ECLN ".fas"
  "Standard Lisp fasl filename extension beginning with \".\", used by \"remake.red\".")

(defparameter sl::fasl-dir*
  (namestring %fasl-directory-pathname%)
  "Standard Lisp fasl directory name ending with \"/\", used by \"remake.red\".")

(defconstant %faslout-header%
  (concatenate
   'string
   #-DEBUG "(cl:declaim (cl:optimize cl:speed))"
   #+DEBUG "(cl:declaim (cl:optimize cl:debug cl:safety))"
   (string #\Newline)
   #+(and SBCL (not DEBUG))
   "(cl:declaim (sb-ext:muffle-conditions sb-ext:compiler-note cl:style-warning))"
   #+(and CLISP (not DEBUG))
   "(setq custom:*suppress-check-redefinition* t custom:*compile-warnings* nil)")
  "Header string written at the top of every Lisp file generated by `faslout'
or nil, meaning no header.")

(defvar *writingfaslfile nil
  "REDUCE variable set to t by `faslout' and reset to nil by `faslend'.")
(defvar *int)

(export '(*writingfaslfile *int))

(defvar %faslout-name.lisp%)
#+CLISP (defvar %faslout-name.lib%)
(defvar %faslout-stream%)

(declaim (ftype (cl:function (t) t) prettyprint %faslout-prettyprint))

(export 'prettyprint)

(defun prettyprint (u)
  "Default prettyprint function, required for bootstrapping.
Redefined later as an autoload for the real prettyprinter."
  (print u))

(defun %faslout-prettyprint (u)
  "The prettyprint function used for faslout generation.
It prints Common Lisp syntax to %faslout-stream%."
  (let (*print-gensym* ; inhibit printing #: prefix for uninterned symbols
        (*readtable* (copy-readtable nil))) ; needed for CLISP
    (cl:print u %faslout-stream%)))

(defvar %faslout-saved-prettyprint% nil
  "The saved current global definition of the function prettyprint.
It is replaced during faslout.")

(declaim (ftype (cl:function ((or symbol simple-string)) null) sl::faslout))

(defun sl::faslout (name)
  "Compile subsequent input into Common Lisp FASL file \"NAME.fasl\".
NAME should be an identifier or string.  (The actual extension of fasl
files depends on the version of Common Lisp.)"
  ;; Output subsequent code as Common Lisp to a temporary file until
  ;; FASLEND evaluated.
  (setq name (string-downcase name))
  (if *int
      (format t "FASLOUT ~a: IN files$ or type in expressions.
When all done, execute FASLEND;~2%" name))
  ;; (unless
  (setq %faslout-stream%
        (cl:open (setq %faslout-name.lisp% (concat2 name ".lisp"))
                 :direction :output :if-exists :supersede
                 #-CCL :external-format
                 #+CLISP charset:UTF-8
                 #-(or CLISP CCL) :UTF-8))
  ;; (%error "FASLOUT cannot open ~a" %faslout-name.lisp%))
  (if %faslout-header%
      (cl:princ %faslout-header% %faslout-stream%))
  (setf %faslout-saved-prettyprint% (symbol-function 'prettyprint)
        (symbol-function 'prettyprint) (symbol-function '%faslout-prettyprint))
  (setq *defn t
        *writingfaslfile t)
  #+CLISP (setq %faslout-name.lib% (concat2 name ".lib"))
  nil)

(flag '(sl::faslout) 'sl::opfn)
(flag '(sl::faslout) 'sl::noval)

;; SBCL outputs more detailed and useful messages than those that I
;; have therefore temporarily commented out below.  Delete them unless
;; they prove useful with other versions of Common Lisp.

(declaim (ftype (cl:function () null) sl::faslend))

(defun sl::faslend ()
  "Terminate a previous FASLOUT and generate the compiled file."
  (unless *writingfaslfile
    (%error "FASLEND is only allowed after a previous FASLOUT"))
  ;; First, tidy up after the call of FASLOUT:
  (unless
      (cl:close %faslout-stream%)
    (%error "FASLEND cannot close ~a" %faslout-name.lisp%))
  (setq *writingfaslfile nil
        *defn nil) ; necessary here if faslend not input as a statement
  (setf (symbol-function 'prettyprint) %faslout-saved-prettyprint%)
  ;; Now compile the Lisp output generated by FASLOUT:
  ;; (format t  "Compiling ~a..." %faslout-name.lisp%)
  ;; (if
  (let ((*readtable* (copy-readtable nil))) ; normal CL syntax
    (compile-file %faslout-name.lisp%
                  #-CCL :external-format
                  #+CLISP charset:UTF-8
                  #-(or CLISP CCL) :UTF-8))
  #+CLISP (delete-file %faslout-name.lib%)
  ;;      ;; (progn
  ;;      ;; (delete-file %faslout-name.lisp%) ; keep to aid debugging ???
  ;;      (format t "Compiling ~a...done" %faslout-name.lisp%)
  ;;      ;; nil)
  ;;      (%error "Error compiling ~a" %faslout-name.lisp%))
  nil)

(declaim (ftype (cl:function (symbol) null) sl::comm1))

(defun sl::comm1 (u) (declare (ignore u))) ; redefined in rlisp/parser

(declaim (ftype (cl:function () cons) sl::faslendstat))

(defun sl::faslendstat ()
  "Terminate reading faslend and turn defn off."
  ;; Modelled on endstat in rlisp/parser.
  (let ((x sl::cursym*))
    (setq *defn nil)                    ; must do this ASAP!
    (sl::comm1 'sl::end)
    (list x)))

(put 'sl::faslend 'sl::stat 'sl::faslendstat) ; cf. endstat
(flag '(sl::faslendstat) 'sl::endstatfn)      ; ditto

(flag '(sl::faslend) 'sl::ignore)       ; to stop it getting compiled!


;;; User interface
;;; ==============

(declaim (ftype (cl:function () package) standard-lisp))

(import 'standard-lisp :cl-user)        ; used internally

(defun standard-lisp ()
  "Switch to STANDARD LISP mode."
  (prog1
      (in-package :sl)
    (setq *readtable* %sl-readtable%
          ;; The REDUCE source code implies that 64-bit IEEE
          ;; arithmetic is expected and it seems to be necessary to
          ;; read the constant 1.0e300 in arith/paraset.red:
          *read-default-float-format* 'double-float
          ;; These must be re-set when Standard Lisp is started to
          ;; work in a saved CLISP memory image:
          %default-read-stream% (%default-read-stream)
          %read-stream% %default-read-stream%
          %default-write-stream% (%default-write-stream)
          %write-stream% %default-write-stream%)))

(declaim (ftype (cl:function () null) sl::reset-readtable begin))

(defun sl::reset-readtable ()
  "Switch to Common Lisp read syntax."
  (setq *readtable* (copy-readtable nil))
  nil)

(export 'begin)                         ; used internally

(defun begin ())                        ; redefined in "clrend.red"

;; From: Common Lisp the Language, 2nd Edition
;; https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node341.html

;; Implementation note: Implementors are encouraged to make sure that
;; there is always a restart named abort around any user code so that
;; user code can call abort at any time and expect something
;; reasonable to happen; exactly what the reasonable thing is may vary
;; somewhat. Typically, in an interactive program, invoking abort
;; should return the user to top level, though in some batch or
;; multi-processing situations killing the running process might be
;; more appropriate.

;; The initialisation code below is based on the REPL example on the
;; web page cited above.

(declaim (ftype (cl:function () t) %reduce-init-function))

#+SBCL
;; See function `toplevel-repl' in
;; "sbcl-2.6.0/src/code/toplevel.lisp".
(defun %reduce-init-function ()
  "The function executed at startup of the saved REDUCE memory image."
  ;; Enable the interactive debugger only if the input and output are
  ;; both interactive, or we are running in Emacs (REDUCE IDE):
  (if  (or (and (interactive-stream-p *standard-input*)
                (interactive-stream-p *standard-output*))
           (getenv "INSIDE_EMACS"))
       (progn
         #+DEBUG (format t "~&Interactive mode -- debugger enabled~%")
         (sb-ext:enable-debugger)
         #+DEBUG (setq *break-on-signals* 'cl:error)
         ;; See https://www.lispworks.com/documentation/HyperSpec/Body/v_break_.htm
         )
       (progn
         #+DEBUG (format t "~&Batch mode -- debugger disabled~%")
         (sb-ext:disable-debugger)))
  ;; Enable compilation only if *comp is true:
  (setq sb-ext:*evaluator-mode*
        (if *comp :compile :interpret))
  (standard-lisp)
  (with-simple-restart
      (abort "Exit REDUCE.")
    (loop
     (with-simple-restart
         (abort "Return to REDUCE.")
       (catch 'toplevel-catcher         ; thrown internally by SBCL
         (begin))))))

#+CLISP
;; See function `main-loop' in
;; "clisp-2.49-6.20150312hg15611.src/clisp/src/reploop.lisp".
(defun %reduce-init-function ()
  "The function executed at startup of the saved REDUCE memory image."
  (standard-lisp)
  (if  (or (interactive-stream-p *standard-output*)
           (getenv "INSIDE_EMACS"))
       (progn
         #+DEBUG (format t "~&Interactive mode -- debugger enabled~%")
         #+DEBUG (setq *break-on-signals* 'cl:error)
         (system::driver ; build driver-frame; do #'lambda "infinitely"
          #'(lambda ()
              (system::with-abort-restart (:report (system::text "Abort main loop"))
                ;; ANSI CL wants an ABORT restart to be available.
                (begin)))))
       ;; Non-interactively, when an ERROR occurs, or when a
       ;; Control+C interrupt occurs, the error message is
       ;; printed and CLISP terminates with an error status.
       (progn
         #+DEBUG (format t "~&Batch mode -- debugger disabled~%")
         #+DEBUG (setq custom:*report-error-print-backtrace* t)
         (system::driver #'(lambda () (ext:exit-on-error (begin)))))))

;; #+CLISP (setq custom:*report-error-print-backtrace* t)

#+CCL
(defun %reduce-init-function ()
  (standard-lisp)
  (if  (or (getenv "interactive")
           (getenv "INSIDE_EMACS"))
       (progn
         #+DEBUG (format t "~&Interactive mode -- debugger enabled~%")
         #+DEBUG (setq *break-on-signals* 'cl:error)
         (with-simple-restart
             (abort "Exit REDUCE.")
           (loop
            (with-simple-restart
                (abort "Return to REDUCE.")
              (begin)))))
       (progn
         #+DEBUG (format t "~&Batch mode -- debugger disabled~%")
         ;; (setq *break-on-errors* nil)
         ;; documented but undeclared free variable!!!
         (begin)))
  (quit))

(declaim (ftype (cl:function (string) null) sl::save-reduce-image))

(defun sl::save-reduce-image (name)
  "Save a REDUCE memory image with main filename component NAME."
  #+SBCL
  (sb-ext:save-lisp-and-die (concat "fasl.sbcl/" name ".img")
                            :toplevel #'%reduce-init-function)
  #+CLISP
  (ext:saveinitmem
   (concat "fasl.clisp/" name ".mem")
   :init-function #'%reduce-init-function :quiet t :norc t
   :documentation "REDUCE Computer Algebra System")
  #+CCL
  (ccl:save-application (concat "fasl.ccl/" name ".image")
                        :toplevel-function #'%reduce-init-function)
  #+ECL (%reduce-init-function)
  #+ABCL (asdf-jar:package name :verbose t))

(defparameter sl::lispsystem* '(sl::common-lisp sl::sl-on-cl)
  "Information about the Lisp system supporting REDUCE.
A list of identifiers indicating system properties.")

#+SBCL  (pushnew 'sl::SBCL  sl::lispsystem*)
#+CLISP (pushnew 'sl::CLISP sl::lispsystem*)
#+ABCL  (pushnew 'sl::ABCL  sl::lispsystem*)
#+CCL   (pushnew 'sl::CCL   sl::lispsystem*)
#+ECL   (progn (pushnew 'sl::ECL sl::lispsystem*)
               (pushnew #+ECLP 'sl::ECLP #+ECLN 'sl::ECLN sl::lispsystem*))

;; The symbols UNIX, CYGWIN and WIN32 are used in gnuintfc.red.
#+(or WIN32 WINDOWS) (pushnew 'sl::WIN32 sl::lispsystem*)
#+CYGWIN (pushnew 'sl::CYGWIN sl::lispsystem*)
#+UNIX (pushnew 'sl::UNIX sl::lispsystem*)
#+(or MACOS OS-MACOSX) (pushnew 'sl::MACOS sl::lispsystem*)

;; For ECLP, use the portable bytecode compiler:
#+ECLP (ext:install-bytecodes-compiler)
;; For ECLN, use the DEFAULT native binary compiler.

#+SBCL
(progn
  (declaim (ftype (cl:function (boolean) symbol) sl::compilation))
  (defun sl::compilation (on)
    "Set the SBCL evaluation mode to compile if ON is non-nil and to
interpret otherwise.  The default is compile.
Called by ON/OFF COMP; see 'clrend.red'."
    (setq sb-ext:*evaluator-mode*
          (if on :compile :interpret))))

;; In SBCL, inhibit printing of package prefixes in the debugger
;; (which doesn't seem to work):
#+SBCL (setq sb-ext:*debug-print-variable-alist* '((*print-escape* . nil)))

#+ABCL (setq *autoload-verbose* t)

;; Tracing support
;; ===============

(setf (macro-function 'sl::cltrace) (macro-function 'cl:trace)) ; for debugging
(setf (macro-function 'sl::cluntrace) (macro-function 'cl:untrace))

#+SBCL
(defmacro sl::cltracebr (&rest fns)
  "Break on entry to the specified functions and enter the debugger."
  `(cl:trace :break t ,@fns))

;; Profiling support
;; =================

#+SBCL
(progn
  (defun sl::profile-begin ()
    (sb-profile:profile "SL"))
  (defun sl::profile-end ()
    (sb-profile:report :limit 50 :print-no-call-list nil)))

;; Common Lisp symbols used in REDUCE source code:
(import
 '(lambda warning
   unwind-protect evenp oddp
   quit force-output                    ; used in clrend
   catch throw                          ; used in corrundum (sic)
   room sleep                           ; used in crack
   *print-base*                         ; used in gf2.tst
   #+SBCL sb-ext:*muffled-warnings*     ; used in build.sh
   )
 :sl)

;;; sl-on-cl.lisp ends here

;; To do:

;; Revise compress to use read and explode to use prin1.  Failing
;; that, use Common Lisp characters.

;; Try using long floats in CLISP; see manual section 12.2.4.

;; Revise documentation strings and function order to follow PSL
;; manual more closely?
