% Generated using doxtract Sat Mar 15 10:20:01 2014
\documentclass[a4paper,11pt]{article}
\title{CSL reference}
\author{A C Norman}
\usepackage{makeidx}
\makeindex
\begin{document}
\maketitle
% Generating section 00 [intro] with 0 subsections
\section{Introduction}
This is reference material for CSL. The Lisp identifiers mentioned here
are the ones that are initially present in a raw CSL image. Some
proportion of them are not really intended to be used by end-users but
are merely the internal components of some feature.

% Generating section 01 [options] with 35 subsections
\section{Command-line options}
The items shown here are the ones that are recognized on the CSL command
line. In general an option that requires an argument can be written as either
{\ttfamily -x yyy} or as {\ttfamily -xyyy}. Arguments should be case
insensitive.
\begin{description} 

\item [{\ttfamily --}] \index{{\ttfamily --}}
If the application is run in console mode then its standard output could
be redirected to a file using shell facilities. But the {\ttfamily --}
directive (followed by a file name) redirects output within the Lisp rather
than outside it. If this is done a very limited capability for sending
progress or status reports to stderr (or the title-bar when running in windowed
mode) remains via the {\ttfamily report!-right} function.
  
The {\ttfamily -w} option may frequently make sense in such cases, but if that
is not used and the system tries to run in a window it will create it
starting off minimised.

\item [{\ttfamily --gui}] \index{{\ttfamily --gui}}
Encourage the system to run in its own window. Similar behaviour
to {\ttfamily -w+}.

\item [{\ttfamily --guimin}] \index{{\ttfamily --guimin}}
Encourage the system to run as in its own window, but
start that window off minimised. Similar
to {\ttfamily -w.}.

\item [{\ttfamily --help}] \index{{\ttfamily --help}}
It is probably obvious what this option does! Note that on Windows the
application was linked as a windows binary so it carefully creates a
console to display the help text in, and organizes a delay to give
people a chance to read it.

\item [{\ttfamily --my-path}] \index{{\ttfamily --my-path}}
At some time I had felt the need for this option, but I now forget what I
expected to use it for! It leads the executable to display the fully
rooted name of the directory it was in and then terminate. It may be useful
in some script?

\item [{\ttfamily --nogui}] \index{{\ttfamily --nogui}}
Encourage the system to run as a console-style application. Similar
to {\ttfamily -w-} or just simply {\ttfamily -w}.

\item [{\ttfamily --texmacs}] \index{{\ttfamily --texmacs}}
If CSL/Reduce is launched from texmacs this command-line flag should be
used to arrange that the {\ttfamily texmacs} flag is set in
{\ttfamily lispsystem!*}, and the code may then do special things.

\item [{\ttfamily --version}] \index{{\ttfamily --version}}
It is probably obvious what this option does! But note that there is an
issue here about whether one is looking at the CSL version identification or
one for the Lisp application from an image file (eg often Reduce).

\item [{\ttfamily -a}] \index{{\ttfamily -a}}
{\ttfamily -a} is a curious option, not intended for general or casual use.
If given it causes the {\ttfamily (batchp)} function to return the opposite
result from normal!  Without ``{attfamily -a}'' {\ttfamily (batchp)} returns
{\ttfamily T} either if at least one file was specified on the command line,
or if the standard input is ``not a tty'' (under some operating systems this
makes sense -- for instance the standard input might not be a ``tty'' if it
is provided via file redirection).  Otherwise (ie primary input is directly
from a keyboard) {\ttfamily (batchp)} returns {\ttfamily nil}.  Sometimes
this judgement about how ``batch'' the current run is will be wrong or
unhelpful, so {\ttfamily -a} allows the user to coax the system into better
behaviour.  I hope that this is never used!

\item [{\ttfamily -b}] \index{{\ttfamily -b}}
{\ttfamily -b} tells the system to avoid any attempt to recolour prompts
and input text. It will mainly be needed on X terminals that have been
set up so that they use colours that make the defaults here unhelpful.
Specifically white-on-black and so on.
{\ttfamily -b} can be followed by colour specifications to make things yet
more specific. It is supposed to be the idea that three colours can be
specified after it for output, input and prompts, with the letters KRGYbMCW
standing for blacK, Red, Green, Yellow, blue, Magenta, Cyan and White.
This may not fully work yet!

\item [{\ttfamily -c}] \index{{\ttfamily -c}}
Displays a notice relating to the authorship of CSL. Note that this
is an authorship statement not a Copyright notice, because if any
(L)GPL code is involved that would place requirements on what was
displayed in a Copyright Notice.

\item [{\ttfamily -d}] \index{{\ttfamily -d}}
A command line entry {\ttfamily -Dname=value} or {\ttfamily -D name=value}
sets the value of the named lisp variable to the value (as a string).
Note that the value set is a {\em string} so if you wish to retrieve
it and use it as a symbold or number within your code you will have to
perform some conversion.

\item [{\ttfamily -e}] \index{{\ttfamily -e}}
A ``spare'' option used from time to time to activate experiments within
CSL.

\item [{\ttfamily -f}] \index{{\ttfamily -f}}
At one stage CSL could run as a socket server, and {\ttfamily -f portnumber}
activated that mode. {\ttfamily -f-} used a default port, 1206 (a number
inspired by an account number on Titan that I used in the 1960s). The code
that supports this may be a useful foundation to others who want to make a
network service out of this code-base, but is currently disabled.

\item [{\ttfamily -g}] \index{{\ttfamily -g}}
In line with the implication of this option for C compilers, this enables
a debugging mode. It sets a lisp variable {\ttfamily !*backtrace} and
arranges that all backtraces are displayed notwithstanding use of
{\ttfamily errorset}.

\item [{\ttfamily -h}] \index{{\ttfamily -h}}
This option is a left-over. When the X-windows version of the code first
started to use Xft it viewed that as optional and could allow a build even when
it was not available. And then even if Xft was detected and liable to be used
by default it provided this option to disable its use. The remnants of the
switch that disabled use of Xft (relating to fonts living on the Host or
the Server) used this switch, but it now has no effect.

\item [{\ttfamily -i}] \index{{\ttfamily -i}}
CSL and Reduce use image files to keep both initial heap images and
``fasl'' loadable modules. By default if the executable launched has some name,
say xxx, then an image file xxx.img is used. But to support greater
generality {\ttfamily -i} introduces a new image, {\ttfamily -i-} indicates
the default one and a sequence of such directives list image files that are
searched in the order given. These are read-only. The similar option
{\ttfamily -o} equally introduces image files that are scanned for input, but
that can also be used for output. Normally there would only be one
{\ttfamily -o} directive.

\item [{\ttfamily -j}] \index{{\ttfamily -j}}
Follow this directive with a file-name, and a record of all the files read
during the Lisp run will be dumped there with a view that it can be included
in a Makefile to document dependencies.

\item [{\ttfamily -k}] \index{{\ttfamily -k}}
{\ttfamily -K nnn} sets the size of heap to be used.  If it is given then that much
memory will be allocated and the heap will never expand.  Without this
option a default amount is used, and (on many machines) it will grow
if space seems tight.
  
The extended version of this option is {\ttfamily -K nnn/ss} and then ss is the
number of ``CSL pages'' to be allocated to the Lisp stack. The default
value (which is 1) should suffice for almost all users, and it should
be noted that the C stack is separate from and independent of this one and
it too could overflow.
  
A suffix K, M or G on the number indicates units of kilobytes, megabytes or
gigabytes, with megabytes being the default. So {\ttfamily -K200M} might
represent typical usage for common-sized computations. In general CSL
will automatically expand its heap, and so it should normally never be
necessary to use this option.

\item [{\ttfamily -l}] \index{{\ttfamily -l}}
This is to send a copy of the standard output to a named log file. It is
very much as if the Lisp function {\ttfamily (spool ``logfile'')} had been
invoked at the start of the run.

\item [{\ttfamily -m}] \index{{\ttfamily -m}}
Memory trace mode. An option that represents an experiment from the past,
and no longer reliably in use. It make it possible to force an
exception at stages whene reference to a specified part of memory was made
and that could be useful for some low level debugging. It is not supported
at present.

\item [{\ttfamily -n}] \index{{\ttfamily -n}}
Normally when the system is started it will run a ``restart function'' as
indicated in its heap image. There can be cases where a heap image has been
created in a bad way such that the saved restart function always fails
abruptly, and hence working out what was wrong becomes hard. In such cases
it may be useful to give the {\ttfamily -n} option that forces CSL to
ignore any startup function and merely always begin in a minimal Lisp-style
read-eval-print loop. This is intended for experts to do disaster recovery
and diagnosis of damaged image files.

\item [{\ttfamily -o}] \index{{\ttfamily -o}}
See {\ttfamily -i}. This specifies an image file used for output via
{\ttfamily faslout} and {\ttfamily reserve}.

\item [{\ttfamily -p}] \index{{\ttfamily -p}}
If a suitable profile option gets implemented one day this will activate it,
but for now it has no effect.

\item [{\ttfamily -q}] \index{{\ttfamily -q}}
This option sets {\ttfamily !*echo} to {\ttfamily nil} and switches off
garbage collector messages to give a slightly quieter run.

\item [{\ttfamily -r}] \index{{\ttfamily -r}}
The random-number generator in CSL is normally initialised to a value
based on the time of day and is hence not reproducible from run to run.
In many cases that behavious is desirable, but for debugging it can be useful
to force a seed. The directive {\ttfamily -r nnn,mmm} sets the seed to
up to 64 bits taken from the values nnn and mmm. The second value if optional,
and specifying {\ttfamily -r0}  explicitly asks for the non-reproducible
behaviour (I hope). Note that the main Reduce-level random number source is
coded at a higher level and does not get reset this way -- this is the
lower level CSL generator.

\item [{\ttfamily -s}] \index{{\ttfamily -s}}
Sets the Lisp variable {\ttfamily !*plap} and hence the compiler generates
an assembly listing.

\item [{\ttfamily -t}] \index{{\ttfamily -t}}
{\ttfamily -t name} reports the time-stamp on the named module, and then
exits. This is for use in perl scripts and the like, and is
needed because the stamps on modules within an image or
library file are not otherwise instantly available.
  
Note that especially on windowed systems it may be necessary to use this
with {\ttfamily -- filename} since the information generated here goes to
the default output, which in some cases is just the screen.

\item [{\ttfamily -u}] \index{{\ttfamily -u}}
See {\ttfamily -d}, but this forcibly undefines a symbol. There are probably
very very few cases where it is useful since I do not have a large
number of system-specific predefined names.

\item [{\ttfamily -v}] \index{{\ttfamily -v}}
An option to make things mildly more verbose. It displays more of a banner
at startup and switches garbage collection messages on.

\item [{\ttfamily -w}] \index{{\ttfamily -w}}
On a typical system if the system is launched it creates a new window and uses
its own windowed intarface in that. If it is run such that at startup the
standard input or output are associated with a file or pipe, or under X the
variable {\ttfamily DISPLAY} is not set it will try to start up in console
mode. The flag {\ttfamily -w} indicates that the system should run in console
more regadless, while {\ttfamily -w+} attempts a window even if that seems
doomed to failure. When running the system to obey a script it will often make
sense to use the {\ttfamily -w} option. Note that on Windows the system is
provided as two separate (but almost identical) binaries. For example the
file {\ttfamily csl.exe} is linked in windows mode. A result is that if
launched from the command line it detaches from its console, and if launched
by double-clicking it does not create a console. It is in fact very ugly when
double clicking on an application causes an unwanted console window to appear.
In contrast {\ttfamily csl.com} is a console mode version of just the same
program, so when launched from a command line it can communicate with the
console in the ordinary expected manner.

\item [{\ttfamily -x}] \index{{\ttfamily -x}}
{\ttfamily -x} is an option intended for use only by system
support experts -- it disables trapping if segment violations by
errorset and so makes it easier to track down low level disasters --
maybe!  This can be valuable when running under a debugger since if the
code traps signals in its usual way and tries to recover it can make it a lot
harder to find out just what was going wrong.

\item [{\ttfamily -y}] \index{{\ttfamily -y}}
{\ttfamily -y } sets the variable {\ttfamily !*hankaku}, which causes the
lisp reader convert a Zenkaku code to Hankaku one when read. I leave this
option decoded on the command line even if the Kanji support code is not
otherwise compiled into CSL just so I can reduce conditional compilation.
This was part of the Internationalisation effort for CSL bu this is no longer
supported.

\item [{\ttfamily -z}] \index{{\ttfamily -z}}
When bootstrapping it is necessary to start up the system for one initial time
without the benefit of any image file at all. The option {\ttfamily -z} makes
this happen, so when it is specified the system starts up with a minimal
environment and only those capabilities that are present in the CSL
kernel. It will normally make sense to start loading some basic Lisp
definitions rather rapidly. The files {\ttfamily compat.lsp},
{\ttfamily extras.lsp} and {\ttfamily compiler.lsp} have Lisp source for the
main things I use, and once they are loaded the Lisp compiler can be used
to compile itself.

\end{description} % end of options section [csl.c]

% Generating section 02 [predef] with 72 subsections
\section{Predefined variables}
\begin{description}

\item [{\ttfamily !!fleps1}] \index{{\ttfamily "!fleps}} ~\newline
There is a function safe!-fp!-plus that performs floating point
arithmetic but guarantees never to raise an exception. This value was
at one stage related to when small values created there got truncated to zero,
but the current code does not use the Lisp variable at all and instead does
things based on the bitwise representation of the numbers.

\item [{\ttfamily !\$cslbase}] \index{{\ttfamily "!\$cslbase}} ~\newline
See {\ttfamily !@cslbase}.

\item [{\ttfamily !\$eof!\$}] \index{{\ttfamily "!\$eof"!\$}} ~\newline
The value of this variable is a pseudo-character returned from various
read functions to signal end-of-file.

\item [{\ttfamily !\$eol!\$}] \index{{\ttfamily "!\$eol"!\$}}~\newline
The value of this variable is an end-of-line character.

\item [{\ttfamily !*applyhook!*}] \index{{\ttfamily "!*applyhook"!*}} ~\newline
If this is set it might be supposed to be the name of a function used
by the interpreter as a callback, but at present it does not actually do
anything!

\item [{\ttfamily !*break!-loop!*}] \index{{\ttfamily "!*break"!-loop"!*}} ~\newline
If the value of this is a symbol that is defined as a function of one
argument then it is called during the processing on an error. This has not
been used in anger and so its whole status may be dubious!

\item [{\ttfamily !*carcheckflag}] \index{{\ttfamily "!*carcheckflag}} ~\newline
In general CSL arranges that every {\ttfamily car} or {\ttfamily cdr} access
is checked for validity. Once upon a time setting this variable to nil
turned such checks off in the hope of gaining a little speed. But it no
longer does that. It may have a minor effect on array access primitives.

\item [{\ttfamily !*comp}] \index{{\ttfamily "!*comp}} ~\newline
When set each function is compiled (into bytecodes) as it gets defined.

\item [{\ttfamily !*debug!-io!*}] \index{{\ttfamily "!*debug"!-io"!*}} ~\newline
An I/O channel intended to be used for diagnostic interactions. The concept
and name is taken from Common Lisp, but there is in fact no real separation
between this and the standard input and output streams.

\item [{\ttfamily !*echo}] \index{{\ttfamily "!*echo}} ~\newline
When this is non-nil characters that are read from an input file are
echoed to the standard output. This gives a more comlete transcript in
a log file, but can sometimes amount to over-verbose output.

\item [{\ttfamily !*error!-messages!*}] \index{{\ttfamily "!*error"!-messages"!*}} ~\newline
Has the value nil and does not do anything! At one stage the idea had been
that CSL's error messages would be in this table so as to be available
from Lisp, but that never happened.

\item [{\ttfamily !*error!-output!*}] \index{{\ttfamily "!*error"!-output"!*}} ~\newline
An I/O channel intended for diagnostic output. The concept comes from
Common Lisp but Standard Lisp (and hence CSL) does not really exploit it.

\item [{\ttfamily !*evalhook!*}] \index{{\ttfamily "!*evalhook"!*}} ~\newline
See {\ttfamily !*applyhook!*}. This also does not do anything at present,
but it it did it would be a place to put the name of a function that
would be called by the interpreter when applying a function.

\item [{\ttfamily !*gc!-hook!*}] \index{{\ttfamily "!*gc"!-hook"!*}} ~\newline
If this is set to have as its value that is a function of one argument then
that function is called with {\ttfamily nil} on every minor entry to the
garbage collection, and with argument {\ttfamily t} at the end of a ``genuine''
full garbage collection. This may sometimes be of interest for those who
want to notice when garbage collection happens but want to control how
they are informed rather than relying on the displayed text that the
{\ttfamily verbos} function controls.

\item [{\ttfamily !*hankaku}] \index{{\ttfamily "!*hankaku}} ~\newline
This was concerned with internationalisation to support a Japanese
locale but has not been activated for some while. In the fullness of time I
hope to migrate CSL to use an UTF8 representation of Unicode characters
internally, but that upgrade is at present an ideal and a project not
a reality. Volunteers to help welcome!

\item [{\ttfamily !*lower}] \index{{\ttfamily "!*lower}} ~\newline
In CSL if the fluid variable {\ttfamily !*lower} is set (which it is
by default) then when characters are read they are folded to lower case.
The related variable {\ttfamily !*raise} causes input to be folded to
upper case on input. In the original Standard Lisp the true internal names
of all functions were in upper case, and {\ttfamily !*raise} was used so
that code using it could be written in mixed or lower case. At some stage
it was accepted that upper case was a throw-back to the days of FORTRAN
and punched cards, so the CSL switched to using lower case
internally and the {\ttfamily !*lower} flag allowed the existing Reduce
sources to survive. At some time in the future I hope that Reduce will
arrange to have both {\ttfamily *raise} and {\ttfamily !*lower} set to
{\ttfamily nil} so that it becomes a case-sensitive system.
  
Note that the PSL Lisp system once (but not now) used {\ttfamily !*lower}
to cause internally upper case symbols to be printed in lower case,
so that there it is a control of output rather than input case folding.
PSL has functions {\ttfamily input!-case} and {\ttfamily output!-case}
that are relevant in this respect.
So code that is to be portable between the two Lisps needs to take care.

\item [{\ttfamily !*macroexpand!-hook!*}] \index{{\ttfamily "!*macroexpand"!-hook"!*}} ~\newline
Common Lisp would like it to be possible to specify a function that would
be called to allow overriding of the normal method of expanding macros. This
variable exists in CSL in case at any stage a serious need for this
capability arises, but at present any use of this variable has no effect.

\item [{\ttfamily !*math!-output!*}] \index{{\ttfamily "!*math"!-output"!*}} ~\newline
In the case that CSL is being used with Reduce and its ``fancy'' maths mode
display is available in a GUI then this provides a special output
stream that displayable layout information in a {\TeX}-like notation that
is not documented here because it is potentially in the process of being
updated. The {\ttfamily tmprint} package in Reduce generates this
material and collaborates with the mathematical display parts of CSL.

\item [{\ttfamily !*native\_code}] \index{{\ttfamily "!*native\_code}} ~\newline
An experimental additional compiler for CSL that maps Lisp directly onto
native code for the current platform has been in development for some time,
but it is not in a state such as to make it useful for other than
people who wish to experiment, extend and debug it. This flag is to do
with enabling it. It is not supported but may possibly become so one day.

\item [{\ttfamily !*notailcall}] \index{{\ttfamily "!*notailcall}} ~\newline
The CSL compiler normally tries to detect patterns of recursion that it
can convert into iteration. This can dramatically reduce stack use and
so allow calculations to succeed when otherwise they would have failed.
This flag can disable that optimisation. The most plausible reason to
want to do that would be if there was serious cause to believe that the
code performorming the optimisation was faulty, and results without it were
needed as part of the process of tracking down the bug.

\item [{\ttfamily !*package!*}] \index{{\ttfamily "!*package"!*}} ~\newline
Interrnally CSL stores the table that maps names into symbols in a way
following the style of the Common Lisp package system. When used as
a Standard Lisp there is only one package and no distinction between
internal and external name visibility, but this name provides access to
the main tdata-structure involved. It is in general expected that this
will be used via the {\ttfamily oblist} function, not directly be users.

\item [{\ttfamily !*pgwd}] \index{{\ttfamily "!*pgwd}} ~\newline
See {\ttfamily !*plap}.

\item [{\ttfamily !*plap}] \index{{\ttfamily "!*plap}} ~\newline
When the CSL compiler runs to generate byte-codes if {\ttfamily !*plap} or
{\ttfamily !*pgwd} is set then the generated code is displayed. This may
be of interest when debugging or for anybody who wants to explore the
Lisp bytecode model that is used. If at some stage a full native compiler
is released then {\ttfamily !*plap} will control display of any intermediate
Lisp-specific material and {\ttfamily !*pgwd} will control display of the
final generated platform dependent machine code.

\item [{\ttfamily !*pretty!-symmetric}] \index{{\ttfamily "!*pretty"!-symmetric}} ~\newline
The {\ttfamily prettyprint} function displays a Lisp expression neatly
indended. If this variable is set (which by default it is) symbols and
strings are shown with escape characters and quotation marks so that the
indented form could be re-input. If this variable is set to {\ttfamily nil}
that does not happen -- the output may not be re-readable by CSL but in
some cases it may be easier for a human reader to decipher.

\item [{\ttfamily !*prinl!-fn!*}] \index{{\ttfamily "!*prinl"!-fn"!*}} ~\newline
Used internally by the functions {\ttfamily prinl} and {\ttfamily princl}
that can print data structures that are re-entrant or looped. Not for use
by end-users.

\item [{\ttfamily !*prinl!-index!*}] \index{{\ttfamily "!*prinl"!-index"!*}} ~\newline
Used internally by the functions {\ttfamily prinl} and {\ttfamily princl}
that can print data structures that are re-entrant or looped. Not for use
by end-users.

\item [{\ttfamily !*prinl!-visited!-nodes!*}] \index{{\ttfamily "!*prinl"!-visited"!-nodes"!*}} ~\newline
Used internally by the functions {\ttfamily prinl} and {\ttfamily princl}
that can print data structures that are re-entrant or looped. Not for use
by end-users.

\item [{\ttfamily !*print!-array!*}] \index{{\ttfamily "!*print"!-array"!*}} ~\newline
In {\ttfamily prinl} if this variable is {\ttfamily nil} arrays and
structures are not printed in full. In some cases this merely loses valuable
information, while in others it leads to output that is more concise and
legible and hence nore useful.

\item [{\ttfamily !*print!-length!*}] \index{{\ttfamily "!*print"!-length"!*}} ~\newline
In {\ttfamily prinl} if this variable is set to an integer then that specifies
the largest number of items in a list that will be displayed.

\item [{\ttfamily !*print!-level!*}] \index{{\ttfamily "!*print"!-level"!*}} ~\newline
In {\ttfamily prinl} if this variable is set to an integer then that specifies
the greatest depth of nesting of lists before the printing gives up. This
and {\ttfamily !*print!-length!*} may very occasionally be useful when
faced with huge lists of whihc only the top few layers are relevant.

\item [{\ttfamily !*pwrds}] \index{{\ttfamily "!*pwrds}} ~\newline
This is normally set, and it causes the compiler to display a message
commenting on how many bytes were used in the compiled version of each
function that is processed.

\item [{\ttfamily !*query!-io!*}] \index{{\ttfamily "!*query"!-io"!*}} ~\newline
An I/O channel intended to be used for query interactions. The concept
and name is taken from Common Lisp, but there is in fact no real separation
between this and the standard input and output streams.

\item [{\ttfamily !*quotes}] \index{{\ttfamily "!*quotes}} ~\newline
Used in the prettyprinter to determine whether the form {\ttfamily (quote x)}
should be displayed as {\ttfamily 'x}. By default it is.

\item [{\ttfamily !*raise}] \index{{\ttfamily "!*raise}} ~\newline
See {\ttfamily !*lower}.

\item [{\ttfamily !*redefmsg}] \index{{\ttfamily "!*redefmsg}} ~\newline
If this is set a message is displayed when a function is redefined.

\item [{\ttfamily !*resources!*}] \index{{\ttfamily "!*resources"!*}} ~\newline
See the {\ttfamily resource!-limit} function.

\item [{\ttfamily !*savedef}] \index{{\ttfamily "!*savedef}} ~\newline
If this variable is set then when you define a function and compile it the
original interpratable Lisp form of the defintion is saved under the
property-name {\ttfamily !*savedef} so that it could be recovered using
{\ttfamily get}. If the function is being compiled into a fasl-file for
later reloading the lisp form of the definition is saved there so that when
{\ttfamily load!-module} or {\ttfamily load!-source} is used it can be
retrieved. This facility is activated when the ``bootstrap'' version of
Reduce is built so that in effect the full source code is available at
run-time. The availability of source in that way can be useful for forms
of global analysis or optimisation of the code -- for instance Reduce
uses it to find the definitions of functions that it wants to optimise
int C code rather than the slower (but more compact) bytecodes it uses
for most things.

\item [{\ttfamily !*spool!-output!*}] \index{{\ttfamily "!*spool"!-output"!*}} ~\newline
The {\ttfamily spool} function or the command-line option {\ttfamily -l}
can establish a file that normal output is copied to as a log. This variable
holds a handle to that file.

\item [{\ttfamily !*standard!-input!*}] \index{{\ttfamily "!*standard"!-input"!*}} ~\newline
Standard Lisp specifies that to select input from the ``standard'' source
one goes {\ttfamily (rds nil)}. In CSL this is underpinned by having an
input stream as stored in this variable following the naming convention used
by Common Lisp.

\item [{\ttfamily !*standard!-output!*}] \index{{\ttfamily "!*standard"!-output"!*}} ~\newline
As {\ttfamily !*standard!-input!*} but for output.

\item [{\ttfamily !*terminal!-io!*}] \index{{\ttfamily "!*terminal"!-io"!*}} ~\newline
A Common Lisp motivated variable which is intended to provide access to
the ``terminal''. In Standard Lisp you are expected to use {\ttfamily rds}
and the precise concept of a terminal is not really defined.

\item [{\ttfamily !*trace!-output!*}] \index{{\ttfamily "!*trace"!-output"!*}} ~\newline
The Lisp trace facility tends to send output to this which is a synonym
for the original standard output.

\item [{\ttfamily !@cslbase}] \index{{\ttfamily "!"@cslbase}} ~\newline
This variable is not actually predefined, but I will nevertheless give some
explanation of how it is used during the bootstrapping process that makes
a CSL or a Reduce image. When you attempt to open a file you mau give
a path starting with an initial ``\$word/\ldots'' or ``\$\{word\}/\ldots''.
these notations of course model typical Unix-style parameter substitution.
The expansion proceeds by first checking if a Lisp variable ``@word''
exists with a string or a symbol as its name. If so that value is used
as the expansion. If that scheme fails the system next looks for an
environment variable and uses its value. This the use of a Lisp variable
``@word'' takes priority over the system environment. Finally if there is
no environment variable available a Lisp variable with name ``\$word'' is
checked and if its value is a string or symbol that is the expansion,
otherwise the expansion will be empty.
  
This is used in the build sequences by passing a command-line
option {\ttfamily -D@cslbase=...} that predefines
{\ttfamily @cslbase} to refer to a key directory where necessary files
can be found.
By defining this rather than {\ttfamily \$cslbase} there is no chance that
any odd values in the (shell) environment will cause trouble, and the
lines such as {\ttfamily (rdf~"\$cslbase/compat.lsp")} can appear in the build
code without any need for absolute path names or any
reliance on the setting of a current directory.
  
In a file-name a path that starts with {\ttfamily !$\sim$/} or
{\ttfamily !$\sim$name/} tries to identify the home directory of the
current or named user.

\item [{\ttfamily blank}] \index{{\ttfamily blank}} ~\newline
The value of this variable is an space or blank character. This
might otherwise be written as ''{\ttfamily ! }''.

\item [{\ttfamily carriage\!-return}] \index{{\ttfamily carriage"!-return}} ~\newline
The value of this variable is a carriage-return character that could arise
in DOS-format files.

\item [{\ttfamily common!-lisp!-mode}] \index{{\ttfamily common"!-lisp"!-mode}} ~\newline
The CSL Lisp system was designed so that if necessary much of the code could
be shared with a version that met the Common Lisp Standard. At no stage has
there been anything like a complete Common version. This is both because the
main use of CSL has been to support Reduce and that wants Standard (not
Common) Lisp, and because providing complete support for all the
functionality in Common Lisp would be a lot of work and would tend to make
the code bulkier (and hence necessarily less reliable) and slower. However
various key underpinnings for Common Lisp are present in the C-coded sources,
generally guarded by ``{\ttfamily \#ifdef COMMON}''. If the Lisp has been
built in this way then this variable will be set in order that users can
readily detect the situation.  At one stage the Axiom algebra system could
be built using the limited Common Lisp compatibility mode, but the recent
Open Source versions of Axiom have probably changed leaving that not an
easy option.

\item [{\ttfamily crbuf!*}] \index{{\ttfamily crbuf"!*}} ~\newline
This is a variable used by the Reduce parser, and as a matter of caution it
is to be treated as reserved in the Lisp system. 

\item [{\ttfamily emsg!*}] \index{{\ttfamily emsg"!*}} ~\newline
After a call {\ttfamily (error nn msg)} this variable gets set to the
value of the second argument ({\ttfamily msg}). This may help if you have had
a failure and want to see if it resulted from a call to the {\ttfamily error}
function and if so what message had been used with it!

\item [{\ttfamily eof!*}] \index{{\ttfamily eof"!*}} ~\newline
Used in Reduce in association with detecting and handling end-of-file
conditions, and reserved in the Lisp to avoid potential interference with
that.

\item [{\ttfamily esc!*}] \index{{\ttfamily esc"!*}} ~\newline
The value of this variable is the character ``escape''. As a non-printing
character use of this is to be viewed as delicate.

\item [{\ttfamily lispsystem!*}] \index{{\ttfamily lispsystem"!*}} ~\newline
This variable is initialised at the start of any run of Lisp to hold
information about the computer in use and the collection of features
available in the Lisp. The items that might be present are explained
further in Section \ref{lispsys}.

\item [{\ttfamily load!-source}] \index{{\ttfamily load"!-source}} ~\newline
The function {\ttfamily load!-source} will load data from a fasl file
and is intended to make it possible to have saved uncompiled Lisp forms
for functions there -- and to be able to reload then in a selective
way. The {\ttfamily load!-source} variable can tune this behaviour. See the
explanation of the function for further details.

\item [{\ttfamily nil}] \index{{\ttfamily nil}} ~\newline
{\ttfamily nil} is the fundamental Lisp atom used to stand for ``false'',
used to terminate lists and generally something that every Lisp programmer
will already understand about. In Standard Lisp {\ttfamily nil} is a
symbol and as such you may not take {\ttfamily car} or {\ttfamily cdr} of
it. So any code that had been developed for Common Lisp and relies on being
able to treat it as if it was a non-empty list will need revision. CSL
always checks for valid access so not only would {\ttfamily (car~nil)} be
a mistake,  but any attempt to do it will lead to an exception being
raised. {\ttfamily nil} must not be used as a name of an argument or a
{\ttfamily prog} variable or in any other context that could attempt to
alter its value.

\item [{\ttfamily ofl!*}] \index{{\ttfamily ofl"!*}} ~\newline
Used in Reduce in association with tracking output files, and reserved in
CSL to avoid conflict with that.

\item [{\ttfamily program!*}] \index{{\ttfamily program"!*}} ~\newline
Used by the Reduce parser to hold a command that has just been parsed, and
reserved in CSL in order to ensure that there is no conflict with that.

\item [{\ttfamily s!:bn}]  ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:bufferi}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:bufferp}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:gensym!-serial}] \index{{\ttfamily s"!:gensym"!-serial}} ~\newline
internal variable used by {\ttfamily dated!-name}.

\item [{\ttfamily s!:indblanks}]  ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:indentlevel}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:initialblanks}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:lmar}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:pendingrpars}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:rmar}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:rparcount}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily s!:stack}] ~\newline
Used internally by the prettyprint function.

\item [{\ttfamily t}] \index{{\ttfamily t}} ~\newline
The Lisp value that stands for ``true''. Any attempt to reset or
rebind {\ttfamily t} will be an error. The value of {\ttfamily t} is
itself. Yoy may recall that in Lisp 1.5 the value of {\ttfamily t}
had been {\ttfamily *t*}, but Standard Lisp mandates the behaviour
implemented here. As far as truth values are concerned, {\ttfamily nil}
is treated as meaning ``false'' and anything that is non-{\ttfamily nil}
is true, including as an obvious special case {\ttfamily t}.

\item [{\ttfamily tab}] \index{{\ttfamily tab}} ~\newline
The value of this variable is a tab character.

\item [{\ttfamily thin!*}] \index{{\ttfamily thin"!*}} ~\newline
In the prettyprinter if {\ttfamily thin!*} values (default 5) can be
fitted on a single line. The idea behind this is so that long lists can
in relevant cases be displayed almost horizontalloy rather than
vertically, as in
{\footnotesize\begin{verbatim}
  (one two three four five             (one 
   six seven eight nine ten   vs.       two
   eleven twelve)                       three
                                        ...
\end{verbatim}}

\item [{\ttfamily ttype!*}] \index{{\ttfamily ttype"!*}} ~\newline
Used by the Reduce parser, and so best not used for other purposes.

\end{description} % end of predef section [csl.c]

% Generating section 03 [lispsys] with 25 subsections
\section{Items that can appear in {\ttfamily lispsystem!*}} \label{lispsys}
  
There is a global variable called {\ttfamily lispsystem!*} whose value is
reset in the process of CSL starting up. An effect of this is that if the
user changes its value those changes do not survice a preserving and
re-loading a heap image: this is deliberate since the heap image may be
re-loaded on a different instance of CSL possibly on a quite different
computer of with a different configuration. The value of {\ttfamily
lispsystem!*} is a list of items, where each item is either an atomic tag
of a pair whose first component is a key. In general it would be unwise
to rely on exactly what information is present without review of the code
that sets it up. The information may be of interest to anybody but some tags
and keys are reflections of experiments rather than fully stable facilities.
\begin{description}

\item[{\ttfamily (c!-code . count)}] \index{{\ttfamily (c"!-code . count)}}
This will be present if code has been optimised into C through the source
files u01.c to u60.c, and in that case the value tells you how many functions
have been optimised in this manner.
  

\item[{\ttfamily  common!-lisp}] \index{{\ttfamily  common"!-lisp}}
For a project some while ago a limited Common Lisp compatibility mode was
being developed, and this tag indicated that it was active. In that case all
entries are in upper case and the variable is called {\ttfamily *FEATURES*}
rather than {\ttfamily lispsystem!*}. But note that this Lisp has never even
aspired to be a full Common Lisp, since its author considers Common Lisp to
have been a sad mistake that must bear significant responsibility for the
fact that interest in Lisp has faded dramatically since its introduction.
  

\item[{\ttfamily (compiler!-command . command)}] \index{{\ttfamily (compiler"!-command . command)}}
The value associated with this key is a string that was used to compile the
files of C code making up CSL. It should contain directives to set up
search paths and predefined symbols. It is intended to be used in an
experiment that generates C code synamically, uses a command based on this
string to compile it and then dynamically links the resulting code in with
the running system.

\item[{\ttfamily csl}] \index{{\ttfamily csl}}
A simple tag intended to indicate that this Lisp system is CSL and not any
other. This can of course only work properly if all other Lisp systems
agree not to set this tag! In the context of Reduce I note that the PSL
Lisp system sets a tag {\ttfamily psl} on {\ttfamily lispsystem!*} and
the realistic use of this is to discriminate between CSL and PSL hosted
copies of Reduce.

\item[{\ttfamily debug}] \index{{\ttfamily debug}}
If CSL was compiled with debugging options this is present, and one can imagine
various bits of code being more cautious or more verbose if it is detected.

\item[{\ttfamily  (executable . name)}] \index{{\ttfamily  (executable . name)}}
The value is the fully rooted name of the executable file that was launched.

\item[{\ttfamily fox}] \index{{\ttfamily fox}}
Used to be present if the FOX GUI toolkit was detected and incorporated as
part of CSL, but now probably never used!

\item[{\ttfamily (linker . type)}] \index{{\ttfamily (linker . type)}}
Intended for use in association with {\ttfamily compiler!-command}, the value
is {\ttfamily win32} on Windows, {\ttfamily x86\_64} on 64-bit Linux and
other things on other systems, as detected using the program {\ttfamily
objtype.c}.

\item[{\ttfamily  (name . name)}] \index{{\ttfamily  (name . name)}}
Some indication of the platform. For instance on one system I use it
is {\ttfamily linux-gnu:x86\_64} and on anther it is just {\ttfamily win32}.

\item[{\ttfamily  (native . tag)}] \index{{\ttfamily  (native . tag)}}
One of the many experiments within CSL that were active at one stage but are
not current involved compilation directly into machine code. The strong
desire to ensure that image files coudl be used on a cross-platform basis
led to saved compiled code being tagged with a numeric ``native code tag'',
and this key/value pair identified the value to be used on the current
machine.

\item[{\ttfamily  (opsys . operating-system)}] \index{{\ttfamily  (opsys . operating-system)}}
Some crude indication of the host operating system.

\item [{\itshape operating system identity}] \index{{\ttfamily operating system identity}}
The name of the current operating system is put on the list. Exactly what
form is not explicitly defined!

\item[{\ttfamily pipes}] \index{{\ttfamily pipes}}
In the earlier days of CSL there were computers where pipes were not
supported, so this tag notes when they are present and hance the facility
to create sub-tasks through them can be used.

\item[{\ttfamily  record\_get}] \index{{\ttfamily  record\_get}}
An an extension to the CSL profiling scheme it it possible to compile
a special version that tracks and counts each use of property-list access
functions. This can be useful because there are ways to give special
treatment to a small number of flags and a small number of properties. The
special-case flage end up stored as a bitmap in the symbol-header so avoid
need for property-list searching. But of course recording this extra
information slows things down. This tag notes when the slow version is
in use. It might be used to trigger a display of statistics at the end of
a calculation.

\item[{\ttfamily reduce}] \index{{\ttfamily reduce}}
This is intended to report if the initial heap image is for Reduce rather than
merely for Lisp.

\item[{\ttfamily  (shortname . name)}] \index{{\ttfamily  (shortname . name)}}
Gives the short name of the current executable, without its full path.

\item[{\ttfamily showmath}] \index{{\ttfamily showmath}}
If the ``showmath'' capability has been compiled into CSL this will be present
so that Lisp code can know it is reasonable to try to use it.

\item[{\ttfamily showmath1}] \index{{\ttfamily showmath1}}
This marks the fact that this version of CSL will support the output
style where flat simple text preceeds TeX output, with a U+0003 (end of text)
marker to separate.

\item[{\ttfamily  sixty!-four}] \index{{\ttfamily  sixty"!-four}}
Present if the Lisp was compiled for a 64-bit computer.

\item[{\ttfamily termed}] \index{{\ttfamily termed}}
Present if a cursor-addressable console was detected.

\item[{\ttfamily texmacs}] \index{{\ttfamily texmacs}}
Present if the system was launched with the {\ttfamily --texmacs} flag.
The intent is that this should only be done when it has been launched with
texmacs as a front-end.

\item[{\ttfamily  (version . ver)}] \index{{\ttfamily  (version . ver)}}
The CSL version number.

\item[{\ttfamily win32}, {\ttfamily win64}] \index{{\ttfamily win32}, {\ttfamily win64}}
Any windows system puts {\ttfamily win32} in {\ttfamily lispsystem!*}.
If 64-bit windows is is use then {\ttfamily win64} is also included

\item[{\ttfamily windowed}] \index{{\ttfamily windowed}}
Present if CSL is running in its own window rather than in console mode.

\end{description} % end of lispsystem* section [restart.c]

% Generating section 04 [flags] with 5 subsections
\section{Flags and Properties}
  
Most of tags here are probably not much use to end-users, but I am
noting them as a matter of completeness.
  
\begin{description}

\item [{\ttfamily lose}] \index{{\ttfamily lose}}
If a name is flagged as {ttfamily lose} then a subsequent attempt to
define or redefine it will be ignored.

\item [{\ttfamily s!:ppchar} and {\ttfamily s!:ppformat}] \index{{\ttfamily s"!:ppchar} and {\ttfamily s!:ppformat}}
These are used in the prettyprint code found in {\ttfamily extras.red}. A
name is given a property {\ttfamily s!:ppformat} if in prettyprinted display
its first few arguments should appear on the same line as it if at all
possible. The {\ttfamily s!:ppchar} property is used to make the display of
bracket characters a little more tidy in the source code.

\item [{\ttfamily switch}] \index{{\ttfamily switch}}
In the Reduce parser some names are ``switches'', and then directives such
as {\ttfamily on xxx} and {\ttfamily off xx} have the effect of setting or
clearing the value of a variable {\ttfamily !*xxx}. This is managed by
setting the {\ttfamily switch} flag om {\ttfamily xxx}. CSL sets some
things as switches ready for when they may be used by the Reduce parser.

\item [{\ttfamily !$\sim$magic!-internal!-symbol!$\sim$}] \index{{\ttfamily "!$\sim$magic"!-internal"!-symbol"!$\sim$}}
CSL does not have a clear representation for functions that is separated from
the representation of an identifier, and so when you ask to get the value
of a raw function you get an identifier (probably a gensym) and this
tag is used to link such values with the symbols they were originally
extracted from.

\end{description} % end of flags section [csl.c]

% Generating section 05 [fns] with 122 subsections
\section{Functions and Special Forms}
  
Each line here shows a name and then one of the words {\itshape  expr},
{\itshape  fexpr} or {\itshape  macro}. In some cases there can also be special
treatment of functions by the compiler so that they get compiled in-line.
\begin{description}

\item [{\ttfamily abs} {\itshape  expr}] \index{{\ttfamily abs} {\itshape  expr}} ~\newline
This takes one argument that should be a number -- and returns its absolute
value. In Common Lisp mode it would find the magnitude of a complex
number, but in normal Standard Lisp mode the only cases that arise are
integers are floating point values.

\item [{\ttfamily binary\_close\_input} {\itshape  expr}] \index{{\ttfamily binary\_close\_input} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_close\_output} {\itshape  expr}] \index{{\ttfamily binary\_close\_output} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_open\_input} {\itshape  expr}] \index{{\ttfamily binary\_open\_input} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_open\_output} {\itshape  expr}] \index{{\ttfamily binary\_open\_output} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_prin1} {\itshape  expr}] \index{{\ttfamily binary\_prin1} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_prin2} {\itshape  expr}] \index{{\ttfamily binary\_prin2} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_prin3} {\itshape  expr}] \index{{\ttfamily binary\_prin3} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_prinbyte} {\itshape  expr}] \index{{\ttfamily binary\_prinbyte} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_princ} {\itshape  expr}] \index{{\ttfamily binary\_princ} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_prinfloat} {\itshape  expr}] \index{{\ttfamily binary\_prinfloat} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_read2} {\itshape  expr}] \index{{\ttfamily binary\_read2} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_read3} {\itshape  expr}] \index{{\ttfamily binary\_read3} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_read4} {\itshape  expr}] \index{{\ttfamily binary\_read4} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_readbyte} {\itshape  expr}] \index{{\ttfamily binary\_readbyte} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_readfloat} {\itshape  expr}] \index{{\ttfamily binary\_readfloat} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_select\_input} {\itshape  expr}] \index{{\ttfamily binary\_select\_input} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily binary\_terpri} {\itshape  expr}] \index{{\ttfamily binary\_terpri} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily bps!-getv} {\itshape  expr}] \index{{\ttfamily bps"!-getv} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily bps!-putv} {\itshape  expr}] \index{{\ttfamily bps"!-putv} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily bps!-upbv} {\itshape  expr}] \index{{\ttfamily bps"!-upbv} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily break!-loop} {\itshape  expr}] \index{{\ttfamily break"!-loop} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily c\_out} {\itshape  expr}] \index{{\ttfamily c\_out} {\itshape  expr}} ~\newline
Not yet written

\item[{\ttfamily caaaar} {\itshape expr}] \index{{\ttfamily caaaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caaadr} {\itshape expr}] \index{{\ttfamily caaadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caaar} {\itshape expr}] \index{{\ttfamily caaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caadar} {\itshape expr}] \index{{\ttfamily caadar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caaddr} {\itshape expr}] \index{{\ttfamily caaddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caadr} {\itshape expr}] \index{{\ttfamily caadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item [{\ttfamily caar \ldots cddddr} {\itshape expr}] \index{{\ttfamily caar \ldots cddddr} {\itshape expr}} ~\newline
Names that start with {\ttfamily c}, then have a sequence of
{\ttfamily a} or {\ttfamily d}s and finally {\ttfamily r} provide
shorthand functions for chains of uses of {\ttfamily car} and
{\ttfamily cdr}. Thus for instance
{\ttfamily (cadar x)} has the same meaning as
{\ttfamily (car (cdr (car x)))}.

\item[{\ttfamily cadaar} {\itshape expr}] \index{{\ttfamily cadaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cadadr} {\itshape expr}] \index{{\ttfamily cadadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cadar} {\itshape expr}] \index{{\ttfamily cadar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caddar} {\itshape expr}] \index{{\ttfamily caddar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cadddr} {\itshape expr}] \index{{\ttfamily cadddr} {\itshape expr}} ~\newline
see {\ttfamily caar} and {\ttfamily fourth}.

\item[{\ttfamily caddr} {\itshape expr}] \index{{\ttfamily caddr} {\itshape expr}} ~\newline
see {\ttfamily caar} and {\ttfamily third}.

\item [{\ttfamily  cadr} {\itshape expr}] \index{{\ttfamily  cadr} {\itshape expr}} ~\newline
see {\ttfamily caar} and {\ttfamily second}.

\item [{\ttfamily car} {\itshape expr}] \index{{\ttfamily car} {\itshape expr}} ~\newline
For a non-empty list the function {\ttfamily car} will return the
first element. For a dotted pair (created using {\ttfamily cons})
it extracts the first component. This is the fundamental low-level
data structure access function in Lisp. See {\ttfamily cdr} for the
function that returns the tail or a list or the second component of
a dotted pair. In CSL any attempt to take {\ttfamily car} of an atom
should be detected and will be treated as an error. If CSL had been
compiled in Common Lisp mode (which is now not probable) a special
exemption would apply and {\ttfamily car} and {\ttfamily cdr} of the
empty lisp {\ttfamily nil} would be {\ttfamily nil}.

\item[{\ttfamily car!*} {\itshape expr}] \index{{\ttfamily car"!*} {\itshape expr}} ~\newline
This function behaves like {\ttfamily car} except that if its argument
is atomic then the argument is returned unaltered rather than that case
being treated as an error.

\item[{\ttfamily cdaaar} {\itshape expr}] \index{{\ttfamily cdaaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdaadr} {\itshape expr}] \index{{\ttfamily cdaadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdaar} {\itshape expr}] \index{{\ttfamily cdaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdadar} {\itshape expr}] \index{{\ttfamily cdadar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdaddr} {\itshape expr}] \index{{\ttfamily cdaddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdadr} {\itshape expr}] \index{{\ttfamily cdadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdar} {\itshape expr}] \index{{\ttfamily cdar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddaar} {\itshape expr}] \index{{\ttfamily cddaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddadr} {\itshape expr}] \index{{\ttfamily cddadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddar} {\itshape expr}] \index{{\ttfamily cddar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdddar} {\itshape expr}] \index{{\ttfamily cdddar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddddr} {\itshape expr}] \index{{\ttfamily cddddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdddr} {\itshape expr}] \index{{\ttfamily cdddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddr} {\itshape expr}] \index{{\ttfamily cddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item [{\ttfamily cdr} {\itshape expr}] \index{{\ttfamily cdr} {\itshape expr}} ~\newline
See {\ttfamily car}.

\item [{\ttfamily char!-code} {\itshape  expr}] \index{{\ttfamily char"!-code} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily char!-downcase} {\itshape  expr}] \index{{\ttfamily char"!-downcase} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily char!-upcase} {\itshape  expr}] \index{{\ttfamily char"!-upcase} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily check!-c!-code} {\itshape  expr}] \index{{\ttfamily check"!-c"!-code} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily cl!-equal} {\itshape  expr}] \index{{\ttfamily cl"!-equal} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily close!-library} {\itshape  expr}] \index{{\ttfamily close"!-library} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily code!-char} {\itshape  expr}] \index{{\ttfamily code"!-char} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily compile!-all} {\itshape  expr}] \index{{\ttfamily compile"!-all} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily convert!-to!-evector} {\itshape  expr}] \index{{\ttfamily convert"!-to"!-evector} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily copy!-module} {\itshape  expr}] \index{{\ttfamily copy"!-module} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily copy!-native} {\itshape  expr}] \index{{\ttfamily copy"!-native} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily create!-directory} {\itshape  expr}] \index{{\ttfamily create"!-directory} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily dated!-name} {\itshape  expr}] \index{{\ttfamily dated"!-name} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily define!-in!-module} {\itshape  expr}] \index{{\ttfamily define"!-in"!-module} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily delete!-file} {\itshape  expr}] \index{{\ttfamily delete"!-file} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily delete!-module} {\itshape  expr}] \index{{\ttfamily delete"!-module} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily do!*} {\itshape macro}] \index{{\ttfamily do"!*} {\itshape macro}} ~\newline
Not yet written

\item [{\ttfamily double!-execute} {\itshape  expr}] \index{{\ttfamily double"!-execute} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily enable!-backtrace} {\itshape  expr}] \index{{\ttfamily enable"!-backtrace} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily enable!-errorset} {\itshape  expr}] \index{{\ttfamily enable"!-errorset} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily eq!-safe} {\itshape  expr}] \index{{\ttfamily eq"!-safe} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily eval!-when} {\itshape  fexpr}] \index{{\ttfamily eval"!-when} {\itshape  fexpr}} ~\newline
Not yet written

\item [{\ttfamily file!-length} {\itshape  expr}] \index{{\ttfamily file"!-length} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily file!-readablep} {\itshape  expr}] \index{{\ttfamily file"!-readablep} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily file!-writeablep} {\itshape  expr}] \index{{\ttfamily file"!-writeablep} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily flagp!*!*} {\itshape  expr}] \index{{\ttfamily flagp"!*"!*} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily fp!-evaluate} {\itshape  expr}] \index{{\ttfamily fp"!-evaluate} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily funcall!*} {\itshape  expr}] \index{{\ttfamily funcall"!*} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily get!*} {\itshape  expr}] \index{{\ttfamily get"!*} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily get!-current!-directory} {\itshape  expr}] \index{{\ttfamily get"!-current"!-directory} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily get!-lisp!-directory} {\itshape  expr}] \index{{\ttfamily get"!-lisp"!-directory} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily hash!-table!-p} {\itshape  expr}] \index{{\ttfamily hash"!-table"!-p} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily hashtagged!-name} {\itshape  expr}] \index{{\ttfamily hashtagged"!-name} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily input!-libraries} {\itshape  fexpr}] \index{{\ttfamily input"!-libraries} {\itshape  fexpr}} ~\newline
Not yet written

\item [{\ttfamily instate!-c!-code} {\itshape  expr}] \index{{\ttfamily instate"!-c"!-code} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily internal!-open} {\itshape  expr}] \index{{\ttfamily internal"!-open} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily is!-console} {\itshape  expr}] \index{{\ttfamily is"!-console} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily let!*} {\itshape  fexpr}] \index{{\ttfamily let"!*} {\itshape  fexpr}} ~\newline
Not yet written

\item [{\ttfamily library!-members} {\itshape  expr}] \index{{\ttfamily library"!-members} {\itshape  expr}} ~\newline
Returns a list of all the modules that could potentially be loaded using
{\ttfamily load!-module}. See {\ttfamily list!-modules} to get a human
readable display that looks more like the result of listing a directory, or
{\ttfamily modulep} for checking the state of a particular named module.
  

\item [{\ttfamily library!-name} {\itshape  expr}] \index{{\ttfamily library"!-name} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily list!*} {\itshape  fexpr}] \index{{\ttfamily list"!*} {\itshape  fexpr}} ~\newline
Not yet written

\item [{\ttfamily list!-directory} {\itshape  expr}] \index{{\ttfamily list"!-directory} {\itshape  expr}} ~\newline
Not yet written
  

\item [{\ttfamily list!-modules} {\itshape  expr}] \index{{\ttfamily list"!-modules} {\itshape  expr}} ~\newline
This prints a human-readable display of the modules present in the current
image files. This will include ``InitialImage'' which is the heap-image
loaded at system startup. For example
{\footnotesize \begin{verbatim}
> (list!-modules)
  
File d:\csl\csl.img (dirsize 8  length 155016, Writable):
  compat       Sat Jul 26 10:20:08 2008  position 556   size: 9320
  compiler     Sat Jul 26 10:20:08 2008  position 9880  size: 81088
  InitialImage Sat Jul 26 10:20:09 2008  position 90972 size: 64040
  
nil
\end{verbatim}}
  
See {\ttfamily library!-members} and {\ttfamily modulep} for functions that
make it possible for Lisp code to discover about the loadable modules that are
available.

\item [{\ttfamily list!-to!-string} {\itshape  expr}] \index{{\ttfamily list"!-to"!-string} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily list!-to!-symbol} {\itshape  expr}] \index{{\ttfamily list"!-to"!-symbol} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily list!-to!-vector} {\itshape  expr}] \index{{\ttfamily list"!-to"!-vector} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily list2!*} {\itshape  expr}] \index{{\ttfamily list2"!*} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily list3!*} {\itshape  expr}] \index{{\ttfamily list3"!*} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily load!-module} {\itshape  expr}] \index{{\ttfamily load"!-module} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily load!-source} {\itshape  expr}] \index{{\ttfamily load"!-source} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily lose!-precision} {\itshape  expr}] \index{{\ttfamily lose"!-precision} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily macro!-function} {\itshape  expr}] \index{{\ttfamily macro"!-function} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily macroexpand!-1} {\itshape  expr}] \index{{\ttfamily macroexpand"!-1} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily make!-bps} {\itshape  expr}] \index{{\ttfamily make"!-bps} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily make!-function!-stream} {\itshape  expr}] \index{{\ttfamily make"!-function"!-stream} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily make!-global} {\itshape  expr}] \index{{\ttfamily make"!-global} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily make!-native} {\itshape  expr}] \index{{\ttfamily make"!-native} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily make!-random!-state} {\itshape  expr}] \index{{\ttfamily make"!-random"!-state} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily make!-simple!-string} {\itshape  expr}] \index{{\ttfamily make"!-simple"!-string} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily make!-special} {\itshape  expr}] \index{{\ttfamily make"!-special} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily math!-display} {\itshape  expr}] \index{{\ttfamily math"!-display} {\itshape  expr}} ~\newline
Not yet written

\item [{\ttfamily member!*!*} {\itshape  expr}] \index{{\ttfamily member"!*"!*} {\itshape  expr}} ~\newline
Not yet written

\item[{\ttfamily rplaca} {\itshape expr}] \index{{\ttfamily rplaca} {\itshape expr}} ~\newline
This is a destructive function in that it alters the data structure
that it is given as its first argument by updating its {\ttfamily car}
component. The result is the updated object. See {\ttfamily rplacd}
for the corresponding function for updating the {\ttfamily cdr} component.

\item [{\ttfamily rplacd} {\itshape expr}] \index{{\ttfamily rplacd} {\itshape expr}} ~\newline
See {\ttfamily rplaca}

\item [{\ttfamily !$\sim$block} {\itshape  fexpr}] \index{{\ttfamily "!$\sim$block} {\itshape  fexpr}} ~\newline
Not yet written

\item [{\ttfamily !$\sim$let} {\itshape  fexpr}] \index{{\ttfamily "!$\sim$let} {\itshape  fexpr}} ~\newline
Not yet written

\item [{\ttfamily !$\sim$tyi} {\itshape  expr}] \index{{\ttfamily "!$\sim$tyi} {\itshape  expr}} ~\newline
Not yet written

\end{description} % end of fns section [tempdoc.c]

% Generating section ~~~~~~~~ [index] with 0 subsections
% The index will go here
\printindex
\end{document}

