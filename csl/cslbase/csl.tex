% Generated using doxtract Tue Oct 25 21:38:53 2022
\documentclass[a4paper,11pt]{article}
\title{CSL reference}
\author{A C Norman}
\usepackage{makeidx}
\makeindex
\begin{document}
\maketitle
% Generating section 00 [intro] with 0 subsections
\section{Introduction}
This is reference material for CSL. The Lisp identifiers mentioned here
are the ones that are initially present in a raw CSL image. Some
proportion of them are not really intended to be used by end-users but
are merely the internal components of some feature.

% Generating section 01 [options] with 51 subsections
\section{Command-line options}
The items shown here are the ones that are recognized on the CSL command
line. In general an option that requires an argument can be written as either
{\ttfamily -x yyy} or as {\ttfamily -xyyy}. Arguments should be case
insensitive.
\begin{description}

\item [{\ttfamily --}] \index{{\ttfamily --}}
          * If the application is run in console mode then its standard output could
          * be redirected to a file using shell facilities. But the {\ttfamily --}
          * directive (followed by a file name) redirects output within the Lisp rather
          * than outside it. If this is done a very limited capability for sending
          * progress or status reports to stderr (or the title-bar when running in
          * windowed  mode) remains via the {\ttfamily report!-right} function.
          *
          * The {\ttfamily -w} option may frequently make sense in such cases,
          * but if that is not used and the system tries to run in a window it will
          * create it starting off minimised.

\item [{\ttfamily --cygwin}] \index{{\ttfamily --cygwin}}
          * On Windows this flag is used to specify that a cygwin rather that a native
          * windows version of Reduce is needed. This can be the situation in some
          * cases where the foreign function interface is to be used.

\item [{\ttfamily --force-backtrace, --bt}] \index{{\ttfamily --force-backtrace, --bt}}
          * Forces any error to generate a backtrace regardless of any
          * attempt from with the system to change that (eg via use of errorset).
          * Intended for use during system  debugging where it may be important to
          * observe behaviour otherwise hidden by (errorset X nil nil) but when it
          * undesirable to change the input script at all.

\item [{\ttfamily --force-echo}] \index{{\ttfamily --force-echo}}
          * Forces echoing of input regardless of any
          * attempt from with the system to change that. Intended for use during system
          * debugging where it may be important to observe progress through an
          * input file but undesirable to change the input script at all.

\item [{\ttfamily --force-verbos}] \index{{\ttfamily --force-verbos}}
          * Forces generation of messages from the garbage collector regardless of any
          * attempt from with the system to change that. Intended for use during system
          * debugging where it may be important to see when a garbage collection occurs
          * but undesirable to change the input script at all.

\item [{\ttfamily --gc-every}] \index{{\ttfamily --gc-every}}
          * --gc-every=N forced a GC every N conses (if N!=0).

\item [{\ttfamily --gc-stop}] \index{{\ttfamily --gc-stop}}
          * --gc-stop=N stops at the start of GC number N.

\item [{\ttfamily --gc-trace}] \index{{\ttfamily --gc-trace}}
          * --gc-trace leads to copious debugging trace output from garbage collection.
          * --gc-trace=N only starts that for GC number N and beyond.

\item [{\ttfamily --gc-trigger}] \index{{\ttfamily --gc-trigger}}
          * --gc-trigger=NNNN causes a garbage collection to be forced on the NNNNth
          * occasion when that could possibly happen. This may sometimes be relevant
          * when trying to track down garbage collection related bugs. If the option
          * is set every garbage collection displays the count that it corresponds to,
          * and the intent is that these counts should be fairly deterministic.

\item [{\ttfamily --gui}] \index{{\ttfamily --gui}}
          * Encourage the system to run in its own window. Similar behaviour
          * to {\ttfamily -w+}.

\item [{\ttfamily --guimin}] \index{{\ttfamily --guimin}}
          * Encourage the system to run as in its own window, but
          * start that window off minimised. Similar
          * to {\ttfamily -w.}.

\item [{\ttfamily --help}] \index{{\ttfamily --help}}
          * It is probably obvious what this option does! Note that on Windows the
          * application was linked as a windows binary so it carefully creates a
          * console to display the help text in, and organizes a delay to give
          * people a chance to read it.

\item [{\ttfamily --ignore-load-time}] \index{{\ttfamily --ignore-load-time}}
          * By default the time spend loading or autoloading optional
          * modules is accounted by CSL as part of "garbage collector time".
          * If this option is set it is just not recorded at all.

\item [{\ttfamily --kara}] \index{{\ttfamily --kara}}
          * This it is intended for use by those maintaining CSL not for the general
          * public. By default long multiplication can use a threaded implementation
          * (to exploit multi-core machines). This happens when numbers get bigger
          * than some magic threshold.
          * This option allows one to override the default threshold so that
          * performance effects can be measured and the cut-off adjusted to suit the
          * machine involved.

\item [{\ttfamily --maxmem}] \index{{\ttfamily --maxmem}}
          * Normally this code goes back to the operating system and requests more memory
          * at any time when it feels that would be useful.This option can be used to
          * set an approximate limit on the amount it will use. See also -k

\item [{\ttfamily --mem}] \index{{\ttfamily --mem}}
          * See "-k" which behaves exactly the same.

\item [{\ttfamily --no-rcfile}] \index{{\ttfamily --no-rcfile}}
          * Instruct the system not to read a user-specific configuation file, which
          * make have such a names as ``{\ttfamily .reducerc}'', at startup time. This
          * can be useful during system building where utterly self-contained and
          * predictable behaviour is important.

\item [{\ttfamily --nogui}] \index{{\ttfamily --nogui}}
          * Encourage the system to run as a console-style application. Similar
          * to {\ttfamily -w-} or just simply {\ttfamily -w}.

\item [{\ttfamily --texmacs}] \index{{\ttfamily --texmacs}}
          * If CSL/Reduce is launched from texmacs this command-line flag should be
          * used to arrange that the {\ttfamily texmacs} flag is set in
          * {\ttfamily lispsystem!*}, and the code may then do special things.

\item [{\ttfamily --trace, --tr}] \index{{\ttfamily --trace, --tr}}
          * When followed by the name of a function this command-line option has and
          * effect as if (trace '(fname)) had been called at system start-up so that
          * all calls to the named function are reported to the user. Perhaps often to
          * be combined with --bt so that on any error a backtrace will get generated,
          * and used when an input script leads to failure and one wants to investigate
          * its behaviour without altering the script at all.

\item [{\ttfamily --version}] \index{{\ttfamily --version}}
          * It is probably obvious what this option does! But note that there is an
          * issue here about whether one is looking at the CSL version identification or
          * one for the Lisp application from an image file (eg often Reduce).

item [{ttfamily --wait}] index{{ttfamily --wait}}
          * This displays the process number and waits for 15 seconds at the
          * start of a run. This may be useful for those who have built everything
          * with debugging options and then want to start it fairly normally and
          * then attach from gdb or some other debugger.

\item [{\ttfamily --waste}] \index{{\ttfamily --waste}}
          * --waste N performs N useless CONS operations during startup
          * so that memory layout and GC patterns are changed from the
          * default

\item [{\ttfamily -a}] \index{{\ttfamily -a}}
          * {\ttfamily -a} is a curious option, not intended for general or casual use.
          * If given it causes the {\ttfamily (batchp)} function to return the opposite
          * result from normal!  Without ``{attfamily -a}'' {\ttfamily (batchp)} returns
          * {\ttfamily T} either if at least one file was specified on the command line,
          * or if the standard input is ``not a tty'' (under some operating systems this
          * makes sense -- for instance the standard input might not be a ``tty'' if it
          * is provided via file redirection).  Otherwise (ie primary input is directly
          * from a keyboard) {\ttfamily (batchp)} returns {\ttfamily nil}.  Sometimes
          * this judgement about how ``batch'' the current run is will be wrong or
          * unhelpful, so {\ttfamily -a} allows the user to coax the system into better
          * behaviour.  I hope that this is never used!

\item [{\ttfamily -b}] \index{{\ttfamily -b}}
          * {\ttfamily -b} tells the system to avoid any attempt to recolour prompts
          * and input text. It will mainly be needed on X terminals that have been
          * set up so that they use colours that make the defaults here unhelpful.
          * Specifically white-on-black and so on.
          * {\ttfamily -b} can be followed by colour specifications to make things yet
          * more specific. It is supposed to be the idea that three colours can be
          * specified after it for output, input and prompts, with the letters KRGYbMCW
          * standing for blacK, Red, Green, Yellow, blue, Magenta, Cyan and White.
          * This may not fully work yet!

\item [{\ttfamily -c}] \index{{\ttfamily -c}}
          * Displays a notice relating to the authorship of CSL. Note that this
          * is an authorship statement not a Copyright notice, because if any
          * (L)GPL code is involved that would place requirements on what was
          * displayed in a Copyright Notice.

\item [{\ttfamily -d}] \index{{\ttfamily -d}}
          * A command line entry {\ttfamily -Dname=value} or {\ttfamily -D name=value}
          * sets the value of the named lisp variable to the value as a string.

\item [{\ttfamily -dd}] \index{{\ttfamily -dd}}
          * A command line entry {\ttfamily -Dname=value} or {\ttfamily -DD name=value}
          * sets the value of the named lisp variable to the value, interpreted as a
          * name, number, string etc using normal Lisp conventions. Cf -D which always
          * leaves the value as a string.

\item [{\ttfamily -e}] \index{{\ttfamily -e}}
          * If you follow "-e" with a Lisp form then that gets evaluated and
          * its result printed during startup. This may be useful for forcing
          * settings or other debugging.

\item [{\ttfamily -f}] \index{{\ttfamily -f}}
          * At one stage CSL could run as a socket server, and {\ttfamily -f portnumber}
          * activated that mode. {\ttfamily -f-} used a default port, 1206 (a number
          * inspired by an account number on Titan that I used in the 1960s). The code
          * that supports this may be a useful foundation to others who want to make a
          * network service out of this code-base, but is currently disabled.

\item [{\ttfamily -g}] \index{{\ttfamily -g}}
          * In line with the implication of this option for C compilers, this enables
          * a debugging mode. It sets a lisp variable {\ttfamily !*backtrace} and
          * arranges that all backtraces are displayed notwithstanding use of
          * {\ttfamily errorset}.

\item [{\ttfamily -h}] \index{{\ttfamily -h}}
          * This option is a left-over. When the X-windows version of the code first
          * started to use Xft it viewed that as optional and could allow a build even when
          * it was not available. And then even if Xft was detected and liable to be used
          * by default it provided this option to disable its use. The remnants of the
          * switch that disabled use of Xft (relating to fonts living on the Host or
          * the Server) used this switch, but it now has no effect.

\item [{\ttfamily -i}] \index{{\ttfamily -i}}
          * CSL and Reduce use image files to keep both initial heap images and
          * ``fasl'' loadable modules. By default if the executable launched has some name,
          * say xxx, then an image file xxx.img is used. But to support greater
          * generality {\ttfamily -i} introduces a new image, {\ttfamily -i-} indicates
          * the default one and a sequence of such directives list image files that are
          * searched in the order given. These are read-only. The similar option
          * {\ttfamily -o} equally introduces image files that are scanned for input, but
          * that can also be used for output. Normally there would only be one
          * {\ttfamily -o} directive.

\item [{\ttfamily -j}] \index{{\ttfamily -j}}
          * Follow this directive with a file-name, and a record of all the files read
          * during the Lisp run will be dumped there with a view that it can be included
          * in a Makefile to document dependencies.

\item [{\ttfamily -k}] \index{{\ttfamily -k}}
          * {\ttfamily -K nnn} sets the size of heap to be used.  If it is given then that much
          * memory will be allocated and the heap will never expand.  Without this
          * option a default amount is used, and (on many machines) it will grow
          * if space seems tight.
          *
          * The extended version of this option is {\ttfamily -K nnn/ss} and then ss is the
          * number of ``CSL pages'' to be allocated to the Lisp stack. The default
          * value (which is 1) should suffice for almost all users, and it should
          * be noted that the C stack is separate from and independent of this one and
          * it too could overflow.
          *
          * A suffix K, M or G on the number indicates units of kilobytes, megabytes or
          * gigabytes, with megabytes being the default. So {\ttfamily -K200M} might
          * represent typical usage for common-sized computations. In general CSL
          * will automatically expand its heap, and so it should normally never be
          * necessary to use this option. It is legal to specify floating point
          * values such as -K1.2G.

\item [{\ttfamily -l}] \index{{\ttfamily -l}}
          * This is to send a copy of the standard output to a named log file. It is
          * very much as if the Lisp function {\ttfamily (spool ``logfile'')} had been
          * invoked at the start of the run.

\item [{\ttfamily -m}] \index{{\ttfamily -m}}
          * Not used at present.

\item [{\ttfamily -n}] \index{{\ttfamily -n}}
          * Normally when the system is started it will run a ``restart function'' as
          * indicated in its heap image. There can be cases where a heap image has been
          * created in a bad way such that the saved restart function always fails
          * abruptly, and hence working out what was wrong becomes hard. In such cases
          * it may be useful to give the {\ttfamily -n} option that forces CSL to
          * ignore any startup function and merely always begin in a minimal Lisp-style
          * read-eval-print loop. This is intended for experts to do disaster recovery
          * and diagnosis of damaged image files.

\item [{\ttfamily -o}] \index{{\ttfamily -o}}
          * See {\ttfamily -i}. This specifies an image file used for output via
          * {\ttfamily faslout} and {\ttfamily reserve}.

\item [{\ttfamily -p}] \index{{\ttfamily -p}}
          * If a suitable profile option gets implemented one day this will activate it,
          * but for now it has no effect.

\item [{\ttfamily -q}] \index{{\ttfamily -q}}
          * This option sets {\ttfamily !*echo} to {\ttfamily nil} and switches off
          * garbage collector messages to give a slightly quieter run.

\item [{\ttfamily -r}] \index{{\ttfamily -r}}
          * The random-number generator in CSL is normally initialised to a value
          * that is intended not to be reproducible from run to run.
          * In many cases that behaviour is desirable, but for debugging it can be useful
          * to force a seed. The directive {\ttfamily -r nnn} sets the seed to
          * up to 64 bits taken from the value nnn.
          * and specifying {\ttfamily -r0}  explicitly asks for the non-reproducible
          * behaviour (I hope). Note that the main Reduce-level random number source is
          * coded at a higher level and does not get reset this way -- this is the
          * lower level CSL generator.

\item [{\ttfamily -s}] \index{{\ttfamily -s}}
          * Sets the Lisp variable {\ttfamily !*plap} and hence the compiler generates
          * an assembly listing.

\item [{\ttfamily -t}] \index{{\ttfamily -t}}
          * {\ttfamily -t name} reports the time-stamp on the named module, and then
          * exits. This is for use in perl scripts and the like, and is
          * needed because the stamps on modules within an image or
          * library file are not otherwise instantly available.
          *
          * Note that especially on windowed systems it may be necessary to use this
          * with {\ttfamily -- filename} since the information generated here goes to
          * the default output, which in some cases is just the screen.

\item [{\ttfamily -u}] \index{{\ttfamily -u}}
          * See {\ttfamily -d}, but this forcibly undefines a symbol. There are probably
          * very very few cases where it is useful since I do not have a large
          * number of system-specific predefined names.

\item [{\ttfamily -v}] \index{{\ttfamily -v}}
          * An option to make things mildly more verbose. It displays more of a banner
          * at startup and switches garbage collection messages on.

\item [{\ttfamily -w}] \index{{\ttfamily -w}}
          * On a typical system if the system is launched it creates a new window and uses
          * its own windowed intarface in that. If it is run such that at startup the
          * standard input or output are associated with a file or pipe, or under X the
          * variable {\ttfamily DISPLAY} is not set it will try to start up in console
          * mode. The flag {\ttfamily -w} indicates that the system should run in console
          * more regardless, while {\ttfamily -w+} attempts a window even if that seems
          * doomed to failure. When running the system to obey a script it will often make
          * sense to use the {\ttfamily -w} option. Note that on Windows the system is
          * provided as two separate (but almost identical) binaries. For example the
          * file {\ttfamily csl.exe} is linked in windows mode. A result is that if
          * launched from the command line it detaches from its console, and if launched
          * by double-clicking it does not create a console. It is in fact very ugly when
          * double clicking on an application causes an unwanted console window to appear.
          * In contrast {\ttfamily csl.com} is a console mode version of just the same
          * program, so when launched from a command line it can communicate with the
          * console in the ordinary expected manner.
          *
          * The option is in fact processed at an earlier stage then here if windowing
          * is possible at all!

\item [{\ttfamily -x}] \index{{\ttfamily -x}}
          * {\ttfamily -x} is an option intended for use only by system
          * support experts -- it disables trapping if segment violations by
          * errorset and so makes it easier to track down low level disasters --
          * maybe!  This can be valuable when running under a debugger since if the
          * code traps signals in its usual way and tries to recover it can make it a lot
          * harder to find out just what was going wrong.

\item [{\ttfamily -y}] \index{{\ttfamily -y}}
          * {\ttfamily -y } is at present unused.

\item [{\ttfamily -z}] \index{{\ttfamily -z}}
          * When bootstrapping it is necessary to start up the system for one initial time
          * without the benefit of any image file at all. The option {\ttfamily -z} makes
          * this happen, so when it is specified the system starts up with a minimal
          * environment and only those capabilities that are present in the CSL
          * kernel. It will normally make sense to start loading some basic Lisp
          * definitions rather rapidly. The files {\ttfamily compat.lsp},
          * {\ttfamily extras.lsp} and {\ttfamily compiler.lsp} have Lisp source for the
          * main things I use, and once they are loaded the Lisp compiler can be used
          * to compile itself.

\end{description} % end of options section [csl.c]

% Generating section 02 [predef] with 70 subsections
\section{Predefined variables}
\begin{description}

\item [{\ttfamily !!fleps1}] \index{{\ttfamily "!fleps}} ~\newline
There is a function safe!-fp!-plus that performs floating point
arithmetic but guarantees never to raise an exception. This value was
at one stage related to when small values created there got truncated to zero,
but the current code does not use the Lisp variable at all and instead does
things based on the bitwise representation of the numbers.

\item [{\ttfamily !\$cslbase}] \index{{\ttfamily "!\$cslbase}} ~\newline
  * See {\ttfamily !@cslbase}.

\item [{\ttfamily !\$eof!\$}] \index{{\ttfamily "!\$eof"!\$}} ~\newline
The value of this variable is a pseudo-character returned from various
read functions to signal end-of-file.

\item [{\ttfamily !\$eol!\$}] \index{{\ttfamily "!\$eol"!\$}}~\newline
The value of this variable is an end-of-line character.

\item [{\ttfamily !\$ff!\$}] \index{{\ttfamily !\$ff!\$}} ~\newline
The value of this variable is a form-feed character.

\item [{\ttfamily !*applyhook!*}] \index{{\ttfamily "!*applyhook"!*}} ~\newline
If this is set it might be supposed to be the name of a function used
by the interpreter as a callback, but at present it does not actually do
anything!

\item [{\ttfamily !*break!-loop!*}] \index{{\ttfamily "!*break"!-loop"!*}} ~\newline
If the value of this is a symbol that is defined as a function of one
argument then it is called during the processing on an error. This has not
been used in anger and so its whole status may be dubious!

\item [{\ttfamily !*carcheckflag}] \index{{\ttfamily "!*carcheckflag}} ~\newline
In general CSL arranges that every {\ttfamily car} or {\ttfamily cdr} access
is checked for validity. Once upon a time setting this variable to nil
turned such checks off in the hope of gaining a little speed. But it no
longer does that. It may have a minor effect on array access primitives.

\item [{\ttfamily !*comp}] \index{{\ttfamily "!*comp}} ~\newline
When set each function is compiled (into bytecodes) as it gets defined.

\item [{\ttfamily !*debug!-io!*}] \index{{\ttfamily "!*debug"!-io"!*}} ~\newline
An I/O channel intended to be used for diagnostic interactions. The concept
and name is taken from Common Lisp, but there is in fact no real separation
between this and the standard input and output streams.

\item [{\ttfamily !*echo}] \index{{\ttfamily "!*echo}} ~\newline
When this is non-nil characters that are read from an input file are
echoed to the standard output. This gives a more comlete transcript in
a log file, but can sometimes amount to over-verbose output.

\item [{\ttfamily !*error!-messages!*}] \index{{\ttfamily "!*error"!-messages"!*}} ~\newline
Has the value nil and does not do anything! At one stage the idea had been
that CSL's error messages would be in this table so as to be available
from Lisp, but that never happened.

\item [{\ttfamily !*error!-output!*}] \index{{\ttfamily "!*error"!-output"!*}} ~\newline
An I/O channel intended for diagnostic output. The concept comes from
Common Lisp but Standard Lisp (and hence CSL) does not really exploit it.

\item [{\ttfamily !*evalhook!*}] \index{{\ttfamily "!*evalhook"!*}} ~\newline
See {\ttfamily !*applyhook!*}. This also does not do anything at present,
but it it did it would be a place to put the name of a function that
would be called by the interpreter when applying a function.

\item [{\ttfamily !*gc!-hook!*}] \index{{\ttfamily "!*gc"!-hook"!*}} ~\newline
If this is set to have as its value that is a function of one argument then
that function is called with {\ttfamily nil} on every minor entry to the
garbage collection, and with argument {\ttfamily t} at the end of a ``genuine''
full garbage collection. This may sometimes be of interest for those who
want to notice when garbage collection happens but want to control how
they are informed rather than relying on the displayed text that the
{\ttfamily verbos} function controls.

\item [{\ttfamily !*lower}] \index{{\ttfamily "!*lower}} ~\newline
In CSL if the fluid variable {\ttfamily !*lower} is set (which it is
by default) then when characters are read they are folded to lower case.
The related variable {\ttfamily !*raise} causes input to be folded to
upper case on input. In the original Standard Lisp the true internal names
of all functions were in upper case, and {\ttfamily !*raise} was used so
that code using it could be written in mixed or lower case. At some stage
it was accepted that upper case was a throw-back to the days of FORTRAN
and punched cards, so the CSL switched to using lower case
internally and the {\ttfamily !*lower} flag allowed the existing Reduce
sources to survive. At some time in the future I hope that Reduce will
arrange to have both {\ttfamily *raise} and {\ttfamily !*lower} set to
{\ttfamily nil} so that it becomes a case-sensitive system.
  
Note that the PSL Lisp system once (but not now) used {\ttfamily !*lower}
to cause internally upper case symbols to be printed in lower case,
so that there it is a control of output rather than input case folding.
PSL has functions {\ttfamily input!-case} and {\ttfamily output!-case}
that are relevant in this respect.
So code that is to be portable between the two Lisps needs to take care.

\item [{\ttfamily !*macroexpand!-hook!*}] \index{{\ttfamily "!*macroexpand"!-hook"!*}} ~\newline
Common Lisp would like it to be possible to specify a function that would
be called to allow overriding of the normal method of expanding macros. This
variable exists in CSL in case at any stage a serious need for this
capability arises, but at present any use of this variable has no effect.

\item [{\ttfamily !*math!-output!*}] \index{{\ttfamily "!*math"!-output"!*}} ~\newline
In the case that CSL is being used with Reduce and its ``fancy'' maths mode
display is available in a GUI then this provides a special output
stream that displayable layout information in a {\TeX}-like notation that
is not documented here because it is potentially in the process of being
updated. The {\ttfamily tmprint} package in Reduce generates this
material and collaborates with the mathematical display parts of CSL.

\item [{\ttfamily !*package!*}] \index{{\ttfamily "!*package"!*}} ~\newline
  * Interrnally CSL stores the table that maps names into symbols in a way
  * following the style of the Common Lisp package system. When used as
  * a Standard Lisp there is only one package and no distinction between
  * internal and external name visibility, but this name provides access to
  * the main tdata-structure involved. It is in general expected that this
  * will be used via the {\ttfamily oblist} function, not directly be users.

\item [{\ttfamily !*pgwd}] \index{{\ttfamily "!*pgwd}} ~\newline
  * See {\ttfamily !*plap}.

\item [{\ttfamily !*plap}] \index{{\ttfamily "!*plap}} ~\newline
  * When the CSL compiler runs to generate byte-codes if {\ttfamily !*plap} or
  * {\ttfamily !*pgwd} is set then the generated code is displayed. This may
  * be of interest when debugging or for anybody who wants to explore the
  * Lisp bytecode model that is used.

\item [{\ttfamily !*pretty!-symmetric}] \index{{\ttfamily "!*pretty"!-symmetric}} ~\newline
  * The {\ttfamily prettyprint} function displays a Lisp expression neatly
  * indended. If this variable is set (which by default it is) symbols and
  * strings are shown with escape characters and quotation marks so that the
  * indented form could be re-input. If this variable is set to {\ttfamily nil}
  * that does not happen -- the output may not be re-readable by CSL but in
  * some cases it may be easier for a human reader to decipher.

\item [{\ttfamily !*prinl!-fn!*}] \index{{\ttfamily "!*prinl"!-fn"!*}} ~\newline
  * Used internally by the functions {\ttfamily prinl} and {\ttfamily princl}
  * that can print data structures that are re-entrant or looped. Not for use
  * by end-users.

\item [{\ttfamily !*prinl!-index!*}] \index{{\ttfamily "!*prinl"!-index"!*}} ~\newline
  * Used internally by the functions {\ttfamily prinl} and {\ttfamily princl}
  * that can print data structures that are re-entrant or looped. Not for use
  * by end-users.

\item [{\ttfamily !*prinl!-visited!-nodes!*}] \index{{\ttfamily "!*prinl"!-visited"!-nodes"!*}} ~\newline
  * Used internally by the functions {\ttfamily prinl} and {\ttfamily princl}
  * that can print data structures that are re-entrant or looped. Not for use
  * by end-users.

\item [{\ttfamily !*print!-array!*}] \index{{\ttfamily "!*print"!-array"!*}} ~\newline
  * In {\ttfamily prinl} if this variable is {\ttfamily nil} arrays and
  * structures are not printed in full. In some cases this merely loses valuable
  * information, while in others it leads to output that is more concise and
  * legible and hence nore useful.

\item [{\ttfamily !*print!-length!*}] \index{{\ttfamily "!*print"!-length"!*}} ~\newline
  * In {\ttfamily prinl} if this variable is set to an integer then that specifies
  * the largest number of items in a list that will be displayed.

\item [{\ttfamily !*print!-level!*}] \index{{\ttfamily "!*print"!-level"!*}} ~\newline
  * In {\ttfamily prinl} if this variable is set to an integer then that specifies
  * the greatest depth of nesting of lists before the printing gives up. This
  * and {\ttfamily !*print!-length!*} may very occasionally be useful when
  * faced with huge lists of whihc only the top few layers are relevant.

\item [{\ttfamily !*pwrds}] \index{{\ttfamily "!*pwrds}} ~\newline
  * This is normally set, and it causes the compiler to display a message
  * commenting on how many bytes were used in the compiled version of each
  * function that is processed.

\item [{\ttfamily !*query!-io!*}] \index{{\ttfamily "!*query"!-io"!*}} ~\newline
  * An I/O channel intended to be used for query interactions. The concept
  * and name is taken from Common Lisp, but there is in fact no real separation
  * between this and the standard input and output streams.

\item [{\ttfamily !*quotes}] \index{{\ttfamily "!*quotes}} ~\newline
  * Used in the prettyprinter to determine whether the form {\ttfamily (quote x)}
  * should be displayed as {\ttfamily 'x}. By default it is.

\item [{\ttfamily !*raise}] \index{{\ttfamily "!*raise}} ~\newline
  * See {\ttfamily !*lower}.

\item [{\ttfamily !*redefmsg}] \index{{\ttfamily "!*redefmsg}} ~\newline
  * If this is set a message is displayed when a function is redefined.

\item [{\ttfamily !*resources!*}] \index{{\ttfamily "!*resources"!*}} ~\newline
  * See the {\ttfamily resource!-limit} function.

\item [{\ttfamily !*savedef}] \index{{\ttfamily "!*savedef}} ~\newline
  * If this variable is set then when you define a function and compile it the
  * original interpratable Lisp form of the defintion is saved under the
  * property-name {\ttfamily !*savedef} so that it could be recovered using
  * {\ttfamily get}. If the function is being compiled into a fasl-file for
  * later reloading the lisp form of the definition is saved there so that when
  * {\ttfamily load!-module} or {\ttfamily load!-source} is used it can be
  * retrieved. This facility is activated when the ``bootstrap'' version of
  * Reduce is built so that in effect the full source code is available at
  * run-time. The availability of source in that way can be useful for forms
  * of global analysis or optimisation of the code -- for instance Reduce
  * uses it to find the definitions of functions that it wants to optimise
  * int C code rather than the slower (but more compact) bytecodes it uses
  * for most things.

\item [{\ttfamily !*spool!-output!*}] \index{{\ttfamily "!*spool"!-output"!*}} ~\newline
  * The {\ttfamily spool} function or the command-line option {\ttfamily -l}
  * can establish a file that normal output is copied to as a log. This variable
  * holds a handle to that file.

\item [{\ttfamily !*standard!-input!*}] \index{{\ttfamily "!*standard"!-input"!*}} ~\newline
  * Standard Lisp specifies that to select input from the ``standard'' source
  * one goes {\ttfamily (rds nil)}. In CSL this is underpinned by having an
  * input stream as stored in this variable following the naming convention used
  * by Common Lisp.

\item [{\ttfamily !*standard!-output!*}] \index{{\ttfamily "!*standard"!-output"!*}} ~\newline
  * As {\ttfamily !*standard!-input!*} but for output.

\item [{\ttfamily !*terminal!-io!*}] \index{{\ttfamily "!*terminal"!-io"!*}} ~\newline
  * A Common Lisp motivated variable which is intended to provide access to
  * the ``terminal''. In Standard Lisp you are expected to use {\ttfamily rds}
  * and the precise concept of a terminal is not really defined.

\item [{\ttfamily !*trace!-output!*}] \index{{\ttfamily "!*trace"!-output"!*}} ~\newline
  * The Lisp trace facility tends to send output to this which is a synonym
  * for the original standard output.

\item [{\ttfamily !@cslbase}] \index{{\ttfamily "!"@cslbase}} ~\newline
  * This variable is not actually predefined, but I will nevertheless give some
  * explanation of how it is used during the bootstrapping process that makes
  * a CSL or a Reduce image. When you attempt to open a file you mau give
  * a path starting with an initial ``\$word/\ldots'' or ``\$\{word\}/\ldots''.
  * these notations of course model typical Unix-style parameter substitution.
  * The expansion proceeds by first checking if a Lisp variable ``@word''
  * exists with a string or a symbol as its name. If so that value is used
  * as the expansion. If that scheme fails the system next looks for an
  * environment variable and uses its value. This the use of a Lisp variable
  * ``@word'' takes priority over the system environment. Finally if there is
  * no environment variable available a Lisp variable with name ``\$word'' is
  * checked and if its value is a string or symbol that is the expansion,
  * otherwise the expansion will be empty.
  *
  * This is used in the build sequences by passing a command-line
  * option {\ttfamily -D@cslbase=...} that predefines
  * {\ttfamily @cslbase} to refer to a key directory where necessary files
  * can be found.
  * By defining this rather than {\ttfamily \$cslbase} there is no chance that
  * any odd values in the (shell) environment will cause trouble, and the
  * lines such as {\ttfamily (rdf~"\$cslbase/compat.lsp")} can appear in the build
  * code without any need for absolute path names or any
  * reliance on the setting of a current directory.
  *
  * In a file-name a path that starting {\ttfamily $\sim$/} or
  * {\ttfamily $\sim$name/} tries to identify the home directory of the
  * current or named user. This has a clear-cut meaning on Unix-like
  * platforms but should perhaps not be relied on under Windows.

\item [{\ttfamily blank}] \index{{\ttfamily blank}} ~\newline
The value of this variable is an space or blank character. This
might otherwise be written as {\ttfamily "! "}.

\item [{\ttfamily carriage!-return}] \index{{\ttfamily carriage"!-return}} ~\newline
The value of this variable is a carriage-return character that could arise
in DOS-format files.

\item [{\ttfamily common!-lisp!-mode}] \index{{\ttfamily common"!-lisp"!-mode}} ~\newline
  * The CSL Lisp system was designed so that if necessary much of the code could
  * be shared with a version that met the Common Lisp Standard. At no stage has
  * there been anything like a complete Common version. This is both because the
  * main use of CSL has been to support Reduce and that wants Standard (not
  * Common) Lisp, and because providing complete support for all the
  * functionality in Common Lisp would be a lot of work and would tend to make
  * the code bulkier (and hence necessarily less reliable) and slower. However
  * various key underpinnings for Common Lisp are present in the C-coded sources,
  * generally guarded by ``{\ttfamily \#ifdef COMMON}''. If the Lisp has been
  * built in this way then this variable will be set in order that users can
  * readily detect the situation.  At one stage the Axiom algebra system could
  * be built using the limited Common Lisp compatibility mode, but the recent
  * Open Source versions of Axiom have probably changed leaving that not an
  * easy option.

\item [{\ttfamily crbuf!*}] \index{{\ttfamily crbuf"!*}} ~\newline
  * This is a variable used by the Reduce parser, and as a matter of caution it
  * is to be treated as reserved in the Lisp system.

\item [{\ttfamily emsg!*}] \index{{\ttfamily emsg"!*}} ~\newline
  * After a call {\ttfamily (error nn msg)} this variable gets set to the
  * value of the second argument ({\ttfamily msg}). This may help if you have had
  * a failure and want to see if it resulted from a call to the {\ttfamily error}
  * function and if so what message had been used with it!

\item [{\ttfamily eof!*}] \index{{\ttfamily eof"!*}} ~\newline
  * Used in Reduce in association with detecting and handling end-of-file
  * conditions, and reserved in the Lisp to avoid potential interference with
  * that.

\item [{\ttfamily esc!*}] \index{{\ttfamily esc"!*}} ~\newline
The value of this variable is the character ``escape''. As a non-printing
character use of this is to be viewed as delicate.

\item [{\ttfamily lispsystem!*}] \index{{\ttfamily lispsystem"!*}} ~\newline
  * This variable is initialised at the start of any run of Lisp to hold
  * information about the computer in use and the collection of features
  * available in the Lisp. The items that might be present are explained
  * further in Section \ref{lispsys}.

\item [{\ttfamily load!-source}] \index{{\ttfamily load"!-source}} ~\newline
  * The function {\ttfamily load!-source} will load data from a fasl file
  * and is intended to make it possible to have saved uncompiled Lisp forms
  * for functions there -- and to be able to reload then in a selective
  * way. The {\ttfamily load!-source} variable can tune this behaviour. See the
  * explanation of the function for further details.

\item [{\ttfamily nil}] \index{{\ttfamily nil}} ~\newline
  * {\ttfamily nil} is the fundamental Lisp atom used to stand for ``false'',
  * used to terminate lists and generally something that every Lisp programmer
  * will already understand about. In Standard Lisp {\ttfamily nil} is a
  * symbol and as such you may not take {\ttfamily car} or {\ttfamily cdr} of
  * it. So any code that had been developed for Common Lisp and relies on being
  * able to treat it as if it was a non-empty list will need revision. CSL
  * always checks for valid access so not only would {\ttfamily (car~nil)} be
  * a mistake,  but any attempt to do it will lead to an exception being
  * raised. {\ttfamily nil} must not be used as a name of an argument or a
  * {\ttfamily prog} variable or in any other context that could attempt to
  * alter its value.

\item [{\ttfamily ofl!*}] \index{{\ttfamily ofl"!*}} ~\newline
  * Used in Reduce in association with tracking output files, and reserved in
  * CSL to avoid conflict with that.

\item [{\ttfamily program!*}] \index{{\ttfamily program"!*}} ~\newline
  * Used by the Reduce parser to hold a command that has just been parsed, and
  * reserved in CSL in order to ensure that there is no conflict with that.

\item [{\ttfamily s!:bn}]  ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:bufferi}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:bufferp}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:gensym!-serial}] \index{{\ttfamily s"!:gensym"!-serial}} ~\newline
  * internal variable used by {\ttfamily dated!-name}.

\item [{\ttfamily s!:indblanks}]  ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:indentlevel}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:initialblanks}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:lmar}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:pendingrpars}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:rmar}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:rparcount}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily s!:stack}] ~\newline
  * Used internally by the prettyprint function.

\item [{\ttfamily t}] \index{{\ttfamily t}} ~\newline
  * The Lisp value that stands for ``true''. Any attempt to reset or
  * rebind {\ttfamily t} will be an error. The value of {\ttfamily t} is
  * itself. Yoy may recall that in Lisp 1.5 the value of {\ttfamily t}
  * had been {\ttfamily *t*}, but Standard Lisp mandates the behaviour
  * implemented here. As far as truth values are concerned, {\ttfamily nil}
  * is treated as meaning ``false'' and anything that is non-{\ttfamily nil}
  * is true, including as an obvious special case {\ttfamily t}.

\item [{\ttfamily tab}] \index{{\ttfamily tab}} ~\newline
The value of this variable is a tab character.

\item [{\ttfamily thin!*}] \index{{\ttfamily thin"!*}} ~\newline
  * In the prettyprinter if {\ttfamily thin!*} values (default 5) can be
  * fitted on a single line. The idea behind this is so that long lists can
  * in relevant cases be displayed almost horizontalloy rather than
  * vertically, as in
  * {\footnotesize\begin{verbatim}
  *   (one two three four five             (one
  *    six seven eight nine ten   vs.       two
  *    eleven twelve)                       three
  *                                         ...
  * \end{verbatim}}

\item [{\ttfamily ttype!*}] \index{{\ttfamily ttype"!*}} ~\newline
  * Used by the Reduce parser, and so best not used for other purposes.

\end{description} % end of predef section [csl.c]

% Generating section 03 [lispsys] with 22 subsections
\section{Items that can appear in {\ttfamily lispsystem!*}} \label{lispsys}
  *
  * There is a global variable called {\ttfamily lispsystem!*} whose value is
  * reset in the process of CSL starting up. An effect of this is that if the
  * user changes its value those changes do not survice a preserving and
  * re-loading a heap image: this is deliberate since the heap image may be
  * re-loaded on a different instance of CSL possibly on a quite different
  * computer of with a different configuration. The value of {\ttfamily
  * lispsystem!*} is a list of items, where each item is either an atomic tag
  * of a pair whose first component is a key. In general it would be unwise
  * to rely on exactly what information is present without review of the code
  * that sets it up. The information may be of interest to anybody but some tags
  * and keys are reflections of experiments rather than fully stable facilities.
  * \begin{description}

\item[{\ttfamily (c!-code . count)}] \index{{\ttfamily (c"!-code . count)}}
      * This will be present if code has been optimised into C through the source
      * files u01.c to u60.c, and in that case the value tells you how many functions
      * have been optimised in this manner.
      *

\item[{\ttfamily  common!-lisp}] \index{{\ttfamily  common"!-lisp}}
      * For a project some while ago a limited Common Lisp compatibility mode was
      * being developed, and this tag indicated that it was active. In that case all
      * entries are in upper case and the variable is called {\ttfamily *FEATURES*}
      * rather than {\ttfamily lispsystem!*}. But note that this Lisp has never even
      * aspired to be a full Common Lisp, since its author considers Common Lisp to
      * have been a sad mistake that must bear significant responsibility for the
      * fact that interest in Lisp has faded dramatically since its introduction.
      *

\item[{\ttfamily csl}] \index{{\ttfamily csl}}
      * A simple tag intended to indicate that this Lisp system is CSL and not any
      * other. This can of course only work properly if all other Lisp systems
      * agree not to set this tag! In the context of Reduce I note that the PSL
      * Lisp system sets a tag {\ttfamily psl} on {\ttfamily lispsystem!*} and
      * the realistic use of this is to discriminate between CSL and PSL hosted
      * copies of Reduce.

\item[{\ttfamily debug}] \index{{\ttfamily debug}}
      * If CSL was compiled with debugging options this is present, and one can imagine
      * various bits of code being more cautious or more verbose if it is detected.

\item[{\ttfamily  (executable . name)}] \index{{\ttfamily  (executable . name)}}
      * The value is the fully rooted name of the executable file that was launched.

\item[{\ttfamily fox}] \index{{\ttfamily fox}}
      * Used to be present if the FOX GUI toolkit was detected and incorporated as
      * part of CSL, but now probably never used!

\item[{\ttfamily  (name . name)}] \index{{\ttfamily  (name . name)}}
      * Some indication of the platform. For instance on one system I use it
      * is {\ttfamily linux-gnu:x86\_64} and on anther it is just {\ttfamily win32}.

\item[{\ttfamily  (opsys . operating-system)}] \index{{\ttfamily  (opsys . operating-system)}}
      * Some crude indication of the host operating system.

\item [{\itshape operating system identity}] \index{{\ttfamily operating system identity}}
      * The name of the current operating system is put on the list. Exactly what
      * form is not explicitly defined!

\item[{\ttfamily pipes}] \index{{\ttfamily pipes}}
      * In the earlier days of CSL there were computers where pipes were not
      * supported, so this tag notes when they are present and hance the facility
      * to create sub-tasks through them can be used.

\item[{\ttfamily  record\_get}] \index{{\ttfamily  record\_get}}
      * An an extension to the CSL profiling scheme it it possible to compile
      * a special version that tracks and counts each use of property-list access
      * functions. This can be useful because there are ways to give special
      * treatment to a small number of flags and a small number of properties. The
      * special-case flage end up stored as a bitmap in the symbol-header so avoid
      * need for property-list searching. But of course recording this extra
      * information slows things down. This tag notes when the slow version is
      * in use. It might be used to trigger a display of statistics at the end of
      * a calculation.

\item[{\ttfamily reduce}] \index{{\ttfamily reduce}}
      * This is intended to report if the initial heap image is for Reduce rather than
      * merely for Lisp.

\item[{\ttfamily  (revision . ver)}] \index{{\ttfamily  (revision . ver)}}
      * The CSL subversion revision number.

\item[{\ttfamily  (shortname . name)}] \index{{\ttfamily  (shortname . name)}}
      * Gives the short name of the current executable, without its full path.

\item[{\ttfamily showmath}] \index{{\ttfamily showmath}}
      * If the ``showmath'' capability has been compiled into CSL this will be present
      * so that Lisp code can know it is reasonable to try to use it.

\item[{\ttfamily showmath1}] \index{{\ttfamily showmath1}}
      * This marks the fact that this version of CSL will support the output
      * style where flat simple text preceeds TeX output, with a U+0003 (end of text)
      * marker to separate.

\item[{\ttfamily  sixty!-four}] \index{{\ttfamily  sixty"!-four}}
      * Present if the Lisp was compiled for a 64-bit computer.

\item[{\ttfamily termed}] \index{{\ttfamily termed}}
      * Present if a cursor-addressable console was detected.

\item[{\ttfamily texmacs}] \index{{\ttfamily texmacs}}
      * Present if the system was launched with the {\ttfamily --texmacs} flag.
      * The intent is that this should only be done when it has been launched with
      * texmacs as a front-end.

\item[{\ttfamily win32}, {\ttfamily win64}] \index{{\ttfamily win32}, {\ttfamily win64}}
      * Any windows system puts {\ttfamily win32} in {\ttfamily lispsystem!*}.
      * If 64-bit windows is is use then {\ttfamily win64} is also included

\item[{\ttfamily windowed}] \index{{\ttfamily windowed}}
      * Present if CSL is running in its own window rather than in console mode.

\end{description} % end of lispsystem* section [restart.c]

% Generating section 04 [flags] with 5 subsections
\section{Flags and Properties}
  
Most of tags here are probably not much use to end-users, but I am
noting them as a matter of completeness.
  
\begin{description}

\item [{\ttfamily lose}] \index{{\ttfamily lose}}
  * If a name is flagged as {ttfamily lose} then a subsequent attempt to
  * define or redefine it will be ignored.

\item [{\ttfamily s!:ppchar} and {\ttfamily s!:ppformat}] \index{{\ttfamily s"!:ppchar} and {\ttfamily s!:ppformat}}
  * These are used in the prettyprint code found in {\ttfamily extras.red}. A
  * name is given a property {\ttfamily s!:ppformat} if in prettyprinted display
  * its first few arguments should appear on the same line as it if at all
  * possible. The {\ttfamily s!:ppchar} property is used to make the display of
  * bracket characters a little more tidy in the source code.

\item [{\ttfamily switch}] \index{{\ttfamily switch}}
  * In the Reduce parser some names are ``switches'', and then directives such
  * as {\ttfamily on xxx} and {\ttfamily off xx} have the effect of setting or
  * clearing the value of a variable {\ttfamily !*xxx}. This is managed by
  * setting the {\ttfamily switch} flag om {\ttfamily xxx}. CSL sets some
  * things as switches ready for when they may be used by the Reduce parser.

\item [{\ttfamily !$\sim$magic!-internal!-symbol!$\sim$}] \index{{\ttfamily "!$\sim$magic"!-internal"!-symbol"!$\sim$}}
  * CSL does not have a clear representation for functions that is separated from
  * the representation of an identifier, and so when you ask to get the value
  * of a raw function you get an identifier (probably a gensym) and this
  * tag is used to link such values with the symbols they were originally
  * extracted from.

\end{description} % end of flags section [csl.c]

% Generating section 05 [fns] with 120 subsections
\section{Functions and Special Forms}
  *
  * Each line here shows a name and then one of the words {\itshape  expr},
  * {\itshape  fexpr} or {\itshape  macro}. In some cases there can also be special
  * treatment of functions by the compiler so that they get compiled in-line.
  * \begin{description}

\item [{\ttfamily abs} {\itshape  expr}] \index{{\ttfamily abs} {\itshape  expr}} ~\newline
  * This takes one argument that should be a number -- and returns its absolute
  * value. In Common Lisp mode it would find the magnitude of a complex
  * number, but in normal Standard Lisp mode the only cases that arise are
  * integers are floating point values.

\item [{\ttfamily binary\_close\_input} {\itshape  expr}] \index{{\ttfamily binary\_close\_input} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_close\_output} {\itshape  expr}] \index{{\ttfamily binary\_close\_output} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_open\_input} {\itshape  expr}] \index{{\ttfamily binary\_open\_input} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_open\_output} {\itshape  expr}] \index{{\ttfamily binary\_open\_output} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_prin1} {\itshape  expr}] \index{{\ttfamily binary\_prin1} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_prin2} {\itshape  expr}] \index{{\ttfamily binary\_prin2} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_prin3} {\itshape  expr}] \index{{\ttfamily binary\_prin3} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_prinbyte} {\itshape  expr}] \index{{\ttfamily binary\_prinbyte} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_princ} {\itshape  expr}] \index{{\ttfamily binary\_princ} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_prinfloat} {\itshape  expr}] \index{{\ttfamily binary\_prinfloat} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_read2} {\itshape  expr}] \index{{\ttfamily binary\_read2} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_read3} {\itshape  expr}] \index{{\ttfamily binary\_read3} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_read4} {\itshape  expr}] \index{{\ttfamily binary\_read4} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_readbyte} {\itshape  expr}] \index{{\ttfamily binary\_readbyte} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_readfloat} {\itshape  expr}] \index{{\ttfamily binary\_readfloat} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_select\_input} {\itshape  expr}] \index{{\ttfamily binary\_select\_input} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily binary\_terpri} {\itshape  expr}] \index{{\ttfamily binary\_terpri} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily bps!-getv} {\itshape  expr}] \index{{\ttfamily bps"!-getv} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily bps!-putv} {\itshape  expr}] \index{{\ttfamily bps"!-putv} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily bps!-upbv} {\itshape  expr}] \index{{\ttfamily bps"!-upbv} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily break!-loop} {\itshape  expr}] \index{{\ttfamily break"!-loop} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily c\_out} {\itshape  expr}] \index{{\ttfamily c\_out} {\itshape  expr}} ~\newline
  * Not yet written

\item[{\ttfamily caaaar} {\itshape expr}] \index{{\ttfamily caaaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caaadr} {\itshape expr}] \index{{\ttfamily caaadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caaar} {\itshape expr}] \index{{\ttfamily caaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caadar} {\itshape expr}] \index{{\ttfamily caadar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caaddr} {\itshape expr}] \index{{\ttfamily caaddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caadr} {\itshape expr}] \index{{\ttfamily caadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item [{\ttfamily caar \ldots cddddr} {\itshape expr}] \index{{\ttfamily caar \ldots cddddr} {\itshape expr}} ~\newline
Names that start with {\ttfamily c}, then have a sequence of
{\ttfamily a} or {\ttfamily d}s and finally {\ttfamily r} provide
shorthand functions for chains of uses of {\ttfamily car} and
{\ttfamily cdr}. Thus for instance
{\ttfamily (cadar x)} has the same meaning as
{\ttfamily (car (cdr (car x)))}.

\item[{\ttfamily cadaar} {\itshape expr}] \index{{\ttfamily cadaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cadadr} {\itshape expr}] \index{{\ttfamily cadadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cadar} {\itshape expr}] \index{{\ttfamily cadar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily caddar} {\itshape expr}] \index{{\ttfamily caddar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cadddr} {\itshape expr}] \index{{\ttfamily cadddr} {\itshape expr}} ~\newline
see {\ttfamily caar} and {\ttfamily fourth}.

\item[{\ttfamily caddr} {\itshape expr}] \index{{\ttfamily caddr} {\itshape expr}} ~\newline
see {\ttfamily caar} and {\ttfamily third}.

\item [{\ttfamily  cadr} {\itshape expr}] \index{{\ttfamily  cadr} {\itshape expr}} ~\newline
see {\ttfamily caar} and {\ttfamily second}.

\item [{\ttfamily car} {\itshape expr}] \index{{\ttfamily car} {\itshape expr}} ~\newline
For a non-empty list the function {\ttfamily car} will return the
first element. For a dotted pair (created using {\ttfamily cons})
it extracts the first component. This is the fundamental low-level
data structure access function in Lisp. See {\ttfamily cdr} for the
function that returns the tail or a list or the second component of
a dotted pair. In CSL any attempt to take {\ttfamily car} of an atom
should be detected and will be treated as an error. If CSL had been
compiled in Common Lisp mode (which is now not probable) a special
exemption would apply and {\ttfamily car} and {\ttfamily cdr} of the
empty lisp {\ttfamily nil} would be {\ttfamily nil}.

\item[{\ttfamily car!*} {\itshape expr}] \index{{\ttfamily car"!*} {\itshape expr}} ~\newline
This function behaves like {\ttfamily car} except that if its argument
is atomic then the argument is returned unaltered rather than that case
being treated as an error.

\item[{\ttfamily cdaaar} {\itshape expr}] \index{{\ttfamily cdaaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdaadr} {\itshape expr}] \index{{\ttfamily cdaadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdaar} {\itshape expr}] \index{{\ttfamily cdaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdadar} {\itshape expr}] \index{{\ttfamily cdadar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdaddr} {\itshape expr}] \index{{\ttfamily cdaddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdadr} {\itshape expr}] \index{{\ttfamily cdadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdar} {\itshape expr}] \index{{\ttfamily cdar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddaar} {\itshape expr}] \index{{\ttfamily cddaar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddadr} {\itshape expr}] \index{{\ttfamily cddadr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddar} {\itshape expr}] \index{{\ttfamily cddar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdddar} {\itshape expr}] \index{{\ttfamily cdddar} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddddr} {\itshape expr}] \index{{\ttfamily cddddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cdddr} {\itshape expr}] \index{{\ttfamily cdddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item[{\ttfamily cddr} {\itshape expr}] \index{{\ttfamily cddr} {\itshape expr}} ~\newline
see {\ttfamily caar}.

\item [{\ttfamily cdr} {\itshape expr}] \index{{\ttfamily cdr} {\itshape expr}} ~\newline
See {\ttfamily car}.

\item [{\ttfamily char!-code} {\itshape  expr}] \index{{\ttfamily char"!-code} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily char!-downcase} {\itshape  expr}] \index{{\ttfamily char"!-downcase} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily char!-upcase} {\itshape  expr}] \index{{\ttfamily char"!-upcase} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily check!-c!-code} {\itshape  expr}] \index{{\ttfamily check"!-c"!-code} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily cl!-equal} {\itshape  expr}] \index{{\ttfamily cl"!-equal} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily close!-library} {\itshape  expr}] \index{{\ttfamily close"!-library} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily code!-char} {\itshape  expr}] \index{{\ttfamily code"!-char} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily compile!-all} {\itshape  expr}] \index{{\ttfamily compile"!-all} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily convert!-to!-evector} {\itshape  expr}] \index{{\ttfamily convert"!-to"!-evector} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily copy!-module} {\itshape  expr}] \index{{\ttfamily copy"!-module} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily create!-directory} {\itshape  expr}] \index{{\ttfamily create"!-directory} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily dated!-name} {\itshape  expr}] \index{{\ttfamily dated"!-name} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily define!-in!-module} {\itshape  expr}] \index{{\ttfamily define"!-in"!-module} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily delete!-file} {\itshape  expr}] \index{{\ttfamily delete"!-file} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily delete!-module} {\itshape  expr}] \index{{\ttfamily delete"!-module} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily do!*} {\itshape macro}] \index{{\ttfamily do"!*} {\itshape macro}} ~\newline
  * Not yet written

\item [{\ttfamily double!-execute} {\itshape  expr}] \index{{\ttfamily double"!-execute} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily enable!-backtrace} {\itshape  expr}] \index{{\ttfamily enable"!-backtrace} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily enable!-errorset} {\itshape  expr}] \index{{\ttfamily enable"!-errorset} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily eq!-safe} {\itshape  expr}] \index{{\ttfamily eq"!-safe} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily eval!-when} {\itshape  fexpr}] \index{{\ttfamily eval"!-when} {\itshape  fexpr}} ~\newline
  * Not yet written

\item [{\ttfamily file!-length} {\itshape  expr}] \index{{\ttfamily file"!-length} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily file!-readablep} {\itshape  expr}] \index{{\ttfamily file"!-readablep} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily file!-writeablep} {\itshape  expr}] \index{{\ttfamily file"!-writeablep} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily flagp!*!*} {\itshape  expr}] \index{{\ttfamily flagp"!*"!*} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily fp!-evaluate} {\itshape  expr}] \index{{\ttfamily fp"!-evaluate} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily funcall!*} {\itshape  expr}] \index{{\ttfamily funcall"!*} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily get!*} {\itshape  expr}] \index{{\ttfamily get"!*} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily get!-current!-directory} {\itshape  expr}] \index{{\ttfamily get"!-current"!-directory} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily get!-lisp!-directory} {\itshape  expr}] \index{{\ttfamily get"!-lisp"!-directory} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily hash!-table!-p} {\itshape  expr}] \index{{\ttfamily hash"!-table"!-p} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily hashtagged!-name} {\itshape  expr}] \index{{\ttfamily hashtagged"!-name} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily input!-libraries} {\itshape  fexpr}] \index{{\ttfamily input"!-libraries} {\itshape  fexpr}} ~\newline
  * Not yet written

\item [{\ttfamily instate!-c!-code} {\itshape  expr}] \index{{\ttfamily instate"!-c"!-code} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily internal!-open} {\itshape  expr}] \index{{\ttfamily internal"!-open} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily is!-console} {\itshape  expr}] \index{{\ttfamily is"!-console} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily let!*} {\itshape  fexpr}] \index{{\ttfamily let"!*} {\itshape  fexpr}} ~\newline
  * Not yet written

\item [{\ttfamily library!-members} {\itshape  expr}] \index{{\ttfamily library"!-members} {\itshape  expr}} ~\newline
  * Returns a list of all the modules that could potentially be loaded using
  * {\ttfamily load!-module}. See {\ttfamily list!-modules} to get a human
  * readable display that looks more like the result of listing a directory, or
  * {\ttfamily modulep} for checking the state of a particular named module.
  *

\item [{\ttfamily library!-name} {\itshape  expr}] \index{{\ttfamily library"!-name} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily list!*} {\itshape  fexpr}] \index{{\ttfamily list"!*} {\itshape  fexpr}} ~\newline
  * Not yet written

\item [{\ttfamily list!-directory} {\itshape  expr}] \index{{\ttfamily list"!-directory} {\itshape  expr}} ~\newline
  * Not yet written
  *

\item [{\ttfamily list!-modules} {\itshape  expr}] \index{{\ttfamily list"!-modules} {\itshape  expr}} ~\newline
  * This prints a human-readable display of the modules present in the current
  * image files. This will include ``InitialImage'' which is the heap-image
  * loaded at system startup. For example
  * {\footnotesize \begin{verbatim}
  * > (list!-modules)
  *
  * File d:\csl\csl.img (dirsize 8  length 155016, Writable):
  *   compat       Sat Jul 26 10:20:08 2008  position 556   size: 9320
  *   compiler     Sat Jul 26 10:20:08 2008  position 9880  size: 81088
  *   InitialImage Sat Jul 26 10:20:09 2008  position 90972 size: 64040
  *
  * nil
  * \end{verbatim}}
  *
  * See {\ttfamily library!-members} and {\ttfamily modulep} for functions that
  * make it possible for Lisp code to discover about the loadable modules that are
  * available.

\item [{\ttfamily list!-to!-string} {\itshape  expr}] \index{{\ttfamily list"!-to"!-string} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily list!-to!-symbol} {\itshape  expr}] \index{{\ttfamily list"!-to"!-symbol} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily list!-to!-vector} {\itshape  expr}] \index{{\ttfamily list"!-to"!-vector} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily list2!*} {\itshape  expr}] \index{{\ttfamily list2"!*} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily list3!*} {\itshape  expr}] \index{{\ttfamily list3"!*} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily load!-module} {\itshape  expr}] \index{{\ttfamily load"!-module} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily load!-source} {\itshape  expr}] \index{{\ttfamily load"!-source} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily lose!-precision} {\itshape  expr}] \index{{\ttfamily lose"!-precision} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily macro!-function} {\itshape  expr}] \index{{\ttfamily macro"!-function} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily macroexpand!-1} {\itshape  expr}] \index{{\ttfamily macroexpand"!-1} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily make!-bps} {\itshape  expr}] \index{{\ttfamily make"!-bps} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily make!-function!-stream} {\itshape  expr}] \index{{\ttfamily make"!-function"!-stream} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily make!-global} {\itshape  expr}] \index{{\ttfamily make"!-global} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily make!-random!-state} {\itshape  expr}] \index{{\ttfamily make"!-random"!-state} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily make!-simple!-string} {\itshape  expr}] \index{{\ttfamily make"!-simple"!-string} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily make!-special} {\itshape  expr}] \index{{\ttfamily make"!-special} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily math!-display} {\itshape  expr}] \index{{\ttfamily math"!-display} {\itshape  expr}} ~\newline
  * Not yet written

\item [{\ttfamily member!*!*} {\itshape  expr}] \index{{\ttfamily member"!*"!*} {\itshape  expr}} ~\newline
  * Not yet written

\item[{\ttfamily rplaca} {\itshape expr}] \index{{\ttfamily rplaca} {\itshape expr}} ~\newline
This is a destructive function in that it alters the data structure
that it is given as its first argument by updating its {\ttfamily car}
component. The result is the updated object. See {\ttfamily rplacd}
for the corresponding function for updating the {\ttfamily cdr} component.

\item [{\ttfamily rplacd} {\itshape expr}] \index{{\ttfamily rplacd} {\itshape expr}} ~\newline
See {\ttfamily rplaca}

\item [{\ttfamily !$\sim$block} {\itshape  fexpr}] \index{{\ttfamily "!$\sim$block} {\itshape  fexpr}} ~\newline
  * Not yet written

\item [{\ttfamily !$\sim$let} {\itshape  fexpr}] \index{{\ttfamily "!$\sim$let} {\itshape  fexpr}} ~\newline
  * Not yet written

\item [{\ttfamily !$\sim$tyi} {\itshape  expr}] \index{{\ttfamily "!$\sim$tyi} {\itshape  expr}} ~\newline
  * Not yet written

\end{description} % end of fns section [tempdoc.c]

% Generating section ~~~~~~~~ [index] with 0 subsections
% The index will go here
\printindex
\end{document}

