+++ Transcript to gf2.log started at Mon Jul 21 10:25:48 2025 +++
Reduce (CSL, rev 7150), 29-Jun-2025 ...




if !*csl then lisp force!-output!-radix 16$



operator vv;

gf2_vars {x, y, z};

d := prefix_to_gf2 (x^2*y + y^2 + z);
d := !*gf2(((0 . 3) (1 . 2) (2 . 1)), ((0 . 2) (2 . 2)), ((0 . 1) (3 . 1)))


%   ( ((0 . 3) (1 . 2) (2 . 1))
%     ((0 . 2) (2 . 2))
%     ((0 . 1) (3 . 1)) )

gf2_to_prefix d;
 2      2
x *y + y  + z



off sparse_gf2;

% For this test I will set the width of each field to just 4 bits. This
% then uses just one hex digit per exponent.
lisp (gf2_degree_bits := 3);
3


gf2_vars {x, y, z};

d := prefix_to_gf2 (x^2*y + y^2 + z);
d := !*gf2(3210, 2020, 1001)


%   ( 0x003002001000  0x002000002000 0x001000000001)
%       tot  x  y  z    tot  x  y  z   tot  x  y  z
% Except that here it will be (0x3210 0x2020 0x1001) because of the
% narrow fields.

gf2_to_prefix d;
 2      2
x *y + y  + z



on gf2_sparse;
***** gf2_sparse not defined as switch 



% I (ACN) do not know any really sensible examples to try here, so here
% are some starting points and maybe somebody who knows what they are doing
% can replace these with something better.

gf2_vars {x, y};

gf2_groeb{x^2 + y,
          x^3 + x};
  2         2
{x  + y,x*(x  + 1)}



gf2_vars {p, s, b, z, t, w};


gf2_groeb{p + s + b,
          p + t + s,
          w + p*s + b**2,
          w + p*t,
          w*p + *b**3,
          w + b*s + b**2};
{b + p + s,

 p + s + t,

  2
 b  + p*s + w,

 p*t + w,

  3
 b  + p*w,

  2
 b  + b*s + w}




end;






*** End-of-file read 

+++ Transcript closed at end of run +++
