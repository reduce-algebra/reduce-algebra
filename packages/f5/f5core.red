module f5core;
% f5 core. Main procedures of the F5 algorithm.

revision('f5core, "$Id$");

copyright('f5core, "(c) 2022 A. Demin, T. Sturm, MPI Informatics, Germany");

% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
%
%    * Redistributions of source code must retain the relevant
%      copyright notice, this list of conditions and the following
%      disclaimer.
%    * Redistributions in binary form must reproduce the above
%      copyright notice, this list of conditions and the following
%      disclaimer in the documentation and/or other materials provided
%      with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
% LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
% A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
% OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
% LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
% DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
% THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
% OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% *** Below is the list of all important procedures in this file, together
% with a short description of the F5 algorithm with the Rewritten Criterion
% that we implement. This is adapted from the algorithm outline given
% in the work by Christian Eder and John Perry in the second section
%   https://arxiv.org/pdf/0906.2967.pdf.
%
%   `core_groebner1`
%   `core_incrementalBasis`
%
%   The entry point is the `core_groebner1`. It receives a list of LabeledPolynomials
% {f1..fm} as an input. Further, we use the notions of "polynomial"
% and "labeled polynomial" interchangeably. `core_groebner1` repeatedly
% invokes `core_incrementalBasis` to construct Groebner bases of
% ideals {f1,f2}, {f1,f2,f3},..., {f1..fm}, in succession.
% LabeledPolynomials are stored in the data structure `r`. Data structure `r`
% is a `Basistracker` object (will be described further), which can be seen
% as a vector of LabeledPolynomials, e.g., [f1, f2, f3].
%   The lists `Gcurr`, `Gprev` are lists of integers. These integers are
% the indices of the corresponding elements in `r`. `Gcurr` contains the
% indices of the generators of {f1..fi}, and `Gprev` contains the indices
% of a Groebner basis of {f1..fi-1}, respectively.
% For example, for i = 4, r = [f1,f2,f3,f4], Gprev = {1, 3}, and Gcurr = {1, 3, 4},
% the list {f1,f3} is a Groebner basis for {f1,f2,f3}. `Gcurr` corresponds to
% {f1,f3,f4}, which is the previously computed Groebner basis (stored in `Gprev`)
% with f4 adjoined.
%   The goal of `core_incrementalBasis` is to compute a Groebner basis of {f1..fi}
% using the previously computed basis from `Gprev`. It achieves this by
% computing d-Groebner bases for d=0,1,2,... . The `core_incrementalBasis`
% iterates the following steps, which follow the general outline of
% Bucherger's algorithm:
%   - Generate a list of critical pairs by iterating `core_makeCriticalPair` on
%     all of the pairs of {currIdx} × Gprev, where {currIdx} is Gcurr \ Gprev.
%   - Identify critical pairs of the smallest degree, and compute the
%     necessary S-polynomials of smallest degree using `core_computeSpolys`.
%   - Reduce polynomials by passing the output of `core_computeSpolys`
%     to `core_reduction`.
%   - The output `R` of `core_reduction` indexes those polynomials in `r` that
%     did not reduce to zero; new critical pairs are generated by iterating
%     `core_makeCriticalPair` on all pairs (k, j) for k in R, j in Gcurr,
%     and `R` is appended to `Gcurr`.
%
%   `core_makeCriticalPair`
%   `core_computeSpolys`
%   `core_reduction`
%
%   We higlight the major differences between the above three functions and
% their counterparts in Buchberger’s algorithm. The `core_makeCriticalPair`
% constructs a critical pair for the given pair of indices of polynomials
% in `r`, discarding, however, any pair whose corresponding S-polynomial
% has a component that satisfies the F5 criterion or the Rewritten Criterion.
%   The list of Critical pairs is then passed to the `core_computeSpolys`.
% `core_computeSpolys` computes and returns a list of indices of
% S-polynomials in the `r` data structure, constructed from the given
% list of Critical Pairs. It disregards any S-polynomial with a component
% rewritable by the Rewritten Criterion.
%   The output of `core_computeSpolys` is passed to the `core_reduction`.
% The `core_reduction` iterates over S-polynomials, from the lowest
% signature to the highest. For each S-polynomial `r_k` in its input, it
% - Performs a complete (normal form) reduction of `r_k` by the previously
%   computed Groebner basis (stored in `Gprev` as indices).
% - Invokes `core_topReductionF5`, which top-reduces `r_k` by the current
%   set of generators (stored in `Gcurr`), subject to the following restrictions
%   1. `core_topReductionF5` invokes `core_findTopReducerF5` to find a
%      polynomial that can be a top-reducer. If it finds one,
%      `core_topReductionF5` may act in two different ways,
%      depending on the signature of the top-reduction. If the signature is
%      "signature-preserving", then the ordinary top-reduction takes place.
%      If the signature is not "signature-preserving", then `core_topReductionF5`
%      acts as if it is computing an S-polynomial, and thus generates a new
%      polynomial with the new higher signature.
%   2. Some top-reductions are forbidden, see the `core_findTopReducerF5`.
%      The practical result is that some polynomials in the intermediate
%      basis may not be fully top-reduced.
%
%   `core_addRule`
%   `core_isRewritable`
%   `core_findRewriting`
%   `core_isTopReducibleTerm`
%
%   `core_addRule` is invoked whenever `core_computeSpolys` or `core_reduction`
% generates a new polynomial, and records the signature of that polynomial.
%   `core_isRewritable` implements the Rewritten criterion. It is invoked
% every time a new S-polynomial is created, to determine if it is rewritable.
% `core_isRewritable` calls to the subroutine `core_findRewriting`, which
% scans the list of all rewrite rules recorded up to this point to find
% the first matching rewriter.
%   `core_isTopReducibleTerm` is called every time `core_makeCriticalPair`
% is called. `core_isTopReducibleTerm` is used to check the F5 criterion
% to determine if the critical pair is redundant.

% *** Notes on the implementation.
% In the implementation all polynomials are wrapped in the LabeledPolynomial
% type (interface implemented in f5lp.red). LabeledPolynomial provides
% the `lp_eval` function to access the polynomial part itself.

% Most of the functions below manipulate polynomials (represented as LabeledPolynomials).
% LabeledPolynomials are stored in the `Basistracker` struct, which is
% usually passed to functions as an argument with the name `r`. To get to
% these polynomials, integer indices are used.
% So, by saying "a polynomial at index k" we mean a polynomial that is
% stored in the Basistracker `r` at index k (our notation for this is `r_k`).
% To get the polynomial at the given index in `r`, `core_getPoly` is used.

% *** Approach to normal vs. sugar strategy, and additional sorting.
%
% There are several points where polynomials or critical pairs are sorted:
% 1. In the very beginning (before passing to core_groebner1), polynomials are sorted
%    by the leading term w.r.t. the current term order (before assigning signatures).
% 2. In each signature index (for each call of `core_incrementalBasis`),
%    critical pairs are sorted either by
%    * the total degree of the pair lcm (Normal strategy, f5sugar OFF)
%    * the sugar degree (Sugar strategy, f5sugar ON)
%    and a set of pairs with same degree is selected.
% 3. Pairs are passed to core_computeSpolys, where they are
%    * first, sorted by the pair lcm w.r.t. the current term order
%    * on output, S-polynomials are sorted by signature
% 4. The above ensures that S-polynomials are traversed in the order of
%    increasing signatures in core_reduction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CriticalPair

% The struct implements the usual critical pair interface:
% the pair stores information about two polynomials to construct
% an S-polynomial from it later.
% Assuming there exist two polynomials `f1` and `f2` and their S-polynomial is
%   u*f1 - v*f2
% then CriticalPair object is represented with a 7-item list
%   {'cp, tt, k, u, l, v, sugar}
% Where
%   tt is a Term, the lcm of the leading term of f1 and the leading term of f2,
%   k is an Integer, the index of `f1` in the Basistracker,
%   u is a Term, the multiplier of `f1`,
%   l is an Integer, the index of `f2` in the Basistracker,
%   v is a Term, the multiplier of `f2`,
%   sugar is an Integer, the sugar degree of corresponding S-polynomial.
%
% It is safe to assume that (k > l), or (k = l and u >= v).

asserted inline procedure core_CriticalPair(tt: Term, k: Integer, u: Term,
                                    l: Integer, v: Term, sugar: Integer): CriticalPair;
  {'cp, tt, k, u, l, v, sugar};

% Returns tt
asserted inline procedure core_getPairLcm(p: CriticalPair): Term;
   cadr p;

% Returns k . u1
asserted inline procedure core_getPairFirst(p: CriticalPair): DottedPair;
   (caddr p) . (cadddr p);

% Returns l . u2
asserted inline procedure core_getPairSecond(p: CriticalPair): DottedPair;
   (car cddddr p) . (cadr cddddr p);

% Returns sugar!
asserted inline procedure core_getPairSugar(p: CriticalPair): Integer;
   caddr cddddr p;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RewriteRule

% The struct implements rewrite rule interface. Rewrite Rule represents
% a signature that has already been produced during the f5 execution.
%
% A RewriteRule object is a list
%   {'rr, index, term}
% Here,
%   index is an Integer, an index of a polynomial for the Basistracker structure,
%   term is a Term, a multiplier for the signature.

asserted inline procedure core_RewriteRule(idx: Integer, tt: Term): RewriteRule;
   {'rr, idx, tt};

% Returns the rule index
asserted inline procedure core_getRuleIndex(r: RewriteRule): Integer;
   cadr r;

% Returns the rule term
asserted inline procedure core_getRuleTerm(r: RewriteRule): Term;
   caddr r;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Basistracker

% Implements the Basistracker struct. Basistracker is an object
% that stores all polynomials produced during f5 execution in a single vector.
% More precicely, a Basistracker instance is represented as
%   {'bt, polys, filled, capacity}
% Where
%   polys is a Vector of `Polynomial`s,
%   filled is an Integer equal to the number of elements added to `polys`,
%   capacity is an Integer equal to the length of `polys`.
%
% In a single core_groebner1 call, a single Basistracker object is created.
% A LabeledPolynomial can be added to the current Basistracker with `core_addPoly`,
% and accessed with `core_getPoly`. To get the index of the last polynomial added
% use `core_getBasisIdx`.
%
% It safe to assume that polynomials added to the current Basistracker
% are normalized (either monic if f5fractionfree if OFF,
%                 or with unit content if f5fractionfree is ON).

% The initial size of the `polys` vector in the `Basistracker`.
%
% We pick a big number from the start,
% so that there is no need to copy the storage vector often.
fluid '(core_initialBasisSize!*);
core_initialBasisSize!* := 10000;

% Creates an empty `Basistracker` with the given capacity
asserted procedure core_Basistracker(capacity: Integer): Basistracker;
   {'bt, mkvect(capacity), 0, capacity};

% Adds LabeledPolynomial f to the basis to the first available index
asserted procedure core_addPoly(r: Basistracker, f: LabeledPolynomial);
   begin scalar polys, newpolys;
         integer capacity, idx;
      polys := cadr r;
      idx := caddr r;
      capacity := cadddr r;
      % check if vector is overflowed.
      % If it is, double the size
      if idx >= capacity then <<
         capacity := capacity * 2;
         cadddr r := capacity;
         newPolys := mkvect(capacity);
         for i := 0:idx do
            putv(newPolys, i, getv(polys, i));
         cadr r := newPolys
      >>;
      % add polynmomial to the first free position
      putv(cadr r, caddr r, f);
      caddr r := caddr r #+ 1
   end;

% Sets the i'th polynomial in the basis to f
asserted inline procedure core_setPoly(r: Basistracker, i: Integer, f: LabeledPolynomial);
   putv(cadr r, i, f);

% Returns the i'th polynomial from the basis
asserted inline procedure core_getPoly(r: Basistracker, i: Integer): LabeledPolynomial;
   getv(cadr r, i);

% Returns the index of the last polynomial added to the basis
asserted inline procedure core_getBasisIdx(r: Basistracker): Integer;
   (caddr r) #- 1;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional comparators for sorting

% TODO: add the current term order cmp as a tie-breaker
asserted procedure core_pairTotalDegreeCmp(p1: CriticalPair,
                                            p2: CriticalPair): Boolean;
   poly_totalDegTerm(core_getPairLcm(p1)) #< poly_totalDegTerm(core_getPairLcm(p2));

asserted procedure core_pairSugarCmp(p1: CriticalPair,
                                            p2: CriticalPair): Boolean;
   core_getPairSugar(p1) #< core_getPairSugar(p2);

% Compares critical pairs by lcm term according to the current term order
asserted procedure core_pairLcmCmp(p1: CriticalPair,
                                    p2: CriticalPair): Boolean;
   poly_cmpTerm(core_getPairLcm(p1), core_getPairLcm(p2));

% Compare associative list elements by their value - a signature
asserted procedure core_assocSgnCmp(pr1: DottedPair,
                                      pr2: DottedPair): Boolean;
   lp_cmpSgn(lp_sgn(cdr pr1), lp_sgn(cdr pr2));

% Compare associative list elements by their value - length of polynomial part
asserted procedure core_assocLengthCmp(pr1: DottedPair,
                                      pr2: DottedPair): Boolean;
   poly_length(lp_eval(cdr pr1)) #< poly_length(lp_eval(cdr pr2));

% Compare associative list elements by their value - a leading term
% in the current term order
asserted procedure core_assocLeadCmp(pr1: DottedPair,
                                      pr2: DottedPair): Boolean;
   poly_leadTotalDegreeCmp(lp_eval(cdr pr1), lp_eval(cdr pr2));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% For the given list of polynomials `inputBasis` first
%   . interreduces input polynomials
%   . sorts them by the order on their leading terms
%     from the smallest to the largest
% and then constructs the list containing the standard basis of
% unit vectors corresponding to `inputBasis`, i.e.,
%   {f1,f2,f3}  -->  {(1,0,0), (0,1,0), (0,0,1)}.
% Each unit vector in the list is represented as a LabeledPolynomial.
asserted procedure core_constructModule(inputBasis: List): List;
   begin scalar outputModule;
         integer i;
      % Add assumptions when f5parametricNormalize
      if !*f5fractionfree then
         inputBasis := for each f in inputBasis collect
                           poly_scaleDenominators(f);
      % Interreducing input basis is a heuristic. The idea it to produce
      % polynomials with disjoint leading terms after interreduction if possible.
      inputBasis := core_interreduceInput(inputBasis);
      % Since F5 constructs the basis for the input polynomials {f1..fn} incrementally,
      % starting from constructing the basis for {f1,f2}, then for {f1,f2,f3}, and so on,
      % the order of input actually matters.
      % We sort polynomials w.r.t. the total degree of leading terms
      % from the smallest to the largest one, as described in the original F5.
      inputBasis := sort(inputBasis, 'poly_leadTotalDegreeCmp);
      i := 0;
      while inputBasis do <<
         push(lp_LabeledPolynomial1(pop(inputBasis), i), outputModule);
         i := i + 1
      >>;
      % if f5statistics is ON, initialize all statistics
      % for i - 1 input polynomials
      if !*f5statistics then
         stat_init(i - 1);
      return reversip(outputModule)
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Computes the normal form of f w.r.t. polynomials r_i where i in Gprev
%
% Two cases are possible:
%  1. At least one reduction step happened,
%     then we return the t flag together with the normal form itself;
%  2. No reductions were performed, then nil flag and f itself are returned.
%
% During reductions, the topReduce flag controls the reduction type.
% If topReduce is set, only top-reductions happen. Otherwise,
% the polynomial is fully reduced.
asserted procedure core_normalForm(f: Polynomial, Gprev: List,
                                   r: Basistracker,
                                   topReduce: Boolean): DottedPair;
   begin scalar updated, reducer, reduced, updatedToreturn;
      % while polynomial f gets updated by reduction steps,
      % scan the list Gprev in search for possible reducers
      repeat <<
         updated := nil;
         for each g in Gprev do <<
            reducer := lp_eval(core_getPoly(r, g));
            if not poly_iszero!?(reducer) and not poly_iszero!?(f) then <<
               reduced . f := if topReduce then
                  poly_tryTopReductionStep(f, reducer)
               else
                  poly_tryReductionStep(f, reducer);
               updated := reduced or updated
            >>
         >>;
         updatedToreturn := updated or updatedToreturn
      >> until not updated;
      return updatedToreturn . f
   end;

% Same as the above, but all possible reducers are
% already stored in the list `reducers` as Polynomial objects.
asserted procedure core_normalFormReducers(f: Polynomial, reducers: List,
                                              topReduce: Boolean): DottedPair;
   begin scalar updated, reducer, reduced, updatedToreturn;
      updated := t;
      while updated do <<
         updated := nil;
         for each reducer in reducers do <<
            if not poly_iszero!?(reducer) and not poly_iszero!?(f) then <<
               reduced . f := if topReduce then
                  poly_tryTopReductionStep(f, reducer)
               else
                  poly_tryReductionStep(f, reducer);
               updated := updated or reduced;
               updatedToreturn := updated or reduced
            >>
         >>
      >>;
      return updatedToreturn . f
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Returns `G` without the i-th element (starting from index 1), e.g.,
% for G = {8, 4, 5} and i = 2 returns {8, 5}
% (non mutating for `G`)
asserted procedure core_getReducers(i: Integer, G: List): List;
   begin scalar reducers, poly;
         integer j;
      j := 1;
      while G do <<
         poly := pop(G);
         if not (j #= i) then
            push(poly, reducers)
      >>;
      j := j #+ 1;
      return reducers
   end;

% Given the set of basis generators `input`,
% applies several (possibly, not all) passes of the Autoreduction algorithm
% until no further top-reductions happen
asserted procedure core_interreduceInput(input: List): List;
   begin scalar reducers, reducer, reduceme, reduced, f, ready, updated;
      updated := t;
      input := sort(input, 'poly_leadTotalDegreeCmp);
      input := for each f in input collect
         poly_normalize(f);
      while updated do <<
         updated := nil;
         ready   := nil;
         while input do <<
            reduceme := pop(input);
            reducers := input;
            while reducers and (not poly_iszero!?(reduceme)) do <<
               reducer := pop(reducers);
               reduced . reduceme := poly_tryTopReductionStep(reduceme, reducer);
               if reduced then <<
                  push(reducer, reducers);
                  updated := t
               >>
            >>;
            reducers := ready;
            while reducers and (not poly_iszero!?(reduceme)) do <<
               reducer := pop(reducers);
               reduced . reduceme := poly_tryTopReductionStep(reduceme, reducer);
               if reduced then <<
                  push(reducer, reducers);
                  updated := t
               >>
            >>;
            if not poly_iszero!?(reduceme) then
               push(poly_normalize(reduceme), ready)
         >>;
         input := ready
      >>;
      return ready
   end;

% Same as above, but
%   . input polynomials are stored in `Gprev` as indices to `r`,
%   . output polynomials are fully reduced (not only top-reduced)
asserted procedure core_interreduceBasis(Gprev: List, r: Basistracker): List;
   begin scalar reducers, updated, reduced, f, newGprev;
         integer i;
      updated := t;
      while updated do <<
         updated := nil;
         newGprev := nil;
         while Gprev do <<
            i := pop(Gprev);
            f := lp_eval(core_getPoly(r, i));
            reducers := append(newGprev, Gprev);
            reduced . f := core_normalForm(f, reducers, r, nil);
            updated := updated or reduced;
            lp_setEval(core_getPoly(r, i), f);
            if not poly_iszero!?(f) then
               push(i, newGprev)
         >>;
         Gprev := newGprev
      >>;
      return newGprev
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Part of the main F5 criterion.
% Checks if Term `m` is top-reducible by the previously computed
% Groebner basis, which consists of `r_i` for i in Gprev.
% If it is, returns t. Otherwise, returns nil
asserted procedure core_isTopReducibleTerm(m: Term, Gprev: List,
                                            r: Basistracker): Boolean;
   begin scalar glead, isReducible;
      while Gprev and (not isReducible) do <<
         glead := poly_leadTerm(lp_eval(core_getPoly(r, pop(Gprev))));
         if poly_dividesTerm!?(glead, m) then
            isReducible := t
      >>;
      return isReducible
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Adds rewrite rule to the vector of rules `Rule`.
% The added rule has the index equal to `k`, and the
% term equal to the term of `sgn`.
% The position of the new rule in `Rule` is the same as the index of `sgn`
asserted procedure core_addRule(Rule: Vector, sgn: Signature, k: Integer);
  begin scalar ruleS;
    ruleS := getv(Rule, lp_indexSgn(sgn));
    push(core_RewriteRule(k, lp_termSgn(sgn)), ruleS);
    putv(Rule, lp_indexSgn(sgn), ruleS)
  end;

% Searches for the first rewriter for signature u*sgn(r_k)
% and returns the index of it in `r`.
% If there are no proper rewriters other than self, returns `k`
asserted procedure core_findRewriting(u: Term, k: Integer,
                                r: Basistracker, Rule: Vector): Integer;
   begin scalar sgn, usgnt, foundRewriter, rulesAtSgn, ruleCurrent;
         integer rewriter;
      rewriter := k;
      sgn      := lp_sgn(core_getPoly(r, k));
      usgnt    := lp_termSgn(lp_mulSgn(sgn, u));
      rulesAtSgn := getv(Rule, lp_indexSgn(sgn));
      % Being careful with order of rules in rulesAtSgn:
      % we want to traverse the rules for the signature `sgn`
      % from the last to the first one in the order they were added,
      % and terminate as soon as the first matching rule was found
      while rulesAtSgn and (not foundRewriter) do <<
         ruleCurrent := pop(rulesAtSgn);
         foundRewriter := poly_dividesTerm!?(core_getRuleTerm(ruleCurrent), usgnt);
         if foundRewriter then
            rewriter := core_getRuleIndex(ruleCurrent)
      >>;
      return rewriter
   end;

% The Main Rewritten Criterion:
% Is signature u*sgn(r_k) rewritable by any rule from the `Rule`?
asserted inline procedure core_isRewritable(u: Term, k: Integer,
                                        r: Basistracker, Rule: Vector);
   not (core_findRewriting(u, k, r, Rule) #= k);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Filters polynomials `r_i` for i in Gprev, leaving only those
% with the leading term not divisible by the leading term of
% any other polynomial from `Gprev`.
% Returns the list of indices of polynomials in the filtered list.
asserted procedure core_filterRedundant(Gprev: List, r: Basistracker): List;
   begin scalar Gnew, alG, Gsorted, glead;
         integer gi;
      % Sort indices Gprev w.r.t. the leading terms of polynomials from in `r`
      alG := for each i in Gprev collect i . core_getPoly(r, i);
      alG := sort(alG, 'core_assocLeadCmp);
      Gsorted := for each pr in alG collect car pr;
      while Gsorted do <<
         gi := pop(Gsorted);
         glead := poly_leadTerm(lp_eval(core_getPoly(r, gi)));
         if not core_isTopReducibleTerm(glead, Gnew, r) then
            push(gi, Gnew)
      >>;
      return Gnew
   end;

% Normalizes each generator in the given `basis`.
% If f5fractionfree is OFF, then each polynomial
% in the basis is divided by its leading coeff;
% Otherwise, this divides each polynomial in
% the basis by the content.
asserted procedure core_normalizeBasis(basis: List): List;
   for each x in basis collect lp_normalize(x);

% Given a Groebner `basis` standardizes it,
% so that the output agrees with the following invariants:
%  . the basis is interreduced (if f5interreduce is OFF, only top-reductions are performed)
%  . the basis is normalized
%  . the basis is sorted by the order on the leading terms of its generators
asserted procedure core_standardizeOutput(basis: List): List;
   begin scalar normalizedBasis;
      normalizedBasis := core_normalizeBasis(basis);
      return sort(normalizedBasis, 'lp_cmpLPLeadReverse)
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Checks if the ideal generated by <polys> contains
% in the ideal generated by <basis>, assuming `basis` is a Groebner basis
asserted procedure core_checkIdealInclusion1(basis: List, polys: List);
   begin scalar included, poly, nf, flag_;
      % Computes the normal form of each polynomial from `polys`
      % with respect to the Groebner basis from `basis`
      included := t;
      basis    := for each f in basis collect lp_eval(f);
      while included and polys do <<
         poly := lp_eval(pop(polys));
         flag_ . nf := core_normalFormReducers(poly, basis, t);
         if not poly_iszero!?(nf) then
            included := nil
      >>;
      return included
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Checks if `basis` is a Groebner basis by checking that
% all S-polynomials reduce to zero
asserted procedure core_isGroebner1(basis: List);
   begin scalar isBasis, tmp, spoly, nf, flag_;
      isBasis := t;
      basis   := for each f in basis collect lp_eval(f);
      while basis do <<
         tmp := cdr basis;
         while isBasis and tmp do <<
            spoly := poly_spoly(car tmp, car basis);
            flag_ . nf := core_normalFormReducers(spoly, basis, t);
            if not poly_iszero!?(nf) then
            isBasis := nil;
            pop(tmp)
         >>;
         pop(basis)
      >>;
      return isBasis
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% For polynomial r_k at index k, searches for a possible top-reducer from
% the Groebner basis computed up to the previous signature index (from `Gprev`).
% A possible top-reducer should fulfill several criteria:
% First, it should be a top-reducer of `r_k` in a usual sense:
%   the leading term of `r_k` must be divisible by the leading term of top-reducer
% Secondly, top-reducer should admit a proper signature:
%   . The signature must be not equal to the signature of `r_k`,
%   . Top-reducer should be not rewritable AND not top-reducible itself
%
% If such top-reducer is found, return its index into r;
% if no such top-reducer was found, return 0
asserted procedure core_findTopReducerF5(k: Integer, Gprev: List, newGcurr: List,
                                  r: Basistracker, Rule: Vector): Integer;
   begin scalar tt, rk, rkEval, rkSgn, rj, u, rjSgnMult, tj;
         integer j, reducer;
      rk     := core_getPoly(r, k);
      rkEval := lp_eval(rk);
      rkSgn  := lp_sgn(rk);
      tt := poly_leadTerm(rkEval);
      for each j in newGcurr do <<
         rj := core_getPoly(r, j);
         tj := poly_leadTerm(lp_eval(rj));
         if (reducer #= 0) and poly_dividesTerm!?(tj, tt) then <<
            u := poly_divTerm(tt, tj);
            rjSgnMult := lp_mulSgn(lp_sgn(rj), u);
            if not lp_eqSgn(rjSgnMult, rkSgn) then
               if not core_isRewritable(u, j, r, Rule) then
                  if not core_isTopReducibleTerm(lp_termSgn(rjSgnMult), Gprev, r) then
                     reducer := j
         >>
      >>;
      return reducer
   end;

% Adapted from John Perry et al.
%   https://arxiv.org/abs/0906.2967
%
% The most tricky part in F5 reduction, the top-reduction function.
% If the LabeledPolynomial being examined has polynomial part 0, then there
% is no data left in that particular Labeled polynomial - an
% empty ordered pair is returned.
%
% Otherwise top-reduction calls upon another sub-routine core_findTopReducerF5.
% Essentially, if core_findTopReducerF5 returns 0, the current LabeledPolynomial
% is normalized and then it is added to the list `completed`
% defined within the core_reduction function.
%
% If a top-reduction is deemed possible, then there are two cases:
% either the reduction will increase the signature of the polynomial or it will not.
% In the latter case, the signature is preserved, the polynomial part
% is top-reduced and the LabeledPolynomial is added to the list `todo`
% in the core_reduction function.
% In the former case, however, the signature will change. This
% is marked by adding a new polynomial to r with appropriate
% signature which is equal to the signature of the top-reducer.
% A new rewrite rule is added and then
% both top-reduced and top-reducer polynomials and are added to the list `todo`
% in the core_reduction function. This is done because the
% top-reduced has a different signature than top-reducer and top-reducer might
% still be reducible by another LabeledPolynomial.
asserted procedure core_topReductionF5(k: Integer, Gprev: List, newGcurr: List,
                      r: Basistracker, Rule: Vector): DottedPair;
   begin scalar rk, rj, u, newpoly, reduced, reducerSgn, flag_;
         integer j;
      rk := core_getPoly(r, k);
      % if reduction to zero happened in the normal form -
      % meaning the system is not regular
      if lp_iszero!?(rk) then <<
         %  Reduction to zero happened!;
         if !*f5statistics then
            stat_incrementZeroReductions();
         return nil . nil
      >>;
      j := core_findTopReducerF5(k, Gprev, newGcurr, r, Rule);
      % no top reducers found in the previous Groebner basis --
      % top-reduction is not possible
      if j #= 0 then <<
         core_setPoly(r, k, lp_normalize(rk));
         return k . nil
      >>;
      % reducer rj found, perform top-reduction
      rj := core_getPoly(r, j);
      flag_ . reduced := poly_tryTopReductionStep(lp_eval(rk), lp_eval(rj));
      if not poly_iszero!?(reduced) then
         reduced := poly_normalize(reduced);
      % we need to check that the signature of reducer
      % is not greater than the signature of rj
      u := poly_divTerm(poly_leadTerm(lp_eval(rk)), poly_leadTerm(lp_eval(rj)));
      reducerSgn := lp_mulSgn(lp_sgn(rj), u);
      return if lp_cmpSgn(reducerSgn, lp_sgn(rk)) then <<
         % signatures OK, reduction is successful.
         % We form the new polynomial at index k,
         % and return it to reduction, to be reduced once again later
         lp_setEval(rk, reduced);
         core_setPoly(r, k, rk);
         nil . k . nil
      >> else <<
         % the signature of reducer is greater, reduction cannot be performed.
         % BUT, we still can form the new polynomial with the signature of reducer
         % for further reduction
         newpoly := lp_LabeledPolynomial2(reduced, reducerSgn);
         core_addPoly(r, newpoly);
         core_addRule(Rule, lp_sgn(newpoly), core_getBasisIdx(r));
         nil . k . core_getBasisIdx(r) . nil
      >>
   end;

% Inserts integer j in todo and returns the new resulting list,
% so that indices in todo are sorted increasingly by signatures
% of labeled polynomials indexed in r by todo
asserted procedure core_insertSorted(todo: List, j: Integer,
                                        r: Basistracker): List;
   begin scalar tmp, sj, s;
      if null todo then
         return {j};
      sj := lp_sgn(core_getPoly(r, j));
      s  := lp_sgn(core_getPoly(r, car todo));
      if lp_cmpSgn(sj, s) then
         return j . todo;
      tmp := todo;
      while cdr todo and lp_cmpSgn(lp_sgn(core_getPoly(r, cadr todo)), sj) do
         pop(todo);
      cdr todo := j . cdr todo;
      return tmp
   end;

% The main reduction function.
% Given indices of S-polynomials in the list S, computes
% the F5-style reduction of each of the polynomial indexed by S.
%
% By F5-style reduction we mean a normal form,
% with respect to the previously computed Groebner basis,
% combined with a top-reduction that does not change the signature.
asserted procedure core_reduction(S: List, Gprev: List, Gcurr: List,
                                    r: Basistracker, Rule: Vector): List;
   begin scalar todo, S, completed, newGcurr, rk, reduced,
         newcompleted, redo, flag_;
         integer k, j, nNormalForms;
      % For each polynomial f the reduction process is the following.
      % First, this polynomial is placed in the `todo` list from the beginning.
      % Secondly, when f is popped from the list, the normal form of f with
      % respect to the basis computed up to this module index (in Gprev) is produced.
      % Since during the normal form computation it is possible that not all feasible
      % reducers were handled, a separate top-reduction step is needed.
      % This is handled by the core_topReductionF5, which is called on the
      % result of the normal form.
      %
      % core_topReductionF5 returns a pair of two lists:
      %   newcompleted and redo
      % Elements from redo are inserted back to the todo list,
      % and the elements of newcompleted are considered fully reduced.
      %
      todo := S;
      newGcurr := copy(Gcurr);
      while todo do <<
         k := pop(todo);
         rk := core_getPoly(r, k);
         % Compute the normal form;
         % If full reduction is not needed, computes only the top normal form.
         % Otherwise, reduces all terms in the polynomial.
         flag_ . reduced := core_normalForm(lp_eval(rk), Gprev, r, t);
         nNormalForms := nNormalForms + 1;
         lp_setEval(rk, reduced);
         core_setPoly(r, k, rk);
         % Compute the F5-style top-reduction;
         newcompleted . redo := core_topReductionF5(k, Gprev, newGcurr, r, Rule);
         if newcompleted then <<
            push(newcompleted, completed);
            push(newcompleted, newGcurr)
         >>;
         for each j in redo do
            todo := core_insertSorted(todo, j, r)
      >>;
      if !*f5statistics then
         stat_updateReductions(length(S), nNormalForms);
      return completed
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Adapted from John Perry et al.
%   https://arxiv.org/abs/0906.2967
%
% Though at first glance this subroutine may look complicated,
% core_computeSpolys essentially does one thing: form the new
% S-polynomials output as LabeledPolynomials.
% We note that, because core_makeCriticalPair ensured
% that sgn(u*k) > sgn(v*l), we know that the signature of all new
% polynomials will always be of the form u_k*sgn(r_k) in core_computeSpolys.
asserted procedure core_computeSpolys(pairs: List, r: Basistracker,
                                        Rule: Vector): List;
   begin scalar S, p, u, v, lpk, lpl, alS, seval, ssgn;
         integer l, k;
      % TODO: Try sorting pairs by total degree>?
      pairs := sort(pairs, 'core_pairLcmCmp);
      while pairs do <<
         p := pop(pairs);
         k . u := core_getPairFirst(p);
         l . v := core_getPairSecond(p);
         % Rewritten criterion
         if (not core_isRewritable(u, k, r, Rule)) and (not core_isRewritable(v, l, r, Rule)) then <<
            % Here, an assumption happens: 
            % in S-polynomial t1*lpk - t2*lpl 
            % leading coefficients leadcoeff(lpk) and leadcoeff(lpl) do not vanish
            lpk := core_getPoly(r, k);
            lpl := core_getPoly(r, l);
            if !*f5parametric then <<
               param_addAssumptionSpol(poly_leadCoeff(lp_eval(lpk)));
               param_addAssumptionSpol(poly_leadCoeff(lp_eval(lpl)))
            >>;
            seval := poly_spoly(lp_eval(lpk), lp_eval(lpl));
            ssgn  := lp_mulSgn(lp_sgn(lpk), u);
            if not poly_iszero!?(seval) then
               seval := poly_normalize(seval);
            core_addPoly(r, lp_LabeledPolynomial2(seval, ssgn));
            core_addRule(Rule, ssgn, core_getBasisIdx(r));
            if not poly_iszero!?(seval) then
               push(core_getBasisIdx(r), S)
         >>
      >>;
      % Sort indices S w.r.t. signatures of polynomials stored in r
      alS := for each i in S collect i . core_getPoly(r, i);
      alS := sort(alS, 'core_assocSgnCmp);
      S := for each pr in alS collect car pr;
      return S
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Constructs a CriticalPair from polynomials in `r` at indices `k` and `l`.
% Returns a CriticalPair object. If the pair is deemed redundant by
% the F5 or by the rewritten criterion, the CriticalPair is nil.
asserted procedure core_makeCriticalPair(i: Integer, k: Integer, l: Integer,
                    Gprev: List, r: Basistracker, Rule: Vector): CriticalPair;
   begin scalar rk, rl, tk, tl, tt, u1, u2, usgn1, usgn2;
         integer i, sugar;
      rk := core_getPoly(r, k);
      rl := core_getPoly(r, l);
      tk := poly_leadTerm(lp_eval(rk));
      tl := poly_leadTerm(lp_eval(rl));
      % tt = lcm(leadTerm(rk), leadTerm(rl))
      tt := poly_lcmTerm(tk, tl);
      % so that u1*rk - u2*rl is S-polynomial
      u1 := poly_subExp(tt, tk);
      u2 := poly_subExp(tt, tl);
      % signatures of u1*rk and u2*rl
      usgn1 := lp_mulSgn(lp_sgn(rk), u1);
      usgn2 := lp_mulSgn(lp_sgn(rl), u2);
      % F5 criterion
      if (lp_indexSgn(usgn1) #= i) and core_isTopReducibleTerm(lp_termSgn(usgn1), Gprev, r) then
         return nil;
      if (lp_indexSgn(usgn2) #= i) and core_isTopReducibleTerm(lp_termSgn(usgn2), Gprev, r) then
         return nil;
      % Rewritten criterion
      if core_isRewritable(u1, k, r, Rule) or core_isRewritable(u2, l, r, Rule) then
         return nil;
      % the pair should be ordered
      if lp_cmpSgn(usgn1, usgn2) then <<
         u1 . u2 := u2 . u1;
         k . l := l . k
      >>;
      sugar := max(poly_totalDegTerm(u1) + poly_getSugar(lp_eval(rk)),
                     poly_totalDegTerm(u2) + poly_getSugar(lp_eval(rl)));
      return core_criticalPair(tt, k, u1, l, u2, sugar)
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Sugar selection strategy for core_selectPairs
asserted procedure core_selectPairsSugar(pairs: List): List;
   begin scalar selectedPairs, p;
         integer deg;
      pairs := sort(pairs, 'core_pairSugarCmp);
      p := pop(pairs);
      selectedPairs := {p};
      deg := core_getPairSugar(p);
      while pairs and (core_getPairSugar(car pairs) #= deg) do
         push(pop(pairs), selectedPairs);
      return selectedPairs . pairs
   end;

% Normal selection strategy for core_selectPairs
asserted procedure core_selectPairsNormal(pairs: List): List;
   begin scalar selectedPairs, p;
         integer deg;
      pairs := sort(pairs, 'core_pairTotalDegreeCmp);
      p := pop(pairs);
      selectedPairs := {p};
      deg := poly_totalDegTerm(core_getPairLcm(p));
      while pairs and (poly_totalDegTerm(core_getPairLcm(car pairs)) #= deg) do
         push(pop(pairs), selectedPairs);
      return selectedPairs . pairs
   end;

% Given a list of critical pairs, selects several (at least one) pairs
% according to current selection strategy and returns them as a new list.
% Also returns the input list, but without selected pairs.
asserted inline procedure core_selectPairs(pairs: List): DottedPair;
   if !*f5sugar then
      core_selectPairsSugar(pairs)
   else
      core_selectPairsNormal(pairs);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Interreduces elements in the Groebner basis stored in the list Gprev,
% while maintaining correct signatures in `r` and correct rewrite rules in `Rule`
asserted procedure core_setupReducedBasis(Gprev: List, r: Basistracker, 
                                             Rule: Vector): List;
   begin scalar f, B, Btmp;
         integer i;
      % `Rule` is not used intentionally
      Gprev := core_interreduceBasis(Gprev, r);
      B := for each f in Gprev collect core_getPoly(r, f);
      Gprev := for i := 1:length(B) collect i;
      Btmp := B;
      for i := 1:length(B) do <<
         f := pop(Btmp);
         core_setPoly(r, i, lp_LabeledPolynomial1(f, i))
      >>;
      % `Rule` is not used intentionally
      % for i := 1:length(B) do <<
      %    % 
      %    for j := 1:length(B) do <<
      %       % 
      %    >>
      % >>;
      return Gprev
   end;                              

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Given that `Gprev` indexes the basis of {f1..fi-1} in `r`,
% constructs the basis of {f1..fi} and returns the list of new basis indices
asserted procedure core_incrementalBasis(i: Integer, Gprev: List,
                          r: Basistracker, Rule: Vector): List;
   begin scalar Gcurr, pairs, p, S, selectedPairs, reduced, k, tmp, alGprev;
         integer i, j, currIdx, nCurrentPairs;
      % The function is organized in the following way.
      % In the very beginning, some initial critical pairs are constructed
      % and added to the list `pairs`. Pairs are formed using
      % the r_currIdx polynomial and the generators of {f1..fi-1}.
      % Then, while the `pairs` list is not empty, all pairs of the smallest
      % degree of the lcm part are chosen and deleted from `pairs`. These pairs
      % are then transformed into S-polynomials with the `core_computeSpolys`.
      % S-polynomials are passed into the `core_reduction`, which returns
      % the indices of new basis members. These new polynomials
      % are used to produce new critical pairs, which are inserted in `pairs`.
      currIdx := core_getBasisIdx(r);
      Gcurr   := copy(Gprev);
      % received new generator at index currIdx, add it to the list..
      push(currIdx, Gcurr);
      % and produce critical pairs with currIdx and every previous generator
      for each j in Gprev do <<
         p := core_makeCriticalPair(i, currIdx, j, Gprev, r, Rule);
         if p then
            push(p, pairs)
      >>;
      % A heuristic: sort previous generators by their length, ascending;
      % In that way polynomial reductions with less number of terms
      % will happen first
      alGprev := for each i in Gprev collect i . core_getPoly(r, i);
      alGprev := for each pr in alGprev join if (not poly_iszero!?(cdr pr)) then {pr} else nil;
      alGprev := sort(alGprev, 'core_assocLengthCmp);
      Gprev   := for each pr in alGprev collect car pr;
      if !*f5statistics then
         stat_updatePairs(length(pairs));
      % construct d-Groebner bases for d=0,1,2,..., incrementally
      while pairs do <<
         % first, select critical pairs and store them to selectedPairs list
         selectedPairs . pairs := core_selectPairs(pairs);
         % compute S-polynomials of selected critical pairs..
         S := core_computeSpolys(selectedPairs, r, Rule);
         % and reduce S-polynomials by the previously computed
         % Groebner basis (Gprev), and the current generators (Gcurr)
         reduced := core_reduction(S, Gprev, Gcurr, r, Rule);
         reduced := reversip(reduced);
         nCurrentPairs := 0;
         if !*f5statistics then <<
            nCurrentPairs := length(pairs)
         >>;
         % form new critical pairs and insert them in the `pairs` list
         while reduced do <<
            k := pop(reduced);
            tmp := Gcurr;
            while tmp do <<
               j := pop(tmp);
               p := core_makeCriticalPair(i, j, k, Gprev, r, Rule);
               if p then
                  push(p, pairs)
            >>;
            push(k, Gcurr)
         >>;
         if !*f5statistics then <<
            stat_updateIncremental(
               poly_totalDegTerm(core_getPairLcm(car selectedPairs)),
               length(pairs) - nCurrentPairs
            )
         >>
      >>;
      return Gcurr
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The heart of the package, --
% the function takes a list of LabeledPolynomials as ideal generators,
% and returns a standardized Groebner basis of this ideal as output
%
% Output contracts:
%   . the output basis is top-reduced, meaning the number of generators is minimal,
%   . the output basis is sorted,
%   . the output basis contains only normalized polynomials,
%   . if f5interreduce is ON, then the output basis is fully reduced
asserted procedure core_groebner1(basis: List): List;
   begin scalar f1, r, Gprev, Rule, fi;
         integer m, i;
      m  := length(basis);
      % f1 - first polynomial added to the basis
      f1 := pop(basis);
      f1 := lp_normalize(f1);
      r := core_Basistracker(core_initialBasisSize!*);
      core_addPoly(r, f1);
      % Gprev indexes generators of the current basis in the Basistracker `r`,
      % So, Gprev := {0} indexes the basis of {f1}
      Gprev := {0};
      % Vector of RewriteRules
      Rule := mkvect(m);
      i := 1;
      % Incremental construction from index 1 to index m-1
      while i #< m do <<
         fi := pop(basis);
         fi := lp_normalize(fi);
         core_addPoly(r, fi);
         putv(Rule, i, nil);
         if !*f5statistics then
            stat_updateModuleIndex();
         % construct the basis for {f1...fi} using the basis for {f1...fi-1}
         Gprev := core_incrementalBasis(i, Gprev, r, Rule);
         % Experimantal functionality, use F5C if f5usef5c switch is ON.
         if !*f5usef5c then
            Gprev := core_setupReducedBasis(Gprev, r, Rule);
         i := i #+ 1
      >>;
      % filter redundant generators
      Gprev := core_filterRedundant(Gprev, r);
      if !*f5interreduce then
         Gprev := core_interreduceBasis(Gprev, r);
      basis := for each i in Gprev collect core_getPoly(r, i);
      if !*f5statistics then
         stat_print();
      return core_standardizeOutput(basis)
   end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

endmodule;  % end of module f5core

end;  % of file
