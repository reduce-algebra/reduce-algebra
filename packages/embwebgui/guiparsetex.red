module guiparsetex;

/**************************************************************************
 * Copyright (C) 2022,                                   E. Schruefer     *
 *                                                                        *
 * Redistribution and use in source and binary forms, with or without     *
 * modification, are permitted provided that the following conditions are *
 * met:                                                                   *
 *                                                                        *
 *     * Redistributions of source code must retain the relevant          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer.                                                      *
 *     * Redistributions in binary form must reproduce the above          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer in the documentation and/or other materials provided  *
 *       with the distribution.                                           *
 *                                                                        *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE         *
 * COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,   *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   *
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  *
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND *
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  *
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF     *
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
 * DAMAGE.                                                                *
 *************************************************************************/


% Very simplistic parser for Latex generated by MathLive.
% Tokenization of latex keywords (starting with a backslash)
% is done by providing a 'tokprop' function for backslash.
% This function prepends the latex keyword with an escaped
% backslash. Dekorative latex directives like spacing (\:, ..)
% and sizing (\left, ..) are skipped over. The wrapper '\mathrm' for
% multicharacter id's is stripped off.
% The actual parsing of latex expressions is performed by associating
% a parse function (via a stat property) with the latex tokens. Here  
% things like converting curly brackets to argument brackets etc. is
% taken care of.


fluid '(!*fancy!-out!-noheader !*multilines !*ignoreLatexEOL);
global '(crchar!* ttype!* cursym!* nxtsym!*);

symbolic procedure readlatextoken;
   begin scalar l;
      crchar!* := readch1();
      if (crchar!* eq '!\ ) and null !*ignoreLatexEOL
         then <<crchar!* := readch1(); return !$eol!$>>;
      if (crchar!* memq '(!! !; !, !: !  )) or
         (!*ignoreLatexEOL and (crchar!* eq '!\)) 
         then <<crchar!* := readch1();
                return token()>>;
      if crchar!* memq '(!{ !} ![ !]) then return token();
      l := crchar!* . l;
      while null digit(crchar!* := readch1()) and liter crchar!* do
         l := crchar!* . l;
      ttype!* := 3;
      l := compress('!\ . reverse l);
      if l memq '(!\left !\right !\quad) 
         then return token();
      if (l eq '!\mathrm) or (l eq '!\operatorname) 
         then <<crchar!* := readch1();
                l := token();
                crchar!* := readch1();
                return l>>;
      if l eq '!\lbrace then return '!{;
      if l eq '!\rbrace then return '!};
      if l eq '!\lbrack then return '![;
      if l eq '!\rbrack then return '!];
%      if l eq '!\langle then return '!<;
%      if l eq '!\rangle then return '!>;
      if l eq '!\quote 
         then <<peekchar!* := crchar!* . peekchar!*;
                return tokquote()>>;
      return l
   end;

switch readlatextoken=off;
put('readlatextoken, 'simpfg,
    '((t (put '!\ 'tokprop 'readlatextoken))
      (nil (remprop '!\ 'tokprop))));
    
switch latexout=off;
put('latexout, 'simpfg,
    '((t (progn (load "tmprint") (onoff 'fancy t)
                (put 'times 'fancy!-prtch "\cdot ")
                (setq !*fancy!-out!-noheader t)
                (setq !*multilines t)
                (onoff 'nat t)))
      (nil (progn (onoff 'fancy nil)
                  (setq !*fancy!-out!-noheader nil)
                  (setq !*multilines nil)
                  ))));

  
symbolic procedure latexOpStat;
   begin scalar op, args, x;
     op := cursym!*;
     if null(scan() eq '!*lcbkt!*)
        then return op;        
     a: args := cadr xreadlist() . args;
        if cursym!* eq '!*lcbkt!*
           then go to a;
     if x := get(op, 'converLatexName) then op := x;  
     return op . reverse args;
  end;
  
symbolic procedure latexOperatornameStat; latexTextStat();

  
symbolic procedure latexTextStat;
   begin scalar arg;
     scan();  
 %    arg := xread t;
     arg:= scan();
     scan();
     scan();
     return arg
  end;
  
  
symbolic procedure latexSqrtStat;
   begin scalar op, args, x;
     op := cursym!*;     
     if (x := scan()) eq '!*lsqbkt!* 
        then args := cadr readprogn() . args;
    args := cadr xreadlist() . args;
    if x := get(op, 'converLatexName) then op := x;
    if length args > 1 then return {'expt, car args, 'recip . cdr args};
    return 'sqrt . reverse args;
  end;
  
symbolic procedure latexSubSupStat;
   begin scalar x, args;
     scan();
     args := cadr xreadlist() . args;
     a: args := (if nxtsym!* eq '!^ 
                    then <<scan();
                           '!^ . cdr cadadr xreadlist()>>
                  else if nxtsym!* eq '!_ 
                    then <<scan();
                           '!_ . cdr cadadr xreadlist()>>) . args;
        if cursym!* eq '!*lcbkt!*
           then go to a;
        if cursym!* eq '!*lpar!*
           then args := xread1 t . args;   %%%% CHECK ME!
     return 'indexstruct . reverse args;
   end;
     
symbolic procedure latexBeginEnvStat;
   begin scalar envir, x;
     scan();
     envir := scan();
     scan();
     if x := get(envir, 'latexEnvStat)
        then return apply1(x, envir)
      else rederr "Unknown LaTeX environment";
   end;
   
put('!\begin, 'stat, 'latexBeginEnvStat);

symbolic procedure latexMultlineStat(u);
   begin scalar x, !*ignoreLatexEOL;
     !*ignoreLatexEOL := t;
     flag('(!\end), 'delim);
     x := xread nil;
     remflag('(!\end), 'delim);
     scan();
     scan();
     if null(u eq scan()) then rederr "Wrong environment end.";
     cursym!* := '!*semicol!*;
     return x
   end;
   
put('multline, 'latexEnvStat, 'latexMultlineStat);

symbolic procedure latexMatrixStat(u);
   begin scalar x, m, !*ignoreLatexEOL;
     flag('(& !\end), 'delim);
     flag(list(!$eol!$), 'delim);
     a: x := xread nil . x;
        if cursym!* eq '& then go to a;
     m := reverse x . m;
     x := nil;
     if cursym!* eq !$eol!$ then go to a;
     remflag('(& !\end), 'delim);
     remflag(list(!$eol!$), 'delim);
     scan();
     if null(u eq scan()) then rederr "Wrong environment end.";
     if (u eq 'pmatrix) or (u eq 'smallmatrix)
        then u := 'mat;
     scan();
     scan();
     return u . reverse m
     end;
 
put('pmatrix, 'latexEnvStat, 'latexMatrixStat);
put('bmatrix, 'latexEnvStat, 'latexMatrixStat);
put('Bmatrix, 'latexEnvStat, 'latexMatrixStat);
put('vmatrix, 'latexEnvStat, 'latexMatrixStat);
put('Vmatrix, 'latexEnvStat, 'latexMatrixStat);
put('smallmatrix, 'latexEnvStat, 'latexMatrixStat);

put('cases, 'latexEnvStat, 'latexMatrixStat);
  
deflist('((!\frac latexOpStat) (!\int latexOpStat) (!\df latexOpStat)
          (!\sqrt latexSqrtStat)), 'stat);
%put('!\sin, 'simpfn, 'simpiden); 
% Hm, we would need a macrofn for something like this to work when the
% object has a stat property.


put('!\coloneq, 'newnam, 'setq);
put('!\cdot, 'newnam, 'times);

put('!\frac, 'converLatexName, 'quotient);
%put('!\sqrt, 'converLatexName, 'sqrt);
put('!\sin, 'newnam, 'sin);
put('!\quote, 'newnam, 'quote);
put('!\operatorname, 'stat, 'latexOperatornameStat);
put('!\mathrm, 'stat, 'latexOperatornameStat);
put('!\mathtt, 'stat, 'latexOperatornameStat);
put('!\mathnormal, 'stat, 'latexOperatornameStat);
put('!\mathit, 'stat, 'latexOperatornameStat);
put('!\text, 'stat, 'latexTextStat);
put('!\enskip, 'stat, 'latexSubSupStat);

put('!\pi, 'newnam, 'pi);

endmodule;

end;
