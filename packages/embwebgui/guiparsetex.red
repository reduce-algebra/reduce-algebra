module guiparsetex;

/**************************************************************************
 * Copyright (C) 2022,                                   E. Schruefer     *
 *                                                                        *
 * Redistribution and use in source and binary forms, with or without     *
 * modification, are permitted provided that the following conditions are *
 * met:                                                                   *
 *                                                                        *
 *     * Redistributions of source code must retain the relevant          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer.                                                      *
 *     * Redistributions in binary form must reproduce the above          *
 *       copyright notice, this list of conditions and the following      *
 *       disclaimer in the documentation and/or other materials provided  *
 *       with the distribution.                                           *
 *                                                                        *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE         *
 * COPYRIGHT OWNERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,   *
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   *
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  *
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND *
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR  *
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF     *
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
 * DAMAGE.                                                                *
 *************************************************************************/


% Very simplistic parser for Latex generated by MathLive.
% Dekorative latex directives like spacing (\:, ..)
% and sizing (\left, ..) are skipped over. The wrapper '\mathrm' for
% multicharacter id's is stripped off.
% The actual parsing of latex expressions is performed by associating
% a parse function (via a stat property) with the latex tokens.  


fluid '(!*fancy!-out!-noheader !*multilines !*ignoreLatexEOL);
global '(cursym!* nxtsym!*);


newtok '((!\) !\);

% Some LaTeX tokens we ignore (e.g. spacing, alignments).

symbolic procedure skipOverLatexCmd;
   begin
     cursym!* := '!*semicol!*;
     return scan()
   end;

newtok '((!\ !!) !\!!);
newtok '((!` !;) !\!;);
newtok '((!\ !,) !\!,);
newtok '((!\ !:) !\!:);
newtok '((!\ l e f t) !\left);
newtok '((!\ r i g h t) !\right);
newtok '((!\ q u a d) !\quad);
newtok '((!\ !\) !\!\);

deflist('((!\!! skipOverLatexCmd) (!\!; skipOverLatexCmd)
          (!\!, skipOverLatexCmd) (!\!: skipOverLatexCmd)
          (!\left skipOverLatexCmd) (!\right skipOverLatexCmd)
          (!\quad skipOverLatexCmd) (!\!\ skipOverLatexCmd)),
         'scan_action!*);

% invisible times:
%newtok '((!\ u n i c o d e !2 !0 !6 !2) !\unicode2062);

%flag('(!\unicode2062), 'need_termination);

%put('!\unicode2062, 'scan_action!*, 'invisibleTimes2Times);

%symbolic procedure invisibleTimes2Times;
%   begin
%     token();
%     return cursym!* := 'times
%   end; 

% this is better than using unicode.

newtok '((!\ v p h a n t o m) !\vphantom);
put('!\vphantom, 'scan_action!*, 'readVPhantomCmd);

symbolic procedure readVPhantomCmd;
   begin scalar arg, x;
     token();
     arg := token();
     if x := get(arg, 'phantomArg) then arg := x;
     token();
     token();
     return cursym!* := arg
  end;

put('!*, 'phantomArg, 'times);

% Conversion of brackets.

newtok '((!\ l b r a c e) !*lcbkt!*);
newtok '((!\ r b r a c e) !*rcbkt!*);
newtok '((!\ l b r a c k) !*lsqbkt!*);
newtok '((!\ r b r a c k) !*rsqbkt!*);
newtok '((!\ l a n g l e) lessp);
newtok '((!\ r a n g l e) greaterp);

  

switch readlatextoken=off;
put('readlatextoken, 'simpfg,
    '((t (load "embwebgui"))
%     (nil (remprop '!\ 'switch!*))
     ));
    
switch latexout=off;
put('latexout, 'simpfg,
    '((t (progn (load "tmprint") (onoff 'fancy t)
%                (put 'times 'fancy!-prtch "\cdot ")
                (put 'times 'fancy!-prtch "\unicode{x2062}")
                (setq !*fancy!-out!-noheader t)
                (setq !*multilines t)
                (onoff 'nat t)))
      (nil (progn (onoff 'fancy nil)
                  (setq !*fancy!-out!-noheader nil)
                  (setq !*multilines nil)
                  ))));


% Operators.

newtok '((!\ f r a c) !\frac);
newtok '((!\ t f r a c) !\tfrac);
newtok '((!\ d f r a c) !\dfrac);
put('!\frac, 'stat, 'latexOpStat);
put('!\dfrac, 'stat, 'latexOpStat);
put('!\tfrac, 'stat, 'latexOpStat);
put('!\frac, 'converLatexName, 'quotient);
put('!\dfrac, 'converLatexName, 'quotient);
put('!\tfrac, 'converLatexName, 'quotient);  

symbolic procedure latexOpStat;
   begin scalar op, args, x;
     op := cursym!*;
     if null(scan() eq '!*lcbkt!*)
        then return op;        
     a: args := cadr xreadlist() . args;
        if cursym!* eq '!*lcbkt!*
           then go to a;
     if x := get(op, 'converLatexName) then op := x;  
     return op . reverse args;
  end;
  
% Text.

newtok '((!\ t e x t) !\text);
put('!\text, 'stat, 'latexTextStat);

symbolic procedure latexOperatornameStat; latexTextStat();

symbolic procedure latexTextStat;
   begin scalar arg;
     scan();  
     arg := scan();
     scan();
     cursym!* := '!*semicol!*;
     return arg
  end;

% Surds.

newtok '((!\ s q r t) !\sqrt);

put('!\sqrt, 'stat, 'latexSqrtStat);  
  
symbolic procedure latexSqrtStat;
   begin scalar op, args, x;
     op := cursym!*;     
     if (x := scan()) eq '!*lsqbkt!* 
        then <<args := scan() . args;
               scan(); scan()>>;
    args := cadr xreadlist() . args;
    if x := get(op, 'converLatexName) then op := x;
    if length args > 1 then return {'expt, car args, 'recip . cdr args};
    return 'sqrt . reverse args;
  end;
  
% Subscripts and Superscripts.

%symbolic procedure latexSubSupStat;
%   begin scalar x, args;
%     scan();
%     args := cadr xreadlist() . args;
%     a: args := (if nxtsym!* eq '!^ 
%                    then <<scan();
%                           '!^ . cdr cadadr xreadlist()>>
%                  else if nxtsym!* eq '!_ 
%                    then <<scan();
%                           '!_ . cdr cadadr xreadlist()>>) . args;
%        if cursym!* eq '!*lcbkt!*
%           then go to a;
%        if cursym!* eq '!*lpar!*
%           then args := xread1 t . args;   %%%% CHECK ME!
%     return 'indexstruct . reverse args;
%   end;

% LaTeX environments.

newtok '((!\ b e g i n) !\begin);
newtok '((!\ e n d) !\end);
     
symbolic procedure latexBeginEnvStat;
   begin scalar envir, x;
     scan();
     envir := scan();
     scan();
     if x := get(envir, 'latexEnvStat)
        then return apply1(x, envir)
      else rederr "Unknown LaTeX environment";
   end;

put('!\begin, 'stat, 'latexBeginEnvStat);

symbolic procedure latexMultlineStat(u);
   begin scalar x, !*ignoreLatexEOL;
     !*ignoreLatexEOL := t;
     flag('(!\end), 'delim);
     x := xread nil;
     remflag('(!\end), 'delim);
     scan();
     if null(u eq scan()) then rederr "Wrong environment end.";
     scan(); scan();
     return x
   end;
   
put('multline, 'latexEnvStat, 'latexMultlineStat);


symbolic procedure latexMatrixStat(u);
   begin scalar x, m, !*ignoreLatexEOL;
     remprop('!\!\, 'scan_action!*);
     flag('(& !\end), 'delim);
     flag('(!\!\), 'delim);
     a: x := xread nil . x;
        if cursym!* eq '& then go to a;
     m := reverse x . m;
     x := nil;
     if cursym!* eq '!\!\ then go to a;
     remflag('(& !\end), 'delim);
     remflag(list(!$eol!$), 'delim);
     scan();
     if null(u eq scan()) then rederr "Wrong environment end.";
     if (u eq 'pmatrix) or (u eq 'smallmatrix)
        then u := 'mat;
     scan();
     scan();
     put('!\!\, 'scan_action!*, 'skipOverLatexCmd);
     return u . reverse m
     end;
 
put('pmatrix, 'latexEnvStat, 'latexMatrixStat);
put('bmatrix, 'latexEnvStat, 'latexMatrixStat);
put('Bmatrix, 'latexEnvStat, 'latexMatrixStat);
put('vmatrix, 'latexEnvStat, 'latexMatrixStat);
put('Vmatrix, 'latexEnvStat, 'latexMatrixStat);
put('smallmatrix, 'latexEnvStat, 'latexMatrixStat);

put('cases, 'latexEnvStat, 'latexMatrixStat);

symbolic procedure latexDisplayLines;
   begin scalar x, p;
    scan();
    x := xread 'group;
    cursym!* := '!*semicol!*;
    return x
   end;

newtok '((!\ d i s p l a y l i n e s) !\displaylines);
put('!\displaylines, 'stat, 'latexDisplayLines);
  
newtok '((!\ c o l o n e q) setq);
newtok '((!\ c d o t) times);

put('!\sin, 'newnam, 'sin);
put('!\quote, 'newnam, 'quote);
put('!\operatorname, 'stat, 'latexOperatornameStat);
put('!\mathrm, 'stat, 'latexOperatornameStat);
put('!\mathtt, 'stat, 'latexOperatornameStat);
put('!\mathnormal, 'stat, 'latexOperatornameStat);
put('!\mathit, 'stat, 'latexOperatornameStat);
%put('!\text, 'stat, 'latexTextStat);
%put('!\enskip, 'stat, 'latexSubSupStat);

put('!\pi, 'newnam, 'pi);

endmodule;

end;
