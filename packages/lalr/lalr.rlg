% Test cases for the parser generator. This all runs in symbolic mode...


%
% This is where (for now) I will put documentation of the syntax I
% will use when creating a grammer. There is a main function called
% lalr_create_parser and that is passed a list that describes
% a grammar. It is in the form of a sequence of productions, and the first
% one given is taken to be the top-level target.
%
% Each production is in the form
%     (LHS   ((rhs1.1 rhs1.2 ...) a1.1 a1.2 ...)
%            ((rhs2.1 rhs2.1 ...) a2.1 a2.2 ...)
%            ...)
% which in regular publication style for grammars might be interpreted
% as meaning
%      LHS ::= rhs1.1 rhs1.2 ... { a1.1 a1.2 ... }
%          |   rhs2.1 rhs2.2 ... { a2.1 a2.2 ... }
%          ...
%          ;
%
% Each LHS is treated as a non-terminal symbol and is specified as a simple
% name. Note that by default the Reduce parser will be folding characters
% within names to lower case and so it will be best to choose names for
% non-terminals that are unambiguous even when case-folded, but I would like
% to establish a convention that in source code they are written in capitals.
%
% The RHS items may be either non-terminals (identified because they are
% present in the left hand side of some production) or terminals. Terminal
% symbols can be specified in two different ways.
%
% Semantic actions must be given in Lisp, and the variables !$1, !$2, ...
% refer to the components from the matched right hand side. The final
% item in the semantic action is used as the result (and hence gets built
% up into the parse tree). If an explicit action is not given the
% behaviour is as if "(list !$1 !$2 ... !$n)" had been given, where the
% number of items is the number of terms in the pattern -- with a special
% case if there is only one item in which case the implicit action is
% just "!$1".
%
% The default lexer has built-in recipies that decode certain sequences
% of characters and return the special markers for !:symbol, !:number,
% !:string, !:list for commonly used cases. In these cases the variable
% yylval gets left set to associated data, so for instance in the case of
% !:symbol it gets set to the particular symbol concerned.
% The token type :list is used for Lisp or rlisp-like notation where the
% input contains
%     'expression
% or  `expression
% so for instance the input `(a b c) leads to the lexer returning !:list and
% yylvel being set to (backquote (a b c)). This treatment is specialised for
% handling rlisp-like syntax.
%
% Other terminals are indicated by writing a string. That may either
% consist of characters that would otherwise form a symbol (ie a letter
% followed by letters, digits and underscores) or a sequence of
% non-alphanumeric characters. In the latter case if a sequence of three or
% more punctuation marks make up a terminal then all the shorter prefixes
% of it will also be grouped to form single entities. So if "<-->" is a
% terminal then '<', '<-' and '<--' will each by parsed as single tokens, and
% any of them that are not used as terminals will be classified as !:symbol.
%
% A non-default lexer needs to be hand-written and can be installed
% for a grammar by using "set!-lexer". See examples.
%
% As well as terminals and non-terminals (which are written as symbols or
% strings) it is possible to write one of
%     (OPT s1 s2 ...)           0 or 1 instances of the sequence s1, ...
%     (STAR s1 s2 ...)          0, 1, 2, ... instances
%     (PLUS s1 s2 ...)          1, 2, 3, ... instances
%     (LIST sep s1 s2 ...)      like (STAR s1 s2 ...) but with the single
%                               item sep between each instance.
%     (LISTPLUS sep s1 ...)     like (PLUS s2 ...) but with sep interleaved.
%     (OR s1 s2 ...)            one or other of the tokens shown.
%
% When the lexer processes input it will return a numeric code that identifies
% the type of the item seen, so in a production one might write
%     (!:symbol ":=" EXPRESSION)
% and as it recognises the first two tokens the lexer will return a numeric
% code for !:symbol (and set yylval to the actual symbol as seen) and then
% a numeric code that it allocates for ":=". In the latter case it will
% also set yylval to the symbol !:!= in case that is useful.
%
% Precedence can be set using lalr_precedence. See examples lower down in this
% file.

% Some of the limitations are:
% (0) Testing has been pretty minimal so far, with the examples in this
%     file the main ones used. Well testing is ongoing with a grammar
%     for SML, and so things are improving on that front.
% (1) The lexer is hand-written and hence somewhat inflexible. It does
%     provide a set of option that can be used to tune it for (broad)
%     compatibility with several commonly-used languages. Probably some
%     people would appreciate something like "lex" or "flex" to make
%     lexer generationm automatic?
% (2) The issue of when input should end is not properly though through,
%     and so it is easy to end up with a syntax error reported when the
%     parser reaches what you had wanted to be the end of your input.
% (3) Diagnostics if you give a malformed grammar are weak.
% (4) The input format is perhaps crude, and in particular semantic actions
%     have to be given as raw Lisp code.
% (5) Diagnostics when you present malformed input to the parser are
%     not that good either...
% (6) The internals of the code use association lists and I *believe* that
%     calls to assoc, rassoc and related functions represent bottlenecks
%     such that processing could be made somewhat faster.
%
% I have listed the above in the order that I think I need to work on them. 

symbolic;


nil

load_package lalr;


nil


% Before testing parser generation I will demonstrate the lexer..
% If I was jumpy about the exact behaviour of the lexer I could go
%               on tracelex;
% to get some more tracing.

lex_cleanup();


nil


lex_keywords '("begin" "<=>" "<==");


nil


% The output from this is expected to be

%  Result: (2 symbol)
%  Result: (4 200)
%  Result: (4 3.542)
%  Result: (3 "a string")
%  Result: (5 (quote (quoted lisp)))
%  Result: (5 (backquote (backquoted (!, comma) (!,!@ comma_at))))
%  Result: (2 !+)
%  Result: (7 !<!=!>)
%  Result: (2 !-)
%  Result: (2 !=)
%  Result: (2 !>)
%  Result: (9 !<)
%  Result: (8 !<!=)
%  Result: (5 begin)
%  Result: (2 !;)
%  Result: (2 !;)
%
%  nil

% The row of "; ; ;" at the end provides some protection so that
% if faults in the lexer were to cause it to read more or less than it ought
% to then what is left over is reasonably likely to remain as valid rlisp
% syntax and so the rest of this test file will be able to continue happily.


begin
  scalar tt;
  off echo;
  lex_init();
  for i := 1:16 do <<
    tt := yylex();
    if not zerop posn() then terpri();
    princ "Result: ";
    print list(tt, yylval) >>;
  on echo
end;

Result: (1 symbol)
Result: (5 200)
Result: (5 3.542)
Result: (3 "a string")
Result: (6 (quote (quoted lisp)))
Result: (6 (backquote (backquoted (!, comma) (!,!@ comma_at))))
Result: (1 !+)
Result: (28 !<!=!>)
Result: (1 !-)
Result: (1 !=)
Result: (1 !>)
Result: (30 !<)
Result: (29 !<!=)
Result: (27 begin)
Result: (1 !;)
Result: (1 !;)

nil
 ;


nil



% I will now illustrate the various lexing styles that are available:

symbolic procedure demonstrate_lexer style;
  begin
    scalar tt, r;
    lex_init();
    lex_keywords '(">=");
% This sets one of the "lexer styles".
    lexer_style!* := style;
    while << tt := yylex(); yylval neq '!; >> do r := (tt . yylval) . r;
    for each x in reverse r do <<
% CSL and PSL do not put "!" escapes in exactly the same places when
% printing symbols with an underscore in the name - and thay also
% disagree about where to break lines to respect linelength. The
% function portable_print exists to provide consistent output in places
% like here.
      if not zerop posn() then terpri();
      portable_print x >>
  end;


demonstrate_lexer


% I will read exactly the same sequence of characters using various lexer
% styles so that token syntax, string treatment and comments show up.

demonstrate_lexer lexer_style_rlisp;


% Rlisp
# script comment test $
// C line
/* C block /* no_nesting */ outside */
(* SML (* nesting *) inside *)
'x'
"strings \" twice \" escapes & embedded "" quotes"
quote'-'chars :=: !!!! _ _ABC mixed!Case a!-b
>=
>>
0x10000
#if nil
conditional
#endif
;
(1 . !#)
(1 . script)
(1 . !/)
(1 . !/)
(1 . c)
(1 . line)
(1 . !/)
(1 . !*)
(1 . c)
(1 . block)
(1 . !/)
(1 . !*)
(1 . no_nesting)
(1 . !*)
(1 . !/)
(1 . outside)
(1 . !*)
(1 . !/)
(1 . !()
(1 . !*)
(1 . sml)
(1 . !()
(1 . !*)
(1 . nesting)
(1 . !*)
(1 . !))
(1 . inside)
(1 . !*)
(1 . !))
(6 quote x)
(6 quote "strings \")
(1 . twice)
(1 . !\)
(3 . " escapes & embedded "" quotes")
(1 . quote)
(6 quote !-)
(6 quote chars)
(1 . !:)
(1 . !=)
(1 . !:)
(1 . !!!!)
(1 . !_)
(1 . !_)
(1 . abc)
(1 . mixed!Case)
(1 . a!-b)
(32 . !>!=)
(33 . !>)
(33 . !>)
(5 . 65536)

nil
;


nil
;


nil


demonstrate_lexer lexer_style_C;


% Rlisp
# script comment test $
// C line
/* C block /* no_nesting */ outside */
(* SML (* nesting *) inside *)
'x'
"strings \" twice \" escapes & embedded "" quotes"
quote'-'chars :=: !!!! _ _ABC mixed!Case a!-b
>=
>>
0x10000
#if nil
conditional
#endif
;
(1 . !%)
(1 . rlisp)
(1 . !#)
(1 . script)
(1 . comment)
(1 . test)
(1 . !$)
(1 . outside)
(1 . !*)
(1 . !/)
(1 . !()
(1 . !*)
(1 . sml)
(1 . !()
(1 . !*)
(1 . nesting)
(1 . !*)
(1 . !))
(1 . inside)
(1 . !*)
(1 . !))
(4 . "x")
(3 . "strings \"" twice \"" escapes & embedded ")
(3 . " quotes")
(1 . quote)
(4 . "-")
(1 . chars)
(1 . !:)
(1 . !=)
(1 . !:)
(1 . !!)
(1 . !!)
(1 . !!)
(1 . !!)
(1 . !_)
(1 . !_abc)
(1 . mixed)
(1 . !!)
(1 . case)
(1 . a)
(1 . !!)
(1 . !-)
(1 . b)
(32 . !>!=)
(33 . !>)
(33 . !>)
(5 . 65536)
(1 . !#)
(1 . if)
(1)
(1 . conditional)
(1 . !#)
(1 . endif)

nil
;


nil
;


nil


demonstrate_lexer lexer_style_SML;


% Rlisp
# script comment test $
// C line
/* C block /* no_nesting */ outside */
(* SML (* nesting *) inside *)
'x'
"strings \" twice \" escapes & embedded "" quotes"
quote'-'chars :=: !!!! _ _ABC mixed!Case a!-b
>=
>>
0x10000
#if nil
conditional
#endif
;
(1 . !%)
(1 . rlisp)
(1 . !#)
(1 . script)
(1 . comment)
(1 . test)
(1 . !$)
(1 . !/!/)
(1 . c)
(1 . line)
(1 . !/!*)
(1 . c)
(1 . block)
(1 . !/!*)
(1 . no_nesting)
(1 . !*!/)
(1 . outside)
(1 . !*!/)
(2 . !'x!')
(3 . "strings \"" twice \"" escapes & embedded ")
(3 . " quotes")
(1 . quote!')
(1 . !-)
(2 . !'chars)
(1 . !:!=!:)
(1 . !#)
(1 . !#)
(1 . !_)
(1 . !_abc)
(1 . mixed)
(1 . !!)
(1 . case)
(1 . a)
(1 . !!!-)
(1 . b)
(32 . !>!=)
(1 . !>!>)
(5 . 65536)
(1 . !#)
(1 . if)
(1)
(1 . conditional)
(1 . !#)
(1 . endif)

nil
;


nil
;


nil


demonstrate_lexer lexer_style_script;


% Rlisp
# script comment test $
// C line
/* C block /* no_nesting */ outside */
(* SML (* nesting *) inside *)
'x'
"strings \" twice \" escapes & embedded "" quotes"
quote'-'chars :=: !!!! _ _ABC mixed!Case a!-b
>=
>>
0x10000
#if nil
conditional
#endif
;
(1 . !%)
(1 . rlisp)
(1 . !/)
(1 . !/)
(1 . c)
(1 . line)
(1 . !/)
(1 . !*)
(1 . c)
(1 . block)
(1 . !/)
(1 . !*)
(1 . no_nesting)
(1 . !*)
(1 . !/)
(1 . outside)
(1 . !*)
(1 . !/)
(1 . !()
(1 . !*)
(1 . sml)
(1 . !()
(1 . !*)
(1 . nesting)
(1 . !*)
(1 . !))
(1 . inside)
(1 . !*)
(1 . !))
(1 . !')
(1 . x)
(1 . !')
(3 . "strings \"" twice \"" escapes & embedded ")
(3 . " quotes")
(1 . quote)
(1 . !')
(1 . !-)
(1 . !')
(1 . chars)
(1 . !:)
(1 . !=)
(1 . !:)
(1 . !!)
(1 . !!)
(1 . !!)
(1 . !!)
(1 . !_)
(1 . !_abc)
(1 . mixed)
(1 . !!)
(1 . case)
(1 . a)
(1 . !!)
(1 . !-)
(1 . b)
(32 . !>!=)
(33 . !>)
(33 . !>)
(5 . 65536)
(1 . conditional)

nil
;


nil
;


nil



lexer_style!* := lexer_style_rlisp;


312513


on lalr_verbose;


nil


% Here I set up a sample grammar
%    S' -> S
%    S  -> C C        { }
%    C  -> "c" C      { }
%        | "d"        { }
% This is example 4.42 from Aho, Sethi and Ullman's Red Dragon book.
% It is example 4.54 in the more recent Purple book.

% Note that this grammar will introduce "c" and "d" as keywords rather than
% being general symbols. When I construct a subsequent grammar that will
% undo that setting. I will omit semantic actions here so that the default
% action of building a form of tree is used.

% There seems to be an issue here in that if I use a name for a non-terminal
% that is the same as one used for a terminal thinsg get confused. So I had
% originally hoped and expected to write just 'c' for the name of the
% non-terminal here are use '"c"' to denote the terminal. However when I
% try that I find that internally the names and up clashing to rather bad
% effect. I will look into this later since it is merely a matter of surface
% notation!  Also in the input to semantic actions the values passed when a
% terminal is matched may at present be the internal numeric code allocated
% to that terminal, not a "sensible" value. Agian this is a small issue.

grammar := '(
  (s  ((cc cc)  )   % One production for S, no explicit semantic here
  )
  (cc (("c" cc) (list 'c !$2))   % First production for C
      (("d")    'd           ))  % Second production for C
% I put in a redundant (unused) clause here to illustrate that it is
% detected and reported.
  (redundant (()))
  )$



g := lalr_create_parser(nil, grammar)$


*** Unused clauses in grammar: 
((redundant (nil)))
=== Terminal symbols ===
   d [28]
   c [27]

=== Nonterminal symbols ===
[-1] S'             : S                         { nil }

[0] S               : CC CC                     { nil }

[1] CC              : d                         { ((quote d)) }
                    | c CC                      { ((list (quote c) !$2)) }


=== FIRST sets for each nonterminal ===
S':                 c d 
S:                  d c 
CC:                 c d 

=== LALR ITEMSET COLLECTION ===
Itemset 0
 S' -> . S [$]
 CC -> . d [c/d]
 CC -> . c CC [c/d]
 S -> . CC CC [$]
GOTO(S) = 1
GOTO(CC) = 2
GOTO(d) = 3
GOTO(c) = 4

Itemset 1
 S' -> S . [$]

Itemset 2
 CC -> . d [$]
 CC -> . c CC [$]
 S -> CC . CC [$]
GOTO(CC) = 6
GOTO(d) = 3
GOTO(c) = 4

Itemset 3
 CC -> d . [$/d/c]

Itemset 4
 CC -> . d [c/d/$]
 CC -> . c CC [c/d/$]
 CC -> c . CC [$/d/c]
GOTO(CC) = 5
GOTO(d) = 3
GOTO(c) = 4

Itemset 5
 CC -> c CC . [c/d/$]

Itemset 6
 S -> CC CC . [$]

=== ACTION TABLE ===
STATE TERMINAL      ACTION
0     c             shift to state 4
      d             shift to state 3
1     <any>         accept
2     c             shift to state 4
      d             shift to state 3
3     <any>         reduce by #2: CC -> [1 symbols] (lambda (!$1) (quote d))
4     c             shift to state 4
      d             shift to state 3
5     <any>         reduce by #3: CC -> [2 symbols] (lambda (!$1 !$2) (list (
                                                    quote c) !$2))
6     <any>         reduce by #1: S -> [2 symbols] 

=== GOTO TABLE ===
NONTERMINAL         SRC     DEST
S                   <any>   1
CC                  4       5
                    2       6
                    <any>   2



symbolic procedure pparse g;
  begin
    scalar r;
    r := yyparse g;
    terpri();
    princ "= ";
    portable_print r
  end;


pparse


pparse g$



c Shift token c onto stack, and shift to state 4
c Shift token c onto stack, and shift to state 4
c Shift token c onto stack, and shift to state 4
d Shift token d onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 2
c Shift token c onto stack, and shift to state 4
d Shift token d onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 5
On lookahead -1, reduce 2 symbols to nonterminal CC, and goto state 6
On lookahead -1, reduce 2 symbols to nonterminal S, and goto state 1
Seems to have finished... 
= ((c (c (c d))) (c d))
;


nil


pparse g$



d Shift token d onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 2
d Shift token d onto stack, and shift to state 3
On lookahead -1, reduce 1 symbols to nonterminal CC, and goto state 6
On lookahead -1, reduce 2 symbols to nonterminal S, and goto state 1
Seems to have finished... 
= (d d)
;


nil



% Now switch off the tracing. It is useful while debugging this
% package but is typically rather over the top for normal use.

off tracelex, lalr_verbose;


nil


% Example 4.46 from the Red Dragon (4.61 in Aho, Lam, Sethi and Ullman,
% "Compilers: principles, techniques and tools", second edition 2007).
%
% This is used there as an example of a grammar that is not SLR(1) but
% that can be handled by LALR .

% The semantic actions here contain print statements that will
% print some sort of trace as the parsing progresses.

symbolic procedure neatprintc x;
 << if not zerop posn() then terpri();
    printc x >>;


neatprintc


g4_46 := '((s   ((l "=" r)   (neatprintc "## S => L = R")
                             (list 'equal !$1 !$3))
                ((r)         (neatprintc "## S => R")
                             !$1))
           (l   (("*" r)     (neatprintc "## L => * R")
                             (list 'star !$2))
                ((!:symbol)  (neatprintc "## L => symbol")
                             !$1))
           (r   ((l)         (neatprintc "## R => L")
                             !$1)))$



g := lalr_create_parser(nil, g4_46)$



pparse g$



leftsym 
## L => symbol
= rightsym 
## L => symbol
## R => L
## S => L = R

= (equal leftsym rightsym)
;


nil



pparse g$



****abc 
## L => symbol
## R => L
## L => * R
## R => L
## L => * R
## R => L
## L => * R
## R => L
## L => * R
= *def 
## L => symbol
## R => L
## L => * R
## R => L
## S => L = R

= (equal (star (star (star (star abc)))) (star def))
;


nil


% This next example is expected to be reasonably representative of
% small grammars. It needs precedence rules to disambiguate the
% grammar, and illustrates both left and right associativity, and
% cases where two operators have the same precedence.

gtest := '((s  ((p))
               ((s "^" s) (list 'expt !$1 !$3))
               ((s "**" s) (list 'expt !$1 !$3))
               ((s "*" s) (list 'times !$1 !$3))
               ((s "/" s) (list 'quotient !$1 !$3))
               ((s "+" s) (list 'plus !$1 !$3))
               ((s "-" s) (list 'difference !$1 !$3))
               ((s "=" s) (list 'equal !$1 !$3))
               (("-" s) (list 'minus !$2))
               (("+" s) !$2))

           (p  (("(" s ")") !$2)
               ((!:symbol))
               ((!:string))
               ((!:number))))$



% "^" and "**" both have the same high precedence and are right
% associative. Next come "*" and "/" which are left associative,
% and after that "+" and "-". Finally "=" has lowest precedence and
% must not associate with itself, so (a=b=c) should be a syntax error.

p := '(!:right ("^" "**") !:left ("*" "/") ("+" "-") !:none "=")$



g := lalr_create_parser(p, gtest)$



pparse g$


a^b^c;
= (expt a (expt b c))


pparse g$


a*b+c*d;
= (plus (times a b) (times c d))


pparse g$


a * (b/c + d/e/f) ^ 2 ^ g - "str" ;
= (difference (times a (expt (plus (quotient b c) (quotient (quotient d e) f))
 (expt 2 g))) "str")


% Demonstrate various of the short-hand notations...

g := lalr_create_parser(nil, '(
 (s
% (opt ...) means that the included material is optional.
          (("begin" (opt "and" "also") "end")))))$



pparse g$


begin end

= (begin nil end)
;


nil
;


nil


pparse g$


begin and also end

= (begin (and also) end)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (star ...) is for zero or mor instances of something.
          (((star "a") "end") !$1))))$



pparse g$


end

= nil
;


nil
;


nil


pparse g$


a a a a a a end

= (a a a a a a)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (plus ...) is for one or more repetitions of an item
          (((plus "a") "end") !$1))))$



pparse g$


a end

= (a)
;


nil
;


nil


pparse g$


a a a a a a end

= (a a a a a a)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (list delimiter item-description) is a sequence of zero
% or more items, and if there are several that are separated by the
% indicated delimiter. 
          (((list ";" !:symbol) "eof") !$1))))$



pparse g$



several ; words ; here eof

= (several words here)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (listplus delimiter item-description) is as (list ...) however it
% requires at least one item.
          (((listplus ";" !:symbol) "eof") !$1))))$



pparse g$



several ; words ; here eof

= (several words here)
;


nil
;


nil


g := lalr_create_parser(nil, '(
 (s
% (or x y z) may be a more compact way of writing what could
% otherwise by given as multiple productions, so for instance
% (or "+" "-" "*" "/") would match one of the listed operators.
          (((star (or "a" "b")) "end") !$1))))$



pparse g$


end

= nil
;


nil
;


nil


pparse g$


a b b a end

= (a b b a)
;


nil
;


nil


% The next example shows all the above put together to parse what is
% in effect a small programming language. Although it is not yet a large
% grammar it illustrates painfull clearly how poor performange of the
% parser generator can be if ut used what Aho, Sethi and Ullman describe as
% the "Easy but space-consuming LALR table construction" method.

p := '(!:left ("*" "/")
              ("+" "-")
       !:none ("<" "<=" "==" "neq" ">=" ">")
       !:right ":=" "="
       !:left ("then" "else" "return"))$



mini_language := '(
 (program
          (((listplus ";" expression) "eof") !$1))

 (expression
          ((funcall))
          ((expression "*" expression) (list 'times !$1 !$3))
          ((expression "/" expression) (list 'quotient !$1 !$3))
          ((expression "+" expression) (list 'plus !$1 !$3))
          ((expression "-" expression) (list 'difference !$1 !$3))
          ((expression "<" expression) (list 'lessp !$1 !$3))
          ((expression "<=" expression) (list 'lesseq !$1 !$3))
          ((expression "==" expression) (list 'equals !$1 !$3))
          ((expression "neq" expression) (list 'neq !$1 !$3))
          ((expression "=>" expression) (list 'geq !$1 !$3))
          ((expression ">" expression) (list 'greaterp !$1 !$3))
          ((expression ":=" expression) (list 'setq !$1 !$3))
          (("fun" funcall "=" expression) (list 'fun !$2 !$4))
          (("if" sequence "then" expression)
             (list 'cond (list !$2 !$4)))
          (("if" sequence "then" sequence "else" expression)
             (list 'cond (list !$2 !$4) (list t !$6)))
          (("go" (opt "to") !:symbol) (list 'go !$3))
          (("goto" !:symbol) (list 'go !$2))
          (("return" expression)))

(funcall
          ((closedexpression))
          ((funcall closedexpression)))

(closedexpression
          ((!:symbol))
          ((!:number))
          (((plus !:string))) % Several strings in a row just concatenate
          (("let" sequence "in" sequence "end") (list 'letstat !$2 !$4))
          (("(" exprlist ")") (cons 'paren !$2))
          (("(" sequence ")") (cons 'paren !$2))
          (("[" exprlist "]") (cons 'bracket !$2)))

(exprlist (((list "," expression))))

(sequence
          (((list ";" expression)))))$



% The grammar shown here used to fail for lack of space. It should now
% behave.
% One issue it reveals at right now is that the processing here does not
% keep the types of terminal symbols under control carefully enough, so the
% numeric values 22 and 33 in the sample text get transliterated back into
% terminal symbols that happen to have ended up allocated numeric codes
% 22 and 33. This NEEDS fixing, but is not really an issue for the
% code that manufactures parsing tables.
%
%                                                       ACN   May 2016

on tracelex, lalr_verbose;


nil


g := lalr_create_parser(p, mini_language)$

Token 'eof' allocated code 27
Token '!;' allocated code 28
Token '!*' allocated code 29
Token '!/' allocated code 30
Token '!+' allocated code 31
Token '!-' allocated code 32
Token '!<' allocated code 33
dipthong data '!<' plus '!=' => '!<!='
Token '!=' allocated code 36
dipthong data '!=' plus '!=' => '!=!='
Token 'neq' allocated code 37
dipthong data '!=' plus '!>' => '!=!>'
Token '!>' allocated code 39
Token '!:' allocated code 41
dipthong data '!:' plus '!=' => '!:!='
Token 'fun' allocated code 42
Token 'if' allocated code 43
Token 'then' allocated code 44
Token 'else' allocated code 45
Token 'go' allocated code 46
Token 'goto' allocated code 47
Token 'return' allocated code 48
Token 'to' allocated code 49
Token 'let' allocated code 50
Token 'in' allocated code 51
Token 'end' allocated code 52
Token '!(' allocated code 53
Token '!)' allocated code 54
Token '![' allocated code 55
Token '!]' allocated code 56
Token '!,' allocated code 57
=== Terminal symbols ===
   , [57]
   :string [3]
   ] [56]
   [ [55]
   ) [54]
   ( [53]
   end [52]
   in [51]
   let [50]
   :number [5]
   to [49]
   return [48] (precedence 5, left associativity)
   goto [47]
   :symbol [1]
   go [46]
   else [45] (precedence 5, left associativity)
   then [44] (precedence 5, left associativity)
   if [43]
   = [36] (precedence 4, right associativity)
   fun [42]
   := [40] (precedence 3, right associativity)
   > [39] (precedence 2, none associativity)
   => [38]
   neq [37] (precedence 2, none associativity)
   == [35] (precedence 2, none associativity)
   <= [34] (precedence 2, none associativity)
   < [33] (precedence 2, none associativity)
   - [32] (precedence 1, left associativity)
   + [31] (precedence 1, left associativity)
   / [30] (precedence 0, left associativity)
   * [29] (precedence 0, left associativity)
   ; [28]
   eof [27]

=== Nonterminal symbols ===
[-1] S'             : PROGRAM                   { nil }

[0] PROGRAM         : LALR_INTERNAL_15 eof      { (!$1) }

[1] LALR_INTERNAL_15: EXPRESSION LALR_INTERNAL_17 
                                                { ((cons !$1 !$2)) }

[2] LALR_INTERNAL_17: ; EXPRESSION LALR_INTERNAL_17 
                                                { ((cons !$2 !$3)) }
                    | <empty>                   { nil }

[3] EXPRESSION      : return EXPRESSION         { nil }
                    | goto :symbol              { ((list (quote go) !$2)) }
                    | go LALR_INTERNAL_18 :symbol 
                                                { ((list (quote go) !$3)) }
                    | if SEQUENCE then SEQUENCE else EXPRESSION 
                                                { ((list (quote cond) (list 
                                                  !$2 !$4) (list t !$6))) }
                    | if SEQUENCE then EXPRESSION 
                                                { ((list (quote cond) (list 
                                                  !$2 !$4))) }
                    | fun FUNCALL = EXPRESSION  { ((list (quote fun) !$2 !$4)) }
                    | EXPRESSION := EXPRESSION  { ((list (quote setq) !$1 !$3)
                                                  ) }
                    | EXPRESSION > EXPRESSION   { ((list (quote greaterp) !$1 
                                                  !$3)) }
                    | EXPRESSION => EXPRESSION  { ((list (quote geq) !$1 !$3)) }
                    | EXPRESSION neq EXPRESSION { ((list (quote neq) !$1 !$3)) }
                    | EXPRESSION == EXPRESSION  { ((list (quote equals) !$1 
                                                  !$3)) }
                    | EXPRESSION <= EXPRESSION  { ((list (quote lesseq) !$1 
                                                  !$3)) }
                    | EXPRESSION < EXPRESSION   { ((list (quote lessp) !$1 
                                                  !$3)) }
                    | EXPRESSION - EXPRESSION   { ((list (quote difference) 
                                                  !$1 !$3)) }
                    | EXPRESSION + EXPRESSION   { ((list (quote plus) !$1 !$3)
                                                  ) }
                    | EXPRESSION / EXPRESSION   { ((list (quote quotient) !$1 
                                                  !$3)) }
                    | EXPRESSION * EXPRESSION   { ((list (quote times) !$1 
                                                  !$3)) }
                    | FUNCALL                   { nil }

[4] LALR_INTERNAL_18: to                        { nil }
                    | <empty>                   { nil }

[5] SEQUENCE        : LALR_INTERNAL_19          { nil }

[6] LALR_INTERNAL_19: EXPRESSION LALR_INTERNAL_21 
                                                { ((cons !$1 !$2)) }
                    | <empty>                   { nil }

[7] LALR_INTERNAL_21: ; EXPRESSION LALR_INTERNAL_21 
                                                { ((cons !$2 !$3)) }
                    | <empty>                   { nil }

[8] FUNCALL         : FUNCALL CLOSEDEXPRESSION  { nil }
                    | CLOSEDEXPRESSION          { nil }

[9] CLOSEDEXPRESSION: [ EXPRLIST ]              { ((cons (quote bracket) !$2)) }
                    | ( SEQUENCE )              { ((cons (quote paren) !$2)) }
                    | ( EXPRLIST )              { ((cons (quote paren) !$2)) }
                    | let SEQUENCE in SEQUENCE end 
                                                { ((list (quote letstat) !$2 
                                                  !$4)) }
                    | LALR_INTERNAL_22          { nil }
                    | :number                   { nil }
                    | :symbol                   { nil }

[10] LALR_INTERNAL_22: :string LALR_INTERNAL_22 { ((cons !$1 !$2)) }
                    | :string                   { ((list !$1)) }

[11] EXPRLIST       : LALR_INTERNAL_24          { nil }

[12] LALR_INTERNAL_24: EXPRESSION LALR_INTERNAL_26 
                                                { ((cons !$1 !$2)) }
                    | <empty>                   { nil }

[13] LALR_INTERNAL_26: , EXPRESSION LALR_INTERNAL_26 
                                                { ((cons !$2 !$3)) }
                    | <empty>                   { nil }


=== FIRST sets for each nonterminal ===
S':                 :string [ ( let :number :symbol return goto go if fun 
PROGRAM:            :string :symbol :number let ( [ fun if go goto return 
LALR_INTERNAL_15:   :string [ ( let :number :symbol return goto go if fun 
LALR_INTERNAL_17:   NIL ; 
EXPRESSION:         :string :symbol :number let ( [ fun if go goto return 
LALR_INTERNAL_18:   NIL to 
SEQUENCE:           :string :symbol :number let ( [ NIL fun if go goto return 
LALR_INTERNAL_19:   :string [ ( let :number :symbol NIL return goto go if fun 
LALR_INTERNAL_21:   NIL ; 
FUNCALL:            :string [ ( let :number :symbol 
CLOSEDEXPRESSION:   :string :symbol :number let ( [ 
LALR_INTERNAL_22:   :string 
EXPRLIST:           :string :symbol :number let ( [ NIL fun if go goto return 
LALR_INTERNAL_24:   :string [ ( let :number :symbol NIL return goto go if fun 
LALR_INTERNAL_26:   NIL , 

=== LALR ITEMSET COLLECTION ===
Itemset 0
 S' -> . PROGRAM [$]
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/eof/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/eof/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/eof]
 LALR_INTERNAL_15 -> . EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/eof
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/eof/[/(/let/:number/
:symbol/:string/;]
 PROGRAM -> . LALR_INTERNAL_15 eof [$]
GOTO(PROGRAM) = 1
GOTO(LALR_INTERNAL_15) = 2
GOTO(EXPRESSION) = 3
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 1
 S' -> PROGRAM . [$]

Itemset 2
 PROGRAM -> LALR_INTERNAL_15 . eof [$]
GOTO(eof) = 83

Itemset 3
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_15 -> EXPRESSION . LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_17 -> . ; EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_17 -> . [eof]
GOTO(LALR_INTERNAL_17) = 79
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 80

Itemset 4
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [end/else/then/in/)/,/]/:=/>/=>/neq/==/<
=/</-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</
-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</
-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</
-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [end/else/then/in/)/,/]/:=/>
/=>/neq/==/<=/</-/+///*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . :number [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/;/eof]
 CLOSEDEXPRESSION -> . :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/;/eof]
 EXPRESSION -> FUNCALL . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/*///+/-/</<=/==/
neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==/neq/=>/>/:=/in/;
/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/
neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+
/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*
///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/
:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=
>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/n
eq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/;/*///
+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*///+/-/</<=/==/neq/
=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> FUNCALL . CLOSEDEXPRESSION [eof/;/[/(/let/:number/:symbol/:string/*/
//+/-/</<=/==/neq/=>/>/:=/]/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/ne
q/=>/>/:=/)/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/)/;/[/
(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/in/;/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/ne
q/=>/>/:=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<
=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<
=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<
=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(
/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/else/;/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>
/>/:=/end/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/,/[/(/le
t/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/
:string/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [eof/;/[/(/let/:number/:symbol/:
string/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/else/end]
 LALR_INTERNAL_22 -> . :string [eof/;/[/(/let/:number/:symbol/:string/*///+/-/</
<=/==/neq/=>/>/:=/]/,/)/in/then/else/end]
GOTO(CLOSEDEXPRESSION) = 19
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(:symbol) = 14

Itemset 5
 FUNCALL -> CLOSEDEXPRESSION . [eof/;/[/(/let/:number/:symbol/:string/*///+/-/</
<=/==/neq/=>/>/:=/]/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:
=/)/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/)/;/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/in/;/[/(/let/:number/:symbol/:
string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/
==/neq/=>/>/:=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:
=/then/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/let/:
number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/else/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/end/;/[/(/let/:number/:symbol/:string/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/
;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 6
 CLOSEDEXPRESSION -> LALR_INTERNAL_22 . [;/[/(/let/:number/:symbol/:string/eof/*
///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/n
eq/=>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(
/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:sy
mbol/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/n
eq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/
[/(/let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/
:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/
:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/
:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/
neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[
/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:sy
mbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*
///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq
/=>/>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 7
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [end/else/=/then/in/)/]/,/:=/>/=
>/neq/==/<=/</-/+///*/eof/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/</-/+
///*/eof/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> :string . LALR_INTERNAL_22 [;/:string/:symbol/:number/let/(
/[/eof/*///+/-/</<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/]/*///+/-/<
/<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/
:=/;/:string/:symbol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:sy
mbol/:number/let/(/[/in/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/
(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/then/*///+/-/<
/<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/then/*///+/-/</<=/==/neq/=>
/>/:=/=/:string/:symbol/:number/let/(/[/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:num
ber/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:num
ber/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:num
ber/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/
</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/else/*///+/-/</<=/==/neq/=
>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:sy
mbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(
/[/end/*///+/-/</<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/*///+/-/</<
=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_22 -> :string . [;/:string/:symbol/:number/let/(/[/eof/*///+/-/</
<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/]/*///+/-/</<=/==/neq/=>/>/:
=/,/:string/:symbol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:sym
bol/:number/let/(/[/)/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/
(/[/in/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/
==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/then/*///+/-/</<=/==/neq/=>/>/:
=/;/:string/:symbol/:number/let/(/[/then/*///+/-/</<=/==/neq/=>/>/:=/=/:string/:
symbol/:number/let/(/[/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:
number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+
/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:
number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+
/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:
number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+
/-/</<=/==/neq/=>/>/:=/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/
:=/;/:string/:symbol/:number/let/(/[/else/*///+/-/</<=/==/neq/=>/>/:=/:string/:s
ymbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/
(/[/*///+/-/</<=/==/neq/=>/>/:=/;/:string/:symbol/:number/let/(/[/end/*///+/-/</
<=/==/neq/=>/>/:=/,/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=/
;/:string/:symbol/:number/let/(/[/*///+/-/</<=/==/neq/=>/>/:=]
GOTO(LALR_INTERNAL_22) = 78
GOTO(:string) = 7

Itemset 8
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:
symbol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symb
ol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symb
ol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symb
ol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/]/:string/:symbol/:number/let/(/[/,]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symbol/:n
umber/let/(/[/,]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/]/:string/:symbol/:n
umber/let/(/[/,]
 CLOSEDEXPRESSION -> [ . EXPRLIST ] [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=
>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/
</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/
let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/l
et/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/
>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/,/]]
 EXPRLIST -> . LALR_INTERNAL_24 []]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/,/]]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/,/]]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/]/[
/(/let/:number/:symbol/:string/,]
 LALR_INTERNAL_22 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/]/[/(/let/:number/:s
ymbol/:string/,]
 LALR_INTERNAL_24 -> . EXPRESSION LALR_INTERNAL_26 []]
 LALR_INTERNAL_24 -> . []]
GOTO(EXPRESSION) = 75
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(EXPRLIST) = 76
GOTO(LALR_INTERNAL_24) = 68
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 9
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [,/:=/>/=>/neq/==/<=/</-/+//
/*/)/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [,/:=/>/=>/neq/==/<=/</-/+///*/)/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> ( . EXPRLIST ) [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=
>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/
</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/
let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/l
et/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/
>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]
 CLOSEDEXPRESSION -> ( . SEQUENCE ) [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=
>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/
</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/
let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:num
ber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/
*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/
=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/l
et/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol
/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/
>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> . EXPRESSION := EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION > EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION => EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION == EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION < EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION - EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION + EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION / EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . EXPRESSION * EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . FUNCALL [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . return EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . goto :symbol [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [,/:=/>/=>/neq/==/<=/
</-/+///*/;/)]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/;/)]
 EXPRLIST -> . LALR_INTERNAL_24 [)]
 FUNCALL -> . CLOSEDEXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:n
umber/let/(/[/;/)]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [,/:=/>/=>/neq/==/<=/</-/+///*/:string/:s
ymbol/:number/let/(/[/;/)]
 LALR_INTERNAL_19 -> . EXPRESSION LALR_INTERNAL_21 [)]
 LALR_INTERNAL_19 -> . [)]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [,/:=/>/=>/neq/==/<=/</-/+///*/)
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [,/:=/>/=>/neq/==/<=/</-/+///*/)/[/(/let/:number/
:symbol/:string/;]
 LALR_INTERNAL_24 -> . EXPRESSION LALR_INTERNAL_26 [)]
 LALR_INTERNAL_24 -> . [)]
 SEQUENCE -> . LALR_INTERNAL_19 [)]
GOTO(EXPRESSION) = 65
GOTO(SEQUENCE) = 66
GOTO(LALR_INTERNAL_19) = 46
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(EXPRLIST) = 67
GOTO(LALR_INTERNAL_24) = 68
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 10
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/in/:string/
:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:sym
bol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:sym
bol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:sym
bol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/in/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:symbol/:
number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/in/:string/:symbol/:
number/let/(/[/;]
 CLOSEDEXPRESSION -> let . SEQUENCE in SEQUENCE end [;/[/(/let/:number/:symbol/:
string/eof/*///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+
/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=
>/>/:=/;/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/
:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+
/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/ne
q/=>/>/:=/=/[/(/let/:number/:symbol/:string/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>
/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>
/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>
/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/
:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///
+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/n
eq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let
/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:
string/end/*///+/-/</<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-
/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/in]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/in]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/in]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/in]
 LALR_INTERNAL_19 -> . EXPRESSION LALR_INTERNAL_21 [in]
 LALR_INTERNAL_19 -> . [in]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/in/
[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/in/[/(/let/:number/:
symbol/:string/;]
 SEQUENCE -> . LALR_INTERNAL_19 [in]
GOTO(EXPRESSION) = 44
GOTO(SEQUENCE) = 61
GOTO(LALR_INTERNAL_19) = 46
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 11
 CLOSEDEXPRESSION -> :number . [;/[/(/let/:number/:symbol/:string/eof/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=>/>/:
=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:num
ber/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/
==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:
=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/let/:
number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/
;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 12
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)
/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/;/*///+/-/</<=/==/neq/=
>/>/:=/]/,/)/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :number [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///*/;/e
of]
 EXPRESSION -> . return EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
 EXPRESSION -> . goto :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> return . EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/*///+/
-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==/neq/=>
/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/
-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/
>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq
/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==
/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<
=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-
/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>
/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*///+/-/</
<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> . CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/
in/then/else/:string/:symbol/:number/let/(/[/end]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [eof/;/*///+/-/</<=/==/neq/=>/>/
:=/]/,/)/in/then/else/[/(/let/:number/:symbol/:string/end]
 LALR_INTERNAL_22 -> . :string [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/[/(/let/:number/:symbol/:string/end]
GOTO(EXPRESSION) = 60
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 13
 EXPRESSION -> goto . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/*///+/-/</<
=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==/neq/=>/>/:=
/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<
=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/
*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>
/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/
=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/
neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=
/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/;
/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*///+/-/</<=/==
/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
GOTO(:symbol) = 59

Itemset 14
 CLOSEDEXPRESSION -> :symbol . [;/[/(/let/:number/:symbol/:string/eof/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/]/*///+/-/</<=/==/neq/=>/>/:
=/,/[/(/let/:number/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:num
ber/:symbol/:string/)/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/in/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/
==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:
=/;/[/(/let/:number/:symbol/:string/then/*///+/-/</<=/==/neq/=>/>/:=/=/[/(/let/:
number/:symbol/:string/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:
symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+
/-/</<=/==/neq/=>/>/:=/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/
:=/;/[/(/let/:number/:symbol/:string/else/*///+/-/</<=/==/neq/=>/>/:=/[/(/let/:n
umber/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:str
ing/*///+/-/</<=/==/neq/=>/>/:=/;/[/(/let/:number/:symbol/:string/end/*///+/-/</
<=/==/neq/=>/>/:=/,/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=/
;/[/(/let/:number/:symbol/:string/*///+/-/</<=/==/neq/=>/>/:=]

Itemset 15
 EXPRESSION -> go . LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=
/==/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/the
n/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/
==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/<
/<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+
/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*
///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/
:=/*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/=
=/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/
*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_18 -> . to [:symbol]
 LALR_INTERNAL_18 -> . [:symbol]
GOTO(LALR_INTERNAL_18) = 56
GOTO(to) = 57

Itemset 16
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/then/:strin
g/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:s
ymbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:s
ymbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:s
ymbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/then/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:symbol
/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/then/:string/:symbol
/:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/then
]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then
]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/then]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/then]
 EXPRESSION -> if . SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=
/==/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/the
n/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/
==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/<
/<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+
/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*
///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/
:=/*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/=
=/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/
*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> if . SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/]/,/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/
;/*///+/-/</<=/==/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/n
eq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=
/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/
>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq
/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==
/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<
=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/
*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/
neq/=>/>/:=/,/*///+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/then]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/then]
 LALR_INTERNAL_19 -> . EXPRESSION LALR_INTERNAL_21 [then]
 LALR_INTERNAL_19 -> . [then]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/the
n/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/then/[/(/let/:number
/:symbol/:string/;]
 SEQUENCE -> . LALR_INTERNAL_19 [then]
GOTO(EXPRESSION) = 44
GOTO(SEQUENCE) = 45
GOTO(LALR_INTERNAL_19) = 46
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 17
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:string/:symbol/:number/let
/(/[/=]
 CLOSEDEXPRESSION -> . :number [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . :symbol [:string/:symbol/:number/let/(/[/=]
 EXPRESSION -> fun . FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,
/*///+/-/</<=/==/neq/=>/>/:=/)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*///+/-/</<=/==
/neq/=>/>/:=/in/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/then/;
/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/
neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=
/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/
</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///
+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/neq/=>/>/:=/
*///+/-/</<=/==/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=/*///+/-/</<=/==/n
eq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/</<=/==/neq/=>/>/:=/,/*//
/+/-/</<=/==/neq/=>/>/:=/;/*///+/-/</<=/==/neq/=>/>/:=]
 FUNCALL -> . CLOSEDEXPRESSION [:string/:symbol/:number/let/(/[/=]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:string/:symbol/:number/let/(/[/=]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [[/(/let/:number/:symbol/:string
/=]
 LALR_INTERNAL_22 -> . :string [[/(/let/:number/:symbol/:string/=]
GOTO(FUNCALL) = 18
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(:symbol) = 14

Itemset 18
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:string/:symbol/:number/let
/(/[/=]
 CLOSEDEXPRESSION -> . :number [:string/:symbol/:number/let/(/[/=]
 CLOSEDEXPRESSION -> . :symbol [:string/:symbol/:number/let/(/[/=]
 EXPRESSION -> fun FUNCALL . = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> FUNCALL . CLOSEDEXPRESSION [=/[/(/let/:number/:symbol/:string]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [=/[/(/let/:number/:symbol/:stri
ng]
 LALR_INTERNAL_22 -> . :string [=/[/(/let/:number/:symbol/:string]
GOTO(CLOSEDEXPRESSION) = 19
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(:symbol) = 14
GOTO(=) = 20

Itemset 19
 FUNCALL -> FUNCALL CLOSEDEXPRESSION . [=/end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/:string/:symbol/:number/let/(/[/;/eof]

Itemset 20
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)
/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/;/*///+/-/</<=/==/neq/=
>/>/:=/]/,/)/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :number [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///*/;/e
of]
 EXPRESSION -> . return EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
 EXPRESSION -> . goto :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> fun FUNCALL = . EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,
/)/in/then/else/end]
 FUNCALL -> . CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/
in/then/else/:string/:symbol/:number/let/(/[/end]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [eof/;/*///+/-/</<=/==/neq/=>/>/
:=/]/,/)/in/then/else/[/(/let/:number/:symbol/:string/end]
 LALR_INTERNAL_22 -> . :string [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/[/(/let/:number/:symbol/:string/end]
GOTO(EXPRESSION) = 21
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 21
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> fun FUNCALL = EXPRESSION . [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 22
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION := . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 43
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 23
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION > . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 42
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 24
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION => . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 41
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 25
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION neq . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 40
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 26
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION == . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 39
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 27
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION <= . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 38
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 28
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION < . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 37
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 29
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION - . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 36
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 30
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION + . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 35
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 31
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION / . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 34
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 32
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/neq/==/<
=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</
-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/)/in/then/else/end/:=/>
/=>/neq/==/<=/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :number []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 CLOSEDEXPRESSION -> . :symbol []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 EXPRESSION -> . EXPRESSION := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
 EXPRESSION -> . FUNCALL [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/in/)/,
/]]
 EXPRESSION -> . return EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/t
hen/in/)/,/]]
 EXPRESSION -> . goto :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/else/then/i
n/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
end/else/then/in/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/end/else/then/in/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
 EXPRESSION -> EXPRESSION * . EXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/:string/:symbol/:number/let/(/[/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION []/,/)/in/then/else/end/:=/>/=>/neq/==/<=
/</-/+///*/;/:string/:symbol/:number/let/(/[/eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/)/in/then/else/end/:=/>/=>/
neq/==/<=/</-/+///*/;/[/(/let/:number/:symbol/:string/eof]
 LALR_INTERNAL_22 -> . :string []/,/)/in/then/else/end/:=/>/=>/neq/==/<=/</-/+//
/*/;/[/(/let/:number/:symbol/:string/eof]
GOTO(EXPRESSION) = 33
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 33
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION * EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 34
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION / EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 35
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION + EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 36
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION - EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 37
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION < EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 38
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION <= EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 39
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION == EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 40
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION neq EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/en
d/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 41
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION => EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 42
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION > EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end/
else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 43
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/end/else/then/in/)/,/]/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION := EXPRESSION . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/end
/else/then/in/)/,/]]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 44
 EXPRESSION -> EXPRESSION . := EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/the
n/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then
/;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [in/;/*///+/-/</<=/==/neq/=>/>/:=/then/
;/*///+/-/</<=/==/neq/=>/>/:=/then/;/*///+/-/</<=/==/neq/=>/>/:=/end/;/*///+/-/<
/<=/==/neq/=>/>/:=]
 LALR_INTERNAL_19 -> EXPRESSION . LALR_INTERNAL_21 [in/then/then/end]
 LALR_INTERNAL_21 -> . ; EXPRESSION LALR_INTERNAL_21 [end/then/in]
 LALR_INTERNAL_21 -> . [end/then/in]
GOTO(LALR_INTERNAL_21) = 52
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 45
 EXPRESSION -> if SEQUENCE . then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> if SEQUENCE . then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
GOTO(then) = 47

Itemset 46
 SEQUENCE -> LALR_INTERNAL_19 . [)/in/then/then/else/end]

Itemset 47
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=
/</-/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-
/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-
/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-
/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/]/,/)/in/then/end/:=/>/
=>/neq/==/<=/</-/+///*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/else/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/else/:string/:symbol/:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==
/<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<
=/</-/+///*/;/else]
 EXPRESSION -> . FUNCALL [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<=/</-/+///*/;/el
se]
 EXPRESSION -> . return EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<=/</-/
+///*/;/else]
 EXPRESSION -> . goto :symbol [end/then/in/)/,/]/eof/:=/>/=>/neq/==/<=/</-/+///*
/;/else]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/then/in/)/,/]/eof/:=/>/=>/neq/
==/<=/</-/+///*/;/else]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/
==/<=/</-/+///*/;/else]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/then/in/)/,/]/eo
f/:=/>/=>/neq/==/<=/</-/+///*/;/else]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/then/in/)/,/]/eof/:=/>/=>/neq/==/
<=/</-/+///*/;/else]
 EXPRESSION -> if SEQUENCE then . EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/)/in/then/else/end]
 EXPRESSION -> if SEQUENCE then . SEQUENCE else EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/]/,/)/in/then/else/end]
 FUNCALL -> . CLOSEDEXPRESSION [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/:string/:symbol/:number/let/(/[/;/else]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/
</-/+///*/:string/:symbol/:number/let/(/[/;/else]
 LALR_INTERNAL_19 -> . EXPRESSION LALR_INTERNAL_21 [else]
 LALR_INTERNAL_19 -> . [else]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [eof/]/,/)/in/then/end/:=/>/=>/n
eq/==/<=/</-/+///*/else/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [eof/]/,/)/in/then/end/:=/>/=>/neq/==/<=/</-/+///
*/else/[/(/let/:number/:symbol/:string/;]
 SEQUENCE -> . LALR_INTERNAL_19 [else]
GOTO(EXPRESSION) = 48
GOTO(SEQUENCE) = 49
GOTO(LALR_INTERNAL_19) = 46
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 48
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/=
=/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==
/neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/then/in/)/,/]/eof/*///+/-/</<=/==/
neq/=>/>/:=/else/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> if SEQUENCE then EXPRESSION . [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 LALR_INTERNAL_19 -> EXPRESSION . LALR_INTERNAL_21 [else]
 LALR_INTERNAL_21 -> . ; EXPRESSION LALR_INTERNAL_21 [else]
 LALR_INTERNAL_21 -> . [else]
GOTO(LALR_INTERNAL_21) = 52
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 49
 EXPRESSION -> if SEQUENCE then SEQUENCE . else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
GOTO(else) = 50

Itemset 50
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)
/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/
then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [eof/;/*///+/-/</<=/==/neq/=
>/>/:=/]/,/)/in/then/else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :number [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 CLOSEDEXPRESSION -> . :symbol [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/=
=/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/
<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///*/;/e
of]
 EXPRESSION -> . return EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
 EXPRESSION -> . goto :symbol [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [end/else/then/in/)/,/]/:=/>/=>/neq/==
/<=/</-/+///*/;/eof]
 EXPRESSION -> if SEQUENCE then SEQUENCE else . EXPRESSION [eof/;/*///+/-/</<=/=
=/neq/=>/>/:=/]/,/)/in/then/else/end]
 FUNCALL -> . CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/:string/:symbol/:number/let/(/[/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/
in/then/else/:string/:symbol/:number/let/(/[/end]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [eof/;/*///+/-/</<=/==/neq/=>/>/
:=/]/,/)/in/then/else/[/(/let/:number/:symbol/:string/end]
 LALR_INTERNAL_22 -> . :string [eof/;/*///+/-/</<=/==/neq/=>/>/:=/]/,/)/in/then/
else/[/(/let/:number/:symbol/:string/end]
GOTO(EXPRESSION) = 51
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 51
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> if SEQUENCE then SEQUENCE else EXPRESSION . [end/else/then/in/)/,
/]/:=/>/=>/neq/==/<=/</-/+///*/;/eof]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 52
 LALR_INTERNAL_19 -> EXPRESSION LALR_INTERNAL_21 . [)/else/end/then/in]

Itemset 53
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [)/;/else/end/then/:=/>/=>/neq/==/<=/</-
/+///*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+//
/*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [)/;/else/end/then/:=/>/=>/n
eq/==/<=/</-/+///*/:string/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . :number [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/:s
tring/:symbol/:number/let/(/[/in]
 CLOSEDEXPRESSION -> . :symbol [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/:s
tring/:symbol/:number/let/(/[/in]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/
end/else/;/)]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/en
d/else/;/)]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/in/then/end/else/;/)]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/end/else
/;/)]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/in/then/end/else/;/)]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/in/the
n/end/else/;/)]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/the
n/end/else/;/)]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/in/then/end/else/;/)]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/in/then/e
nd/else/;/)]
 FUNCALL -> . CLOSEDEXPRESSION [;/)/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/:s
tring/:symbol/:number/let/(/[/in]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [;/)/else/end/then/:=/>/=>/neq/==/<=/</-/
+///*/:string/:symbol/:number/let/(/[/in]
 LALR_INTERNAL_21 -> ; . EXPRESSION LALR_INTERNAL_21 [)/else/end/then/in]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [)/;/else/end/then/:=/>/=>/neq/=
=/<=/</-/+///*/[/(/let/:number/:symbol/:string/in]
 LALR_INTERNAL_22 -> . :string [)/;/else/end/then/:=/>/=>/neq/==/<=/</-/+///*/[/
(/let/:number/:symbol/:string/in]
GOTO(EXPRESSION) = 54
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 54
 EXPRESSION -> EXPRESSION . := EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==
/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/
neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [)/in/then/end/else/;/*///+/-/</<=/==/n
eq/=>/>/:=]
 LALR_INTERNAL_21 -> . ; EXPRESSION LALR_INTERNAL_21 [else/end/then/in/)]
 LALR_INTERNAL_21 -> . [else/end/then/in/)]
 LALR_INTERNAL_21 -> ; EXPRESSION . LALR_INTERNAL_21 [)/in/then/end/else]
GOTO(LALR_INTERNAL_21) = 55
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 55
 LALR_INTERNAL_21 -> ; EXPRESSION LALR_INTERNAL_21 . [)/else/end/then/in]

Itemset 56
 EXPRESSION -> go LALR_INTERNAL_18 . :symbol [end/else/then/in/)/,/]/:=/>/=>/neq
/==/<=/</-/+///*/;/eof]
GOTO(:symbol) = 58

Itemset 57
 LALR_INTERNAL_18 -> to . [:symbol]

Itemset 58
 EXPRESSION -> go LALR_INTERNAL_18 :symbol . [eof/;/*///+/-/</<=/==/neq/=>/>/:=/
]/,/)/in/then/else/end]

Itemset 59
 EXPRESSION -> goto :symbol . [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-/+///
*/;/eof]

Itemset 60
 EXPRESSION -> EXPRESSION . := EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-
/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/
</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [end/else/then/in/)/,/]/;/eof/*///+/-/<
/<=/==/neq/=>/>/:=]
 EXPRESSION -> return EXPRESSION . [end/else/then/in/)/,/]/:=/>/=>/neq/==/<=/</-
/+///*/;/eof]
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 61
 CLOSEDEXPRESSION -> let SEQUENCE . in SEQUENCE end [end/else/=/then/in/)/]/,/:=
/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO(in) = 62

Itemset 62
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/end/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/end/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/end/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> let SEQUENCE in . SEQUENCE end [;/[/(/let/:number/:symbol/:
string/eof/*///+/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/end]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/end]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/end]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/end]
 LALR_INTERNAL_19 -> . EXPRESSION LALR_INTERNAL_21 [end]
 LALR_INTERNAL_19 -> . [end]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/end
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/end/[/(/let/:number/
:symbol/:string/;]
 SEQUENCE -> . LALR_INTERNAL_19 [end]
GOTO(EXPRESSION) = 44
GOTO(SEQUENCE) = 63
GOTO(LALR_INTERNAL_19) = 46
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 63
 CLOSEDEXPRESSION -> let SEQUENCE in SEQUENCE . end [end/else/=/then/in/)/]/,/:=
/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO(end) = 64

Itemset 64
 CLOSEDEXPRESSION -> let SEQUENCE in SEQUENCE end . [;/[/(/let/:number/:symbol/:
string/eof/*///+/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 65
 EXPRESSION -> EXPRESSION . := EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/
*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*
///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [)/,/*///+/-/</<=/==/neq/=>/>/:=/)/;/*/
//+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_19 -> EXPRESSION . LALR_INTERNAL_21 [)]
 LALR_INTERNAL_21 -> . ; EXPRESSION LALR_INTERNAL_21 [)]
 LALR_INTERNAL_21 -> . [)]
 LALR_INTERNAL_24 -> EXPRESSION . LALR_INTERNAL_26 [)]
 LALR_INTERNAL_26 -> . , EXPRESSION LALR_INTERNAL_26 [)]
 LALR_INTERNAL_26 -> . [)]
GOTO(LALR_INTERNAL_21) = 52
GOTO(LALR_INTERNAL_26) = 71
GOTO(,) = 72
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 53

Itemset 66
 CLOSEDEXPRESSION -> ( SEQUENCE . ) [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/
</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO()) = 70

Itemset 67
 CLOSEDEXPRESSION -> ( EXPRLIST . ) [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/
</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO()) = 69

Itemset 68
 EXPRLIST -> LALR_INTERNAL_24 . []/)]

Itemset 69
 CLOSEDEXPRESSION -> ( EXPRLIST ) . [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 70
 CLOSEDEXPRESSION -> ( SEQUENCE ) . [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 71
 LALR_INTERNAL_24 -> EXPRESSION LALR_INTERNAL_26 . []/)]

Itemset 72
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 []/,/:=/>/=>/neq/==/<=/</-/+///*/:string
/:symbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:sy
mbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:sy
mbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:sy
mbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end []/,/:=/>/=>/neq/==/<=/</-/+
///*/:string/:symbol/:number/let/(/[/)]
 CLOSEDEXPRESSION -> . :number []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/
:number/let/(/[/)]
 CLOSEDEXPRESSION -> . :symbol []/,/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/
:number/let/(/[/)]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/)/,/]]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/)/,/]]
 FUNCALL -> . CLOSEDEXPRESSION [,/]/:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/
:number/let/(/[/)]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [,/]/:=/>/=>/neq/==/<=/</-/+///*/:string/
:symbol/:number/let/(/[/)]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 []/,/:=/>/=>/neq/==/<=/</-/+///*
/[/(/let/:number/:symbol/:string/)]
 LALR_INTERNAL_22 -> . :string []/,/:=/>/=>/neq/==/<=/</-/+///*/[/(/let/:number/
:symbol/:string/)]
 LALR_INTERNAL_26 -> , . EXPRESSION LALR_INTERNAL_26 []/)]
GOTO(EXPRESSION) = 73
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 73
 EXPRESSION -> EXPRESSION . := EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION []/)/,/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_26 -> . , EXPRESSION LALR_INTERNAL_26 [)/]]
 LALR_INTERNAL_26 -> . [)/]]
 LALR_INTERNAL_26 -> , EXPRESSION . LALR_INTERNAL_26 []/)]
GOTO(LALR_INTERNAL_26) = 74
GOTO(,) = 72
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 74
 LALR_INTERNAL_26 -> , EXPRESSION LALR_INTERNAL_26 . []/)]

Itemset 75
 EXPRESSION -> EXPRESSION . := EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION []/,/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_24 -> EXPRESSION . LALR_INTERNAL_26 []]
 LALR_INTERNAL_26 -> . , EXPRESSION LALR_INTERNAL_26 []]
 LALR_INTERNAL_26 -> . []]
GOTO(LALR_INTERNAL_26) = 71
GOTO(,) = 72
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32

Itemset 76
 CLOSEDEXPRESSION -> [ EXPRLIST . ] [end/else/=/then/in/)/]/,/:=/>/=>/neq/==/<=/
</-/+///*/eof/:string/:symbol/:number/let/(/[/;]
GOTO(]) = 77

Itemset 77
 CLOSEDEXPRESSION -> [ EXPRLIST ] . [;/[/(/let/:number/:symbol/:string/eof/*///+
/-/</<=/==/neq/=>/>/:=/,/]/)/in/then/=/else/end]

Itemset 78
 LALR_INTERNAL_22 -> :string LALR_INTERNAL_22 . [end/else/=/then/in/)/]/,/:=/>/=
>/neq/==/<=/</-/+///*/eof/[/(/let/:number/:symbol/:string/;]

Itemset 79
 LALR_INTERNAL_15 -> EXPRESSION LALR_INTERNAL_17 . [eof]

Itemset 80
 CLOSEDEXPRESSION -> . LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/eof/:string
/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . [ EXPRLIST ] [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( EXPRLIST ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . ( SEQUENCE ) [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:sy
mbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . let SEQUENCE in SEQUENCE end [:=/>/=>/neq/==/<=/</-/+///*
/eof/:string/:symbol/:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :number [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 CLOSEDEXPRESSION -> . :symbol [:=/>/=>/neq/==/<=/</-/+///*/eof/:string/:symbol/
:number/let/(/[/;]
 EXPRESSION -> . EXPRESSION := EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION > EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION => EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION neq EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION == EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION <= EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION < EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION - EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION + EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION / EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . EXPRESSION * EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . FUNCALL [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . return EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . goto :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . go LALR_INTERNAL_18 :symbol [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 EXPRESSION -> . if SEQUENCE then SEQUENCE else EXPRESSION [:=/>/=>/neq/==/<=/</
-/+///*/;/eof]
 EXPRESSION -> . fun FUNCALL = EXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/;/eof]
 FUNCALL -> . CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:symbol/:num
ber/let/(/[/;/eof]
 FUNCALL -> . FUNCALL CLOSEDEXPRESSION [:=/>/=>/neq/==/<=/</-/+///*/:string/:sym
bol/:number/let/(/[/;/eof]
 LALR_INTERNAL_17 -> ; . EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_22 -> . :string LALR_INTERNAL_22 [:=/>/=>/neq/==/<=/</-/+///*/eof
/[/(/let/:number/:symbol/:string/;]
 LALR_INTERNAL_22 -> . :string [:=/>/=>/neq/==/<=/</-/+///*/eof/[/(/let/:number/
:symbol/:string/;]
GOTO(EXPRESSION) = 81
GOTO(FUNCALL) = 4
GOTO(CLOSEDEXPRESSION) = 5
GOTO(LALR_INTERNAL_22) = 6
GOTO(:string) = 7
GOTO([) = 8
GOTO(() = 9
GOTO(let) = 10
GOTO(:number) = 11
GOTO(return) = 12
GOTO(goto) = 13
GOTO(:symbol) = 14
GOTO(go) = 15
GOTO(if) = 16
GOTO(fun) = 17

Itemset 81
 EXPRESSION -> EXPRESSION . := EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . > EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . => EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . neq EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . == EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . <= EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . < EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . - EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . + EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . / EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 EXPRESSION -> EXPRESSION . * EXPRESSION [eof/;/*///+/-/</<=/==/neq/=>/>/:=]
 LALR_INTERNAL_17 -> . ; EXPRESSION LALR_INTERNAL_17 [eof]
 LALR_INTERNAL_17 -> . [eof]
 LALR_INTERNAL_17 -> ; EXPRESSION . LALR_INTERNAL_17 [eof]
GOTO(LALR_INTERNAL_17) = 82
GOTO(:=) = 22
GOTO(>) = 23
GOTO(=>) = 24
GOTO(neq) = 25
GOTO(==) = 26
GOTO(<=) = 27
GOTO(<) = 28
GOTO(-) = 29
GOTO(+) = 30
GOTO(/) = 31
GOTO(*) = 32
GOTO(;) = 80

Itemset 82
 LALR_INTERNAL_17 -> ; EXPRESSION LALR_INTERNAL_17 . [eof]

Itemset 83
 PROGRAM -> LALR_INTERNAL_15 eof . [$]

+++++ Reduce/reduce conflict in itemset #65 on lookahead )
Reduction #1: LALR_INTERNAL_26 -> <empty>
Reduction #2: LALR_INTERNAL_21 -> <empty>
Resolved in favour of reduction #1

+++ Shift/reduce conflict in itemset #60 on lookahead =>
Reduce: EXPRESSION -> return EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #51 on lookahead =>
Reduce: EXPRESSION -> if SEQUENCE then SEQUENCE else EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #48 on lookahead ;
Reduce: EXPRESSION -> if SEQUENCE then EXPRESSION 
Shift: to state #53
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #48 on lookahead =>
Reduce: EXPRESSION -> if SEQUENCE then EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++++ Reduce/reduce conflict in itemset #48 on lookahead else
Reduction #1: LALR_INTERNAL_21 -> <empty>
Reduction #2: EXPRESSION -> if SEQUENCE then EXPRESSION 
Resolved in favour of reduction #1

+++ Shift/reduce conflict in itemset #43 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION := EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #42 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION > EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead *
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #32
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead /
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #31
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead +
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #30
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead -
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #29
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead <
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #28
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead <=
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #27
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead ==
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #26
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead neq
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #25
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead >
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #23
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #41 on lookahead :=
Reduce: EXPRESSION -> EXPRESSION => EXPRESSION 
Shift: to state #22
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #40 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION neq EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #39 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION == EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #38 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION <= EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #37 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION < EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #36 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION - EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #35 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION + EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #34 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION / EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #33 on lookahead =>
Reduce: EXPRESSION -> EXPRESSION * EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++ Shift/reduce conflict in itemset #21 on lookahead =>
Reduce: EXPRESSION -> fun FUNCALL = EXPRESSION 
Shift: to state #24
Resolved in favour of the shift operation

+++++ Reduce/reduce conflict in itemset #9 on lookahead )
Reduction #1: LALR_INTERNAL_24 -> <empty>
Reduction #2: LALR_INTERNAL_19 -> <empty>
Resolved in favour of reduction #1

+++ Shift/reduce conflict in itemset #7 on lookahead :string
Reduce: LALR_INTERNAL_22 -> :string 
Shift: to state #7
Resolved in favour of the shift operation

=== ACTION TABLE ===
STATE TERMINAL      ACTION
0     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
1     <any>         accept
2     eof           shift to state 83
3     ;             shift to state 80
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #4: LALR_INTERNAL_17 -> [0 symbols] 
4     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #22: EXPRESSION -> [1 symbols] 
5     <any>         reduce by #31: FUNCALL -> [1 symbols] 
6     <any>         reduce by #35: CLOSEDEXPRESSION -> [1 symbols] 
7     :string       shift to state 7
      <any>         reduce by #37: LALR_INTERNAL_22 -> [1 symbols] (lambda (
                                                                   !$1) (list 
                                                                   !$1))
8     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #40: LALR_INTERNAL_24 -> [0 symbols] 
9     :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #40: LALR_INTERNAL_24 -> [0 symbols] 
10    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #27: LALR_INTERNAL_19 -> [0 symbols] 
11    <any>         reduce by #35: CLOSEDEXPRESSION -> [1 symbols] 
12    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
13    :symbol       shift to state 59
14    <any>         reduce by #35: CLOSEDEXPRESSION -> [1 symbols] 
15    to            shift to state 57
      <any>         reduce by #24: LALR_INTERNAL_18 -> [0 symbols] 
16    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #27: LALR_INTERNAL_19 -> [0 symbols] 
17    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
18    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      =             shift to state 20
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
19    <any>         reduce by #30: FUNCALL -> [2 symbols] 
20    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
21    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #10: EXPRESSION -> [4 symbols] (lambda (!$1 !$2 
                                                             !$3 !$4) (list (
                                                             quote fun) !$2 
                                                             !$4))
22    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
23    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
24    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
25    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
26    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
27    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
28    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
29    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
30    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
31    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
32    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
33    =>            shift to state 24
      <any>         reduce by #21: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote times) !$1 
                                                             !$3))
34    =>            shift to state 24
      <any>         reduce by #20: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote quotient) 
                                                             !$1 !$3))
35    *             shift to state 32
      /             shift to state 31
      =>            shift to state 24
      <any>         reduce by #19: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote plus) !$1 
                                                             !$3))
36    *             shift to state 32
      /             shift to state 31
      =>            shift to state 24
      <any>         reduce by #18: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote difference)
                                                             !$1 !$3))
37    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #17: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote lessp) !$1 
                                                             !$3))
38    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #16: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote lesseq) 
                                                             !$1 !$3))
39    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #15: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote equals) 
                                                             !$1 !$3))
40    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #14: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote neq) !$1 
                                                             !$3))
41    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #13: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote geq) !$1 
                                                             !$3))
42    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      =>            shift to state 24
      <any>         reduce by #12: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote greaterp) 
                                                             !$1 !$3))
43    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #11: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                             !$3) (list (
                                                             quote setq) !$1 
                                                             !$3))
44    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #29: LALR_INTERNAL_21 -> [0 symbols] 
45    then          shift to state 47
46    <any>         reduce by #25: SEQUENCE -> [1 symbols] 
47    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #27: LALR_INTERNAL_19 -> [0 symbols] 
48    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      else          reduce by #29: LALR_INTERNAL_21 -> [0 symbols] 
      <any>         reduce by #9: EXPRESSION -> [4 symbols] (lambda (!$1 !$2 
                                                            !$3 !$4) (list (
                                                            quote cond) (list 
                                                            !$2 !$4)))
49    else          shift to state 50
50    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
51    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #8: EXPRESSION -> [6 symbols] (lambda (!$1 !$2 
                                                            !$3 !$4 !$5 !$6) (
                                                            list (quote cond) 
                                                            (list !$2 !$4) (
                                                            list t !$6)))
52    <any>         reduce by #26: LALR_INTERNAL_19 -> [2 symbols] (lambda (
                                                                   !$1 !$2) (
                                                                   cons !$1 
                                                                   !$2))
53    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
54    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #29: LALR_INTERNAL_21 -> [0 symbols] 
55    <any>         reduce by #28: LALR_INTERNAL_21 -> [3 symbols] (lambda (
                                                                   !$1 !$2 
                                                                   !$3) (cons 
                                                                   !$2 !$3))
56    :symbol       shift to state 58
57    <any>         reduce by #23: LALR_INTERNAL_18 -> [1 symbols] 
58    <any>         reduce by #7: EXPRESSION -> [3 symbols] (lambda (!$1 !$2 
                                                            !$3) (list (quote 
                                                            go) !$3))
59    <any>         reduce by #6: EXPRESSION -> [2 symbols] (lambda (!$1 !$2) 
                                                            (list (quote go) 
                                                            !$2))
60    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #5: EXPRESSION -> [2 symbols] 
61    in            shift to state 62
62    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
      <any>         reduce by #27: LALR_INTERNAL_19 -> [0 symbols] 
63    end           shift to state 64
64    <any>         reduce by #34: CLOSEDEXPRESSION -> [5 symbols] (lambda (
                                                                   !$1 !$2 
                                                                   !$3 !$4 
                                                                   !$5) (list 
                                                                   (quote 
                                                                   letstat) 
                                                                   !$2 !$4))
65    ;             shift to state 53
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      ,             shift to state 72
      <any>         reduce by #42: LALR_INTERNAL_26 -> [0 symbols] 
66    )             shift to state 70
67    )             shift to state 69
68    <any>         reduce by #38: EXPRLIST -> [1 symbols] 
69    <any>         reduce by #33: CLOSEDEXPRESSION -> [3 symbols] (lambda (
                                                                   !$1 !$2 
                                                                   !$3) (cons 
                                                                   (quote 
                                                                   paren) !$2)
                                                                   )
70    <any>         reduce by #33: CLOSEDEXPRESSION -> [3 symbols] (lambda (
                                                                   !$1 !$2 
                                                                   !$3) (cons 
                                                                   (quote 
                                                                   paren) !$2)
                                                                   )
71    <any>         reduce by #39: LALR_INTERNAL_24 -> [2 symbols] (lambda (
                                                                   !$1 !$2) (
                                                                   cons !$1 
                                                                   !$2))
72    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
73    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      ,             shift to state 72
      <any>         reduce by #42: LALR_INTERNAL_26 -> [0 symbols] 
74    <any>         reduce by #41: LALR_INTERNAL_26 -> [3 symbols] (lambda (
                                                                   !$1 !$2 
                                                                   !$3) (cons 
                                                                   !$2 !$3))
75    *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      ,             shift to state 72
      <any>         reduce by #42: LALR_INTERNAL_26 -> [0 symbols] 
76    ]             shift to state 77
77    <any>         reduce by #32: CLOSEDEXPRESSION -> [3 symbols] (lambda (
                                                                   !$1 !$2 
                                                                   !$3) (cons 
                                                                   (quote 
                                                                   bracket) 
                                                                   !$2))
78    <any>         reduce by #36: LALR_INTERNAL_22 -> [2 symbols] (lambda (
                                                                   !$1 !$2) (
                                                                   cons !$1 
                                                                   !$2))
79    <any>         reduce by #2: LALR_INTERNAL_15 -> [2 symbols] (lambda (
                                                                  !$1 !$2) (
                                                                  cons !$1 
                                                                  !$2))
80    :symbol       shift to state 14
      :string       shift to state 7
      :number       shift to state 11
      fun           shift to state 17
      if            shift to state 16
      go            shift to state 15
      goto          shift to state 13
      return        shift to state 12
      let           shift to state 10
      (             shift to state 9
      [             shift to state 8
81    ;             shift to state 80
      *             shift to state 32
      /             shift to state 31
      +             shift to state 30
      -             shift to state 29
      <             shift to state 28
      <=            shift to state 27
      ==            shift to state 26
      neq           shift to state 25
      =>            shift to state 24
      >             shift to state 23
      :=            shift to state 22
      <any>         reduce by #4: LALR_INTERNAL_17 -> [0 symbols] 
82    <any>         reduce by #3: LALR_INTERNAL_17 -> [3 symbols] (lambda (
                                                                  !$1 !$2 !$3)
                                                                  (cons !$2 
                                                                  !$3))
83    <any>         reduce by #1: PROGRAM -> [2 symbols] (lambda (!$1 !$2) 
                                                         !$1)

=== GOTO TABLE ===
NONTERMINAL         SRC     DEST
PROGRAM             <any>   1
LALR_INTERNAL_15    <any>   2
LALR_INTERNAL_17    81      82
                    <any>   79
EXPRESSION          0       3
                    20      21
                    32      33
                    31      34
                    30      35
                    29      36
                    28      37
                    27      38
                    26      39
                    25      40
                    24      41
                    23      42
                    22      43
                    47      48
                    50      51
                    53      54
                    12      60
                    9       65
                    72      73
                    8       75
                    80      81
                    <any>   44
LALR_INTERNAL_18    <any>   56
SEQUENCE            47      49
                    10      61
                    62      63
                    9       66
                    <any>   45
LALR_INTERNAL_19    <any>   46
LALR_INTERNAL_21    54      55
                    <any>   52
FUNCALL             17      18
                    <any>   4
CLOSEDEXPRESSION    18      19
                    4       19
                    <any>   5
LALR_INTERNAL_22    7       78
                    <any>   6
EXPRLIST            8       76
                    <any>   67
LALR_INTERNAL_24    <any>   68
LALR_INTERNAL_26    73      74
                    <any>   71



pparse g$

yylex initialized

fun 
yylex = fun type 42
Shift token fun onto stack, and shift to state 17
f(
yylex = f type 1
Shift token f onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 18
a
yylex = !( type 53
Shift token !( onto stack, and shift to state 9
,
yylex = a type 1
Shift token a onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !, type 57
On lookahead 57, reduce 1 symbols to nonterminal EXPRESSION, and goto state 65
Shift token !, onto stack, and shift to state 72
b)
yylex = b type 1
Shift token b onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !) type 54
On lookahead 54, reduce 1 symbols to nonterminal EXPRESSION, and goto state 73
On lookahead 54, reduce 0 symbols to nonterminal LALR_INTERNAL_26
, and goto state 74
On lookahead 54, reduce 3 symbols to nonterminal LALR_INTERNAL_26
, and goto state 71
On lookahead 54, reduce 2 symbols to nonterminal LALR_INTERNAL_24
, and goto state 68
On lookahead 54, reduce 1 symbols to nonterminal EXPRLIST, and goto state 67
Shift token !) onto stack, and shift to state 69
On lookahead -1, reduce 3 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 19
On lookahead -1, reduce 2 symbols to nonterminal FUNCALL, and goto state 18
 = 
yylex = != type 36
Shift token != onto stack, and shift to state 20
a 
yylex = a type 1
Shift token a onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
+
yylex = !+ type 31
On lookahead 31, reduce 1 symbols to nonterminal EXPRESSION, and goto state 21
Shift token !+ onto stack, and shift to state 30
 b;
yylex = b type 1
Shift token b onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !; type 28
On lookahead 28, reduce 1 symbols to nonterminal EXPRESSION, and goto state 35
On lookahead 28, reduce 3 symbols to nonterminal EXPRESSION, and goto state 21
On lookahead 28, reduce 4 symbols to nonterminal EXPRESSION, and goto state 3
Shift token !; onto stack, and shift to state 80

f(
yylex = f type 1
Shift token f onto stack, and shift to state 14
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
2
yylex = !( type 53
Shift token !( onto stack, and shift to state 9
2,
yylex = 22 type 5
Shift token 22 onto stack, and shift to state 11
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !, type 57
On lookahead 57, reduce 1 symbols to nonterminal EXPRESSION, and goto state 65
Shift token !, onto stack, and shift to state 72
33)
yylex = 33 type 5
Shift token 33 onto stack, and shift to state 11
On lookahead -1, reduce 1 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 5
On lookahead -1, reduce 1 symbols to nonterminal FUNCALL, and goto state 4
yylex = !) type 54
On lookahead 54, reduce 1 symbols to nonterminal EXPRESSION, and goto state 73
On lookahead 54, reduce 0 symbols to nonterminal LALR_INTERNAL_26
, and goto state 74
On lookahead 54, reduce 3 symbols to nonterminal LALR_INTERNAL_26
, and goto state 71
On lookahead 54, reduce 2 symbols to nonterminal LALR_INTERNAL_24
, and goto state 68
On lookahead 54, reduce 1 symbols to nonterminal EXPRLIST, and goto state 67
Shift token !) onto stack, and shift to state 69
On lookahead -1, reduce 3 symbols to nonterminal CLOSEDEXPRESSION
, and goto state 19
On lookahead -1, reduce 2 symbols to nonterminal FUNCALL, and goto state 4

eof
yylex = eof type 27
On lookahead 27, reduce 1 symbols to nonterminal EXPRESSION, and goto state 81
On lookahead 27, reduce 0 symbols to nonterminal LALR_INTERNAL_17
, and goto state 82
On lookahead 27, reduce 3 symbols to nonterminal LALR_INTERNAL_17
, and goto state 79
On lookahead 27, reduce 2 symbols to nonterminal LALR_INTERNAL_15
, and goto state 2
Shift token eof onto stack, and shift to state 83
On lookahead -1, reduce 2 symbols to nonterminal PROGRAM, and goto state 1
Seems to have finished... 
= ((fun (f (paren a b)) (plus a b)) (f (paren 22 33)))

end;

nil
Tested on x86_64-pc-windows CSL
Time: lalr  94  0
1: Leaving REDUCE ... 


End of Lisp run after 0.14+0.01 seconds
